import * as R from "ramda";
import {
  getStorageModule,
  applyNamespaceToKeyName,
  STORAGE_TYPES,
  DEFAULT_NAMESPACE,
} from "../index";
import { StorageMock } from "./StorageMocks";

import * as functionUtils from "@applicaster/zapp-react-native-utils/functionUtils";

const noopSpy = jest.spyOn(functionUtils, "noop");
const consoleSpy = jest.spyOn(console, "warn").mockImplementation(() => {});

global.window = {
  sessionStorage: new StorageMock("sessionStorage"),
  localStorage: new StorageMock("localStorage"),
};

function resetMocks() {
  noopSpy.mockClear();
  consoleSpy.mockClear();
}

function clearStorage() {
  R.forEach(storage => global.window[storage].clear(), STORAGE_TYPES);
}

async function testStorage(expectations) {
  await Promise.all(
    R.map(storage => {
      const Storage = getStorageModule(storage);
      expectations(Storage);
    }, STORAGE_TYPES)
  );
}

describe("storageObject", () => {
  beforeEach(resetMocks);

  describe("when the requested storage exists", () => {
    const key = "foo";
    const value = "bar";
    const namespaceValue = "baz";
    const namespace = "baz";
    const keyName = applyNamespaceToKeyName(key, namespace);
    const failKey = "fail_key";

    beforeEach(clearStorage);

    it("returns an object with 3 methods", () => {
      expect.assertions(6);

      testStorage(Storage => {
        expect(Storage).toHaveProperty("setItem");
        expect(Storage).toHaveProperty("getItem");
        expect(Storage).toHaveProperty("getAllItems");
      });
    });

    describe("setItem", () => {
      beforeEach(clearStorage);

      it("sets a property in the storage", async () => {
        expect.assertions(4);

        await testStorage(async Storage => {
          const result = await Storage.setItem(key, value, null);
          const keyWithDefaultNameSpace = applyNamespaceToKeyName(
            key,
            DEFAULT_NAMESPACE
          );

          expect(result).toBe(true);
          expect(Storage[keyWithDefaultNameSpace]).toEqual(value);
        });
      });

      it("sets a property in the storage with a namespace", async () => {
        expect.assertions(4);

        await testStorage(async Storage => {
          const result = await Storage.setItem(key, namespaceValue, namespace);

          expect(result).toBe(true);
          expect(Storage[keyName]).toEqual(namespaceValue);
        });
      });

      it("will reject a promise if it the setting of the data fails", async () => {
        expect.assertions(2);

        await testStorage(async Storage => {
          await expect(
            Storage.setItem(failKey, value)
          ).rejects.toMatchSnapshot();
        });
      });
    });

    describe("getItem", () => {
      beforeEach(async () => {
        clearStorage();
        await testStorage(async Storage => {
          Storage.setItem(key, value, null);
          Storage.setItem(key, namespaceValue, namespace);
        });
      });

      it("gets properties from the storage", async () => {
        expect.assertions(8);

        await testStorage(async Storage => {
          await expect(Storage.getItem(key)).resolves.toEqual(value);
          await expect(Storage.getItem(key)).resolves.toMatchSnapshot();
          await expect(Storage.getItem(key, null)).resolves.toEqual(value);
          await expect(Storage.getItem(key, null)).resolves.toMatchSnapshot();
        });
      });

      it("gets properties from the storage with a namespace", async () => {
        expect.assertions(4);

        await testStorage(async Storage => {
          await expect(Storage.getItem(key, namespace)).resolves.toEqual(
            namespaceValue
          );

          await expect(
            Storage.getItem(key, namespace)
          ).resolves.toMatchSnapshot();
        });
      });

      it("rejects if the property cannot be retrieved", async () => {
        expect.assertions(2);

        await testStorage(async Storage => {
          await expect(Storage.getItem(failKey)).rejects.toMatchSnapshot();
        });
      });
    });

    describe("getAllItems", () => {
      beforeEach(async () => {
        clearStorage();
        await testStorage(async Storage => {
          await Storage.setItem(key, value);
          await Storage.setItem(key, namespaceValue, namespace);
          await Storage.setItem("otherKey", "otherValue");
          await Storage.setItem("otherKey", "otherValue", namespace);
        });
      });

      it("returns all keys", async () => {
        expect.assertions(2);

        await testStorage(async Storage => {
          await expect(Storage.getAllItems()).resolves.toMatchSnapshot();
        });
      });

      it("returns all keys in the namespace if provided", async () => {
        expect.assertions(2);

        await testStorage(async Storage => {
          await expect(
            Storage.getAllItems(namespace)
          ).resolves.toMatchSnapshot();
        });
      });
    });
  });

  describe("when the request storage doesn't exist", () => {
    it("returns the noop function and displays a message in the console", () => {
      const storageType = "some_storage";
      const Storage = getStorageModule(storageType);
      Storage.setItem();

      expect(noopSpy).toHaveBeenCalled();
      expect(consoleSpy).toHaveBeenCalledWith(
        `Storage type ${storageType} does not exist in this environment`
      );
    });
  });
});
