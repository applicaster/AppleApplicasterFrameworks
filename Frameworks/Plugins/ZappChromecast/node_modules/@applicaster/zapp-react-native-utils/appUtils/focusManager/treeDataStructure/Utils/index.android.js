import * as R from "ramda";
import { rejectItemByPath } from "../../../../objectUtils";
import {
  measureDistance,
  measureEuclidianDistanceToCenter,
} from "@applicaster/zapp-react-native-utils/rectUtils";

import { mapAsync } from "../../../../functionUtils";

export const FocusDirection = {
  LEFT: 1,
  TOP: 2,
  RIGHT: 4,
  BOTTOM: 8,
};

/**
 * Function search down the tree for priority item in given children array.
 * Priorities are:
 * Priority 1: Currently selected item - like a menu item
 * Priority 2: Previously focused item in the parent group
 * Priority 3: Preferrable items - items which have been marked as preferable
 * Priority 4: First item on the list - if by any accident above priories are not satisfied
 * @private
 * @param {Array} children
 * @returns focusable priority item.
 */
export function findPriorityItem(children) {
  let preferedGroups = getPriorityItems(children);

  if (preferedGroups.length > 0 && !preferedGroups[0].children) {
    return preferedGroups;
  }

  preferedGroups = preferedGroups.filter(
    it =>
      it.children &&
      it.children.length > 0 &&
      it.children.filter(obj => obj && obj.component.props.preferredFocus)
        .length > 0
  );

  while (
    preferedGroups.length > 0 &&
    preferedGroups[0].children &&
    preferedGroups[0].children.length > 0
  ) {
    preferedGroups = getPriorityItems(preferedGroups[0].children);
  }

  return preferedGroups;
}

/**
 * Function search for currently selected item - like a menu item.
 * @private
 * @param {Array} children
 * @returns array of selected items
 */
export function getSelectedItems(children) {
  let selectedItems = children.filter(
    obj => obj && obj.component.props.selected
  );
  return selectedItems;
}

/**
 * Function search for previously focused item in the parent group.
 * @private
 * @param {Array} children
 * @returns array of last focus items
 */
export function getLastFocusedItems(children) {
  let lastFocusedItems = children.filter(
    obj => obj && obj.id === obj.parent.lastFocusedItem
  );
  return lastFocusedItems;
}

/**
 * Function search for items which have been marked as preferable.
 * @private
 * @param {Array} children
 * @returns array of prefereable focus items
 */
export function getPreferableItems(children) {
  let preferredItems = children.filter(
    obj => obj && obj.component.props.preferredFocus
  );

  return preferredItems;
}

/**
 * Function search for priority items in children array. Priorities are:
 * Priority 1: Currently selected item - like a menu item
 * Priority 2: Previously focused item in the parent group
 * Priority 3: Preferrable items - items which have been marked as preferable
 * Priority 4: First item on the list - if by any accident above priories are not satisfied
 * @private
 * @param {Array} children
 * @returns array of pririty focus items
 */
export function getPriorityItems(children) {
  const selectedItems = getSelectedItems(children);
  const lastFocusedItems = getLastFocusedItems(children);
  const preferredItems = getPreferableItems(children);
  if (selectedItems.length > 0) {
    return selectedItems;
  } else if (lastFocusedItems.length > 0) {
    return lastFocusedItems;
  } else if (preferredItems.length > 0) {
    return preferredItems;
  } else if (children.length > 0) {
    return [children[0]];
  }
  return [];
}

/**
 * Get target in shortest distance in specified direction
 * @private
 * @param {Object} direction of the navigation, which led to this focus change
 * @param {Object} excludedNode node which should be excluded from target group
 * @param {Array} targetNodes array of input target nodes
 * @param {Object} comparisonRect rectangle to compare sides in direction.
 * @returns {Object} target in direction.
 */
export async function getTargetInDirection(
  direction,
  excludedNode,
  targetNodes,
  comparisonRect
) {
  const targets = rejectItemByPath(["id"], excludedNode.id, targetNodes);

  const targetsWithDistances = await mapAsync(async target => {
    const targetRect = await target.component.getRect();

    return {
      distance: measureDistance(direction, comparisonRect, targetRect),
      euclidianDistance: measureEuclidianDistanceToCenter(
        comparisonRect,
        targetRect
      ),
      target,
      targetRect,
    };
  }, targets);

  const distances = targetsWithDistances.filter(obj => obj.distance >= 0);

  if (!distances || distances.length === 0) {
    return null;
  }

  const match = R.compose(
    R.head,
    R.sortBy(it => it.euclidianDistance),
    R.head,
    R.values,
    R.groupBy(it => it.distance)
  )(distances);

  return match ? match.target : null;
}

/**
 * Find focusable node in direction from currentFocusedNode.
 * If it does not find a node in current group it seach parent node
 * incuding deep search inside simbilngs of parent. Search goes up the tree
 * until find next focusable item or tree ends.
 * @public
 * @param {Object} direction of the navigation, which led to this focus change
 * @param {Object} currentFocusNode currently focused node as start point of search
 * @returns {Object} focusable node in direction.
 */
export async function findFocusableNode(direction, currentFocusNode) {
  const currentFocusable = currentFocusNode.component || null;
  if (currentFocusable) {
    const currentFocusableRect = await currentFocusable.getRect();

    let focusableNode = await getTargetInDirection(
      direction,
      currentFocusNode,
      currentFocusNode.parent.children,
      currentFocusableRect
    );

    const parentHasPriority =
      currentFocusNode.parent.component &&
      hasPriorityInDirection(direction, currentFocusNode.parent.component);

    const canFindParentSibling = await findFocusableNode(
      direction,
      currentFocusNode.parent
    );

    if (parentHasPriority && canFindParentSibling) {
      return canFindParentSibling;
    } else if (focusableNode && focusableNode.component) {
      // inside group
      return focusableNode;
    } else {
      // outside group
      let parentFocusableNode = currentFocusNode;
      // going up the structure untill sibling node
      while (
        !focusableNode &&
        parentFocusableNode &&
        parentFocusableNode.parent &&
        parentFocusableNode.parent.parent
      ) {
        parentFocusableNode = parentFocusableNode.parent;

        focusableNode = await getTargetInDirection(
          direction,
          parentFocusableNode, // excluded sibling parent of current focuable
          parentFocusableNode.parent.children, // siblings of parent
          currentFocusableRect
        );
      }

      if (focusableNode) {
        const preferred = findPriorityItem(focusableNode.children);
        return preferred[0];
      }
    }
  }
}

/**
 * Checks of component has priority in the direction. It is used to navigate
 * outside of the group if group has priotity in specified direction.
 * @public
 * @param {Object} direction of the navigation, which led to this focus change
 * @param {Object} component - object to check props.prioritiseFocusOn
 * @returns {Boolean} TRUE if object has priority in direction.
 * @returns {Boolean} FALSE if object has NO priority in direction.
 */
export function hasPriorityInDirection(direction, component) {
  const { prioritiseFocusOn = 0 } = component.props;
  const directionMapper = {
    left: 1,
    up: 2,
    right: 4,
    down: 8,
  };
  const mappedDirection = directionMapper[direction.value];
  return (prioritiseFocusOn & mappedDirection) > 0;
}
