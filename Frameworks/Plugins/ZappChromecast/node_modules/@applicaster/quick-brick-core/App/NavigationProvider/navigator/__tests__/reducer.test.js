import reducer, {
  ACTIONS,
  push,
  replace,
  back,
  setNavBarVisibility,
  setNavBarTitle,
  setNavBarSummary,
  initialState,
} from "../reducer";

describe("ACTIONS", () => {
  it("matches snapshot", () => {
    expect(ACTIONS).toMatchSnapshot();
  });
});

describe("actions", () => {
  describe("push", () => {
    it("returns a push action", () => {
      const route = "/river/A1234";
      const state = { foo: "bar" };
      const action = push(route, state);

      expect(action).toHaveProperty("type", ACTIONS.PUSH);

      expect(action).toHaveProperty(
        "payload",
        expect.objectContaining({
          route,
          state,
        })
      );
    });
  });

  describe("replace", () => {
    it("returns a replace action", () => {
      const route = "/river/A1234";
      const state = { foo: "bar" };
      const action = replace(route, state);

      expect(action).toHaveProperty("type", ACTIONS.REPLACE);

      expect(action).toHaveProperty(
        "payload",
        expect.objectContaining({
          route,
          state,
        })
      );
    });
  });

  describe("back", () => {
    it("returns a back action", () => {
      const backAction = back();

      expect(backAction).toHaveProperty("type", ACTIONS.BACK);
      expect(backAction).toHaveProperty(
        "payload",
        expect.objectContaining({
          route: undefined,
          state: undefined,
        })
      );
    });
  });

  describe("setNavBarVisibility", () => {
    it("returns a setNavBarVisibility action", () => {
      const payload = true;
      const setNavBarVisibilityAction = setNavBarVisibility(payload);

      expect(setNavBarVisibilityAction).toHaveProperty(
        "type",
        ACTIONS.SET_NAV_BAR_VISIBILITY
      );
      expect(setNavBarVisibilityAction).toHaveProperty("payload", payload);
    });
  });

  describe("setNavBarTitle", () => {
    it("returns a setNavBarTitle action", () => {
      const payload = "Screen Title";
      const setNavBarTitleAction = setNavBarTitle(payload);

      expect(setNavBarTitleAction).toHaveProperty(
        "type",
        ACTIONS.SET_NAV_BAR_TITLE
      );
      expect(setNavBarTitleAction).toHaveProperty("payload", payload);
    });
  });

  describe("setNavBarSummary", () => {
    it("returns a setNavBarSummary action", () => {
      const payload = "Screen Summary";
      const setNavBarSummaryAction = setNavBarSummary(payload);

      expect(setNavBarSummaryAction).toHaveProperty(
        "type",
        ACTIONS.SET_NAV_BAR_SUMMARY
      );
      expect(setNavBarSummaryAction).toHaveProperty("payload", payload);
    });
  });
});

describe("reducer", () => {
  const route = "/river/A1234";
  const state = { foo: "bar" };
  const route2 = "/river/B7890";
  const state2 = { bar: "baz" };

  it("has the proper inital state", () => {
    const state = reducer();
    expect(state).toEqual(initialState);
  });

  describe("when a push action is dispatched", () => {
    const action = replace(route, state);
    const newState = reducer(initialState, action);
    const action2 = push(route2, state2);
    const newState2 = reducer(newState, action2);

    it("adds a navigation entry to the stack", () => {
      expect(newState).toHaveProperty("stack");
      expect(newState.stack).toBeArrayOfSize(1);
      expect(newState.stack[0]).toHaveProperty("action", ACTIONS.REPLACE);
      expect(newState.stack[0]).toHaveProperty("route", route);
      expect(newState.stack[0]).toHaveProperty("state", state);

      expect(newState2).toHaveProperty("stack");
      expect(newState2.stack).toBeArrayOfSize(2);
      expect(newState2.stack[0]).toHaveProperty("action", ACTIONS.REPLACE);
      expect(newState2.stack[0]).toHaveProperty("route", route);
      expect(newState2.stack[0]).toHaveProperty("state", state);
      expect(newState2.stack[1]).toHaveProperty("action", ACTIONS.PUSH);
      expect(newState2.stack[1]).toHaveProperty("route", route2);
      expect(newState2.stack[1]).toHaveProperty("state", state2);
    });

    it("leaves navBar properties in state unchanged", () => {
      expect(newState.navBar).toEqual(initialState.navBar);
      expect(newState2.navBar).toEqual(initialState.navBar);
    });

    it("updates the location properties of the state", () => {
      expect(newState).toHaveProperty("location");
      expect(newState.location).toHaveProperty("pathname", route);
      expect(newState.location).toHaveProperty("state", state);

      expect(newState2).toHaveProperty("location");
      expect(newState2.location).toHaveProperty("pathname", route2);
      expect(newState2.location).toHaveProperty("state", state2);
    });
  });

  describe("when a replace action is dispatched", () => {
    const action = replace(route, state);
    const newState = reducer(initialState, action);
    const action2 = replace(route2, state2);
    const newState2 = reducer(newState, action2);

    it("resets the stack and adds an entry when replace is called", () => {
      expect(newState).toHaveProperty("stack");
      expect(newState.stack).toBeArrayOfSize(1);
      expect(newState.stack[0]).toHaveProperty("action", ACTIONS.REPLACE);
      expect(newState.stack[0]).toHaveProperty("route", route);
      expect(newState.stack[0]).toHaveProperty("state", state);

      expect(newState2).toHaveProperty("stack");
      expect(newState2.stack).toBeArrayOfSize(1);
      expect(newState2.stack[0]).toHaveProperty("action", ACTIONS.REPLACE);
      expect(newState2.stack[0]).toHaveProperty("route", route2);
      expect(newState2.stack[0]).toHaveProperty("state", state2);
    });

    it("leaves navBar properties in state unchanged", () => {
      expect(newState.navBar).toEqual(initialState.navBar);
      expect(newState2.navBar).toEqual(initialState.navBar);
    });

    it("updates the location properties of the state", () => {
      expect(newState).toHaveProperty("location");
      expect(newState.location).toHaveProperty("pathname", route);
      expect(newState.location).toHaveProperty("state", state);

      expect(newState2).toHaveProperty("location");
      expect(newState2.location).toHaveProperty("pathname", route2);
      expect(newState2.location).toHaveProperty("state", state2);
    });
  });

  describe("when a back action is dispatched", () => {
    describe("when there's more than one entry in the stack", () => {
      const action = replace(route, state);
      const newState = reducer(initialState, action);
      const action2 = push(route2, state2);
      const newState2 = reducer(newState, action2);
      const backAction = back();
      const finalState = reducer(newState2, backAction);

      it("removes the last item when going back and there's more than 1 entry", () => {
        expect(finalState).toHaveProperty("stack");
        expect(finalState.stack).toBeArrayOfSize(newState2.stack.length - 1);
        expect(finalState.stack[0]).toHaveProperty("action", ACTIONS.BACK);
        expect(finalState.stack[0]).toHaveProperty("route", route);
        expect(finalState.stack[0]).toHaveProperty("state", state);
      });

      it("leaves navBar properties in state unchanged", () => {
        expect(newState.navBar).toEqual(initialState.navBar);
        expect(newState2.navBar).toEqual(initialState.navBar);
        expect(finalState.navBar).toEqual(initialState.navBar);
      });

      it("updates the location properties of the state", () => {
        expect(newState).toHaveProperty("location");
        expect(newState.location).toHaveProperty("pathname", route);
        expect(newState.location).toHaveProperty("state", state);

        expect(newState2).toHaveProperty("location");
        expect(newState2.location).toHaveProperty("pathname", route2);
        expect(newState2.location).toHaveProperty("state", state2);

        expect(finalState).toHaveProperty("location");
        expect(finalState.location).toHaveProperty("pathname", route);
        expect(finalState.location).toHaveProperty("state", state);
      });
    });

    describe("when there's only one entry in the stack", () => {
      const action = replace(route, state);
      const newState = reducer(initialState, action);
      const backAction = back();
      const finalState = reducer(newState, backAction);

      it("returns the same entry when going back and there's one entry", () => {
        expect(finalState).toHaveProperty("stack");
        expect(finalState.stack).toBeArrayOfSize(1);
        expect(finalState.stack[0]).toHaveProperty("action", ACTIONS.REPLACE);
        expect(finalState.stack[0]).toHaveProperty("route", route);
        expect(finalState.stack[0]).toHaveProperty("state", state);
        expect(finalState).toEqual(newState);
      });
    });

    describe("when there are hooks in the stack", () => {
      const action = replace(route, state);
      const newState = reducer(initialState, action);
      const hookPayload = { ...state, isHook: true };
      const hookRoute = "/hooks/hook-id";
      const hookAction = push(hookRoute, hookPayload);
      const newState2 = reducer(newState, hookAction);
      const hookPayload2 = { ...hookPayload, hook2: true };
      const hookRoute2 = "/hooks/hook-id-2";
      const hookAction2 = push(hookRoute2, hookPayload2);
      const newState3 = reducer(newState2, hookAction2);
      const finalState = reducer(newState3, back());

      it("goes back to the previous entry in the stack before the hooks", () => {
        expect(finalState).toHaveProperty("stack");
        expect(finalState.stack).toBeArrayOfSize(1);
        expect(finalState.stack[0]).toHaveProperty("action", ACTIONS.BACK);
        expect(finalState.stack[0]).toHaveProperty("route", route);
        expect(finalState.stack[0]).toHaveProperty("state", state);
      });

      it("restores the location properties of the state", () => {
        expect(newState).toHaveProperty("location");
        expect(newState.location).toHaveProperty("pathname", route);
        expect(newState.location).toHaveProperty("state", state);

        expect(newState2).toHaveProperty("location");
        expect(newState2.location).toHaveProperty("pathname", hookRoute);
        expect(newState2.location).toHaveProperty("state", hookPayload);

        expect(newState3).toHaveProperty("location");
        expect(newState3.location).toHaveProperty("pathname", hookRoute2);
        expect(newState3.location).toHaveProperty("state", hookPayload2);

        expect(finalState).toHaveProperty("location");
        expect(finalState.location).toHaveProperty("pathname", route);
        expect(finalState.location).toHaveProperty("state", state);
      });

      it("leaves the navBar properties of the state unchanged", () => {
        expect(newState.navBar).toEqual(initialState.navBar);
        expect(newState2.navBar).toEqual(initialState.navBar);
        expect(newState3.navBar).toEqual(initialState.navBar);
        expect(finalState.navBar).toEqual(initialState.navBar);
      });
    });
  });

  describe("when a setNavBarVisibility action is dispatched", () => {
    const navBarVisibility = false;
    const action = setNavBarVisibility(navBarVisibility);
    const newState = reducer(initialState, action);

    it("updates the visibility of the navbar", () => {
      expect(newState.navBar).toHaveProperty("visible", navBarVisibility);
    });

    it("leaves the other properties of the state unchanged", () => {
      expect(newState.navBar).toHaveProperty(
        "title",
        initialState.navBar.title
      );
      expect(newState.navBar).toHaveProperty(
        "summary",
        initialState.navBar.summary
      );
      expect(newState.stack).toEqual(initialState.stack);
      expect(newState.location).toEqual(initialState.location);
    });
  });

  describe("when a setNavBarTitle action is dispatched", () => {
    const navBarTitle = "Screen Title";
    const action = setNavBarTitle(navBarTitle);
    const newState = reducer(initialState, action);

    it("updates the navbar title", () => {
      expect(newState.navBar).toHaveProperty("title", navBarTitle);
    });

    it("leaves the other properties of the state unchanged", () => {
      expect(newState.navBar).toHaveProperty(
        "visible",
        initialState.navBar.visible
      );
      expect(newState.navBar).toHaveProperty(
        "summary",
        initialState.navBar.summary
      );
      expect(newState.stack).toEqual(initialState.stack);
      expect(newState.location).toEqual(initialState.location);
    });
  });

  describe("<hen a setNavBarSummary action is dispatched", () => {
    const navBarSummary = "Screen summary";
    const action = setNavBarSummary(navBarSummary);
    const newState = reducer(initialState, action);

    it("updates the navbar title", () => {
      expect(newState.navBar).toHaveProperty("summary", navBarSummary);
    });

    it("leaves the other properties of the state unchanged", () => {
      expect(newState.navBar).toHaveProperty(
        "visible",
        initialState.navBar.visible
      );
      expect(newState.navBar).toHaveProperty(
        "title",
        initialState.navBar.title
      );
      expect(newState.stack).toEqual(initialState.stack);
      expect(newState.location).toEqual(initialState.location);
    });
  });
});
