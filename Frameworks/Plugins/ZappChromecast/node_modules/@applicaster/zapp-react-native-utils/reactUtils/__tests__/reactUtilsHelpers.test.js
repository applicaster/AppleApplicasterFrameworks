import * as React from "react";
import { shallow } from "enzyme";
import { shallowToJson } from "enzyme-to-json";

import {
  isClassComponent,
  attachMethodToPrototype,
  wrapInClass,
  addLifeCycleMethods,
} from "../helpers";

import {
  ClassComponent,
  existingMethod,
  ComponentWithLifeCycle,
  StatelessComponent,
  componentDidMount,
  COMPONENT_DID_MOUNT_METHOD,
} from "./fixtures";

describe("isClassComponent", () => {
  it("returns true if the component is a class component", () => {
    expect(isClassComponent(ClassComponent)).toBe(true);
  });

  it("returns false otherwise", () => {
    expect(isClassComponent(StatelessComponent)).toBe(false);
  });
});

describe("attachMethodToPrototype", () => {
  const initialWrapper = shallow(<ClassComponent />);

  expect(initialWrapper.instance()).not.toHaveProperty(
    COMPONENT_DID_MOUNT_METHOD
  );

  afterEach(() => {
    componentDidMount.mockClear();
  });

  it("attaches a lifecycle method to the component's prototype", () => {
    const NewComponent = attachMethodToPrototype(ClassComponent)(
      componentDidMount,
      COMPONENT_DID_MOUNT_METHOD
    );

    const wrapper = shallow(<NewComponent />);

    expect(shallowToJson(wrapper)).toMatchSnapshot();
    expect(wrapper.instance()).toHaveProperty(COMPONENT_DID_MOUNT_METHOD);
    expect(componentDidMount).toHaveBeenCalled();
  });

  it("preserves any existing lifecycle method", () => {
    const NewComponent = attachMethodToPrototype(ComponentWithLifeCycle)(
      componentDidMount,
      COMPONENT_DID_MOUNT_METHOD
    );

    expect(componentDidMount).not.toHaveBeenCalled();

    const wrapper = shallow(<NewComponent />);

    expect(shallowToJson(wrapper)).toMatchSnapshot();
    expect(componentDidMount).toHaveBeenCalled();
    expect(existingMethod).toHaveBeenCalled();
  });
});

describe("wrapInClass", () => {
  let NewComponent;
  let wrapper;

  beforeEach(() => {
    NewComponent = wrapInClass(StatelessComponent);
    wrapper = shallow(<NewComponent />);
  });

  it("wraps the stateless component in a class", () => {
    expect(isClassComponent(NewComponent)).toBe(true);
    expect(shallowToJson(wrapper)).toMatchSnapshot();
  });
});

describe("addLifeCycleMethods", () => {
  let NewComponent;
  let wrapper;

  beforeEach(() => {
    NewComponent = addLifeCycleMethods({ componentDidMount })(ClassComponent);
    wrapper = shallow(<NewComponent />);
  });

  afterEach(() => {
    componentDidMount.mockClear();
  });

  it("attaches the lifecycle method to the component", () => {
    expect(shallowToJson(wrapper)).toMatchSnapshot();
  });

  it("adds the lifecycle method to the component", () => {
    expect(componentDidMount).toHaveBeenCalled();
  });
});
