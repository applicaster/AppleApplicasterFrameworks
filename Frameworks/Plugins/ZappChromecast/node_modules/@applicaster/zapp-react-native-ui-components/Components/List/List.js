// @flow
import * as React from "react";
import * as R from "ramda";

import { FlatList, TouchableOpacity } from "react-native";
import { Header } from "../Header";

type Props = {
  CellRenderer: React.ComponentType<{ item: Object, state: string }>,
  component: any,
  navigator: {
    push: () => void,
  },
  onLoadFinished: any,
  styles: any,
  zappPipesData: {
    data: {
      entry: [{}],
    },
    loading: Boolean,
  },
};

const listStyles = {
  container: {
    flex: 1,
  },
};

export class ListComponent extends React.PureComponent<Props> {
  constructor(props) {
    super(props);

    this._keyExtractor = this._keyExtractor.bind(this);
    this.renderHeader = this.renderHeader.bind(this);
    this.renderItem = this.renderItem.bind(this);
    this.navigateTo = this.navigateTo.bind(this);

    this.state = { selected: undefined };
  }

  _keyExtractor = (item, index) => `${index}${item.id}`;

  renderPlaceholder() {
    return null;
  }

  renderHeader() {
    const {
      styles: { header },
    } = this.props.component;

    if (header && header.visible) {
      const title =
        R.path(["zappPipesData", "data", "title"], this.props) || "";
      return <Header title={title} />;
    }

    return null;
  }

  navigateTo(item) {
    this.props.navigator.push(item);
  }

  renderItem = ({ item, index }) => {
    const { CellRenderer } = this.props;
    const cellState = item.id === this.state.selected ? "focused" : "default";
    const id = R.has("id", item) ? item.id : "";
    return (
      <TouchableOpacity
        activeOpacity={1.0}
        onPress={() => this.navigateTo(item)}
        onPressIn={() => this.setState({ selected: item.id })}
        onPressOut={() => this.setState({ selected: undefined })}
        testID={`${index}${id}`}
      >
        <CellRenderer item={item} state={cellState} />
      </TouchableOpacity>
    );
  };

  renderComponent(zappPipesData: any) {
    this.props.onLoadFinished();

    const itemLimit = Math.min(
      R.path(["rules", "item_limit"], this.props) || 20,
      20
    );

    const data =
      zappPipesData.data && zappPipesData.data.entry
        ? zappPipesData.data.entry.slice(0, itemLimit)
        : [];

    return (
      <FlatList
        numColumns={1}
        contentContainerStyle={listStyles.container}
        data={data}
        renderItem={this.renderItem}
        keyExtractor={this._keyExtractor}
        ListHeaderComponent={this.renderHeader}
      />
    );
  }

  render() {
    const { zappPipesData } = this.props;
    return zappPipesData && !zappPipesData.loading
      ? this.renderComponent(zappPipesData)
      : this.renderPlaceholder();
  }
}
