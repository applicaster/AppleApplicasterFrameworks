const { appBootstrapper } = require("../appBootstrapper");

jest.mock("path", () => ({
  ...require.requireActual("path"),
  resolve: require.requireActual("path").join,
}));

jest.mock("../../../file", () => ({
  copyFiles: jest.fn(),
}));

const { copyFiles } = require("../../../file");

const mock__dirname = __dirname;

jest.mock("../../../settings/paths", () => ({
  quickBrickDirectory: jest.fn(
    require.requireActual("../../../settings/paths").quickBrickDirectory
  ),
  getFileDestinationPath: jest.fn(opts => {
    if (opts.fileName && opts.fileName === "plugin_configurations.json") {
      return require("path").join(
        mock__dirname,
        "./fixtures/plugin_configurations.json"
      );
    }
    if (opts.fileName && opts.fileName === "remote_configurations.json") {
      return require("path").join(
        mock__dirname,
        "./fixtures/remote_configurations.json"
      );
    }
    return require
      .requireActual("../../../settings/paths")
      .getFileDestinationPath(opts);
  }),
}));

jest.mock("../../../settings", () => ({
  getCLIProperties: jest.fn(() => ({
    name: "@applicaster/zapplicaster-cli",
    version: "1.0.0-test-version",
  })),
}));

const {
  quickBrickDirectory,
  getFileDestinationPath,
} = require("../../../settings/paths");

jest.mock("../../../logger", () => ({
  log: jest.fn(),
}));

const logger = require("../../../logger");

jest.mock("shelljs", () => ({
  ...require.requireActual("shelljs"),
  exec: jest.fn(cmd => ({ code: cmd.includes("FAIL") ? 1 : 0 })),
}));

const { exec } = require("shelljs");

jest.mock("../../../plugins", () => ({
  gatherDependencies: jest.fn(() => [
    {
      dependency_name: "plugin",
      identifier: "plugin",
      dependency_version: "1.0.0",
    },
  ]),
  getPluginDependencies: jest.fn(() => [
    { name: "plugin", type: "dependencies", version: "1.0.0" },
  ]),
  getDefaultPlugins: jest.fn(() => [
    { name: "default plugin", type: "default_plugin " },
  ]),
  getFallbackPlugins: jest.fn(() => [{ name: "fallback plugin" }]),
  addMandatoryPlugins: jest.fn(() => {}),
}));

const {
  gatherDependencies,
  getPluginDependencies,
  getDefaultPlugins,
  getFallbackPlugins,
} = require("../../../plugins");

const mockedRenderTemplateFileCurried = jest.fn(Promise.resolve);

jest.mock("../../../render", () => ({
  injectDependencies: jest.fn(Promise.resolve),
  injectScripts: jest.fn(Promise.resolve),
  renderTemplateFile: jest.fn(() => mockedRenderTemplateFileCurried),
}));

const {
  injectDependencies,
  injectScripts,
  renderTemplateFile,
} = require("../../../render");

const destinationPath = "path/to/workspace";
const platform = "ios";
const yarn = false;
const zappReactNative = false;
const buildParams = { appVersionId: "A1234" };
const template = {
  files: {
    templatePath: "template/path",
    filesToCopy: ["custom_conf.config.js", ".babelrc", "package.json"],
    filesToRender: [
      { templatePath: "template/index.js.ejs", filePath: "index.js" },
      {
        templatePath: "template/config/index.js.ejs",
        filePath: "config/index.js",
      },
    ],
  },
  dependencies: [
    { name: "custom_dep", type: "dependencies", version: "1.0.0" },
    { name: "custom_dev_dep", type: "devDependencies", version: "1.0.0" },
  ],
  scripts: [
    {
      name: "start",
      command: "yarn run",
    },
    {
      name: "test",
      command: "jest -u",
    },
  ],
};

const configuration = opts => ({
  destinationPath,
  platform,
  yarn,
  zappReactNative,
  buildParams,
  template,
  ...opts,
});

function clearAllMocks() {
  [
    copyFiles,
    quickBrickDirectory,
    getFileDestinationPath,
    logger.log,
    exec,
    injectDependencies,
    injectScripts,
    renderTemplateFile,
    gatherDependencies,
    getPluginDependencies,
    getDefaultPlugins,
    getFallbackPlugins,
  ].forEach(f => f.mockClear());
}

describe("appBootstrapper", () => {
  beforeEach(clearAllMocks);

  it("bootstraps the app", async () => {
    const config = configuration({});
    const result = await appBootstrapper(config);
    expect(result).toBe(true);

    expect(logger.log.mock.calls).toMatchSnapshot();
    expect(copyFiles.mock.calls).toMatchSnapshot();
    expect(gatherDependencies.mock.calls).toMatchSnapshot();
    expect(getPluginDependencies.mock.calls).toMatchSnapshot();
    expect(getDefaultPlugins.mock.calls).toMatchSnapshot();
    expect(getFallbackPlugins.mock.calls).toMatchSnapshot();
    expect(injectDependencies.mock.calls).toMatchSnapshot();
    expect(injectScripts.mock.calls).toMatchSnapshot();
    expect(renderTemplateFile.mock.calls).toMatchSnapshot();
    expect(mockedRenderTemplateFileCurried.mock.calls).toMatchSnapshot();
    expect(exec.mock.calls).toMatchSnapshot();
  });

  it("throws if npm install fails", async () => {
    expect.assertions(1);
    try {
      const config = configuration({ destinationPath: "FAILING_PATH" });
      await appBootstrapper(config);
    } catch (e) {
      expect(e).toMatchSnapshot();
    }
  });

  it("notifies about the specific behaviour when running inside zapp react native repo", async () => {
    // when running the cli inside this repo, the cli skips the package.json copy from the template
    // if it exists. This avoids issues with the workspace.
    // When running the CLI, it logs the specific behaviour in the console;
    const config = configuration({ zappReactNative: true });
    const result = await appBootstrapper(config);
    expect(result).toBe(true);

    expect(logger.log.mock.calls).toMatchSnapshot();
    expect(copyFiles.mock.calls).toMatchSnapshot();
    expect(exec).toHaveBeenCalledWith("yarn");
  });

  it("uses yarn to install if provided in the options", async () => {
    const config = configuration({ yarn: true });
    const result = await appBootstrapper(config);
    expect(result).toBe(true);

    expect(exec.mock.calls).toMatchSnapshot();
  });
});
