import * as React from "react";
import * as R from "ramda";

import { NavigationContext } from "@applicaster/zapp-react-native-ui-components/Contexts/NavigationContext";

import {
  getTargetRoute,
  getRiverFromRoute,
} from "@applicaster/zapp-react-native-utils/navigationUtils";

import reducer, {
  initialState,
  setNavBarVisibility,
  setNavBarTitle,
  setNavBarSummary,
  ACTIONS,
  push,
  replace,
  back,
} from "./navigator/reducer";

import { HooksManager } from "@applicaster/zapp-react-native-utils/appUtils/HooksManager";
import { HOOKS_EVENTS } from "@applicaster/zapp-react-native-utils/appUtils/HooksManager/constants";

import {
  homeRiverSelector,
  activeRiverSelector,
  lastEntrySelector,
} from "./navigator/selectors";

type Props = {
  children: React.Node,
  rivers: { [string]: {} },
  plugins: [{}],
};

const navigationActions = {
  [ACTIONS.PUSH]: push,
  [ACTIONS.REPLACE]: replace,
};

const getRiverIds = R.compose(R.join("-"), R.keys);

const getPluginIds = R.compose(R.join("-"), R.map(R.prop("identifier")));

export function NavigationProvider({ children, rivers, plugins }: Props) {
  const [state, dispatch] = React.useReducer(reducer, initialState);

  const pathname = state?.location?.pathname;

  const activeRiver = React.useMemo(
    () => activeRiverSelector({ pathname, rivers }),
    [pathname, rivers]
  );

  const homeRiver = React.useMemo(() => homeRiverSelector({ rivers }), [
    rivers,
  ]);

  const showNavBar = () => dispatch(setNavBarVisibility(true));
  const hideNavBar = () => dispatch(setNavBarVisibility(false));
  const setScreenTitle = R.compose(dispatch, setNavBarTitle);
  const setScreenSummary = R.compose(dispatch, setNavBarSummary);
  const routeData = () => state?.location?.state;
  const pushItem = (item) => navigateTo(item, ACTIONS.PUSH);

  const replaceItem = (item) => {
    const targetRoute = getTargetRoute(item);

    if (targetRoute !== pathname) {
      navigateTo(item, ACTIONS.REPLACE);
    }
  };

  const canGoBack = () => state.stack.length > 1;

  const goBack = (fallbackToHome = true) => {
    if (fallbackToHome && !canGoBack()) {
      goHome();
    } else {
      dispatch(back());
    }
  };

  const goHome = () => navigateTo(homeRiver, ACTIONS.REPLACE);

  const handleHookPresent = ({ hookPlugin, route, payload }, dispose) => {
    if (hookPlugin?.lastHook) {
      dispose();
    }
    dispatch(push(route, payload));
  };

  const handleHookError = ({ error, hookPlugin }, dispose) => {
    // eslint-disable-next-line no-console
    console.warn({ error });

    if (hookPlugin?.lastHook) {
      dispose();
    }
    goBack();
  };

  const handleHookCancel = ({ hookPlugin }, dispose) => {
    if (hookPlugin?.lastHook) {
      dispose();
    }
    goBack();
  };

  const handleHookSucces = (navigationAction, targetRoute) => (
    { hookPlugin, payload },
    dispose
  ) => {
    if (hookPlugin?.lastHook) {
      dispose({ disposeAll: true });
    }
    dispatch(navigationAction(targetRoute, payload));
  };

  function navigateTo(item, action) {
    const initialPathname = action === ACTIONS.PUSH ? pathname : "";
    const targetRoute = getTargetRoute(item, initialPathname);
    const targetScreen = getRiverFromRoute({ route: targetRoute, rivers });

    const navigationAction = navigationActions[action] || replace;

    const hooksOptions = {
      targetScreen,
      rivers,
      plugins,
    };

    HooksManager(hooksOptions)
      .on(HOOKS_EVENTS.PRESENT_SCREEN_HOOK, handleHookPresent)
      .on(HOOKS_EVENTS.ERROR, handleHookError)
      .on(HOOKS_EVENTS.CANCEL, handleHookCancel)
      .on(HOOKS_EVENTS.SUCCESS, handleHookSucces(navigationAction, targetRoute))
      .handleHooks(item);
  }

  const navigator = React.useMemo(
    () => ({
      activeRiver,
      currentRoute: pathname,
      previousAction: lastEntrySelector(state)?.action,
      isNavBarVisible: state.navBar.visible,
      screenTitle: state.navBar.title,
      screenSummary: state.navBar.summary,
      showNavBar,
      hideNavBar,
      setScreenTitle,
      setScreenSummary,
      push: pushItem,
      replace: replaceItem,
      goHome,
      canGoBack,
      goBack,
      routeData,
    }),
    [getRiverIds(rivers), getPluginIds(plugins), JSON.stringify(state)]
  );

  // when running the tests, we pass the dispatch function
  // in order to be able to trigger state changes
  if (process.env.NODE_ENV === "test") {
    navigator.dispatch = dispatch;
    navigator.state = state;
  }

  React.useEffect(() => {
    if (pathname === "/") {
      goHome();
    }
  }, [pathname]);

  if (pathname === "/") {
    return null;
  }

  return (
    <NavigationContext.Provider value={navigator}>
      {children}
    </NavigationContext.Provider>
  );
}
