const pluginPath = "plugins/my-plugin";

const getOptions = (opts = {}) => ({
  cliArgs: [opts.pluginPath || pluginPath],
  cliOptions: {
    pluginPath,
    yarn: false,
    dryRun: false,
    next: false,
    version: "1.5.0",
    singlePlatform: "",
    skipGit: false,
    ...opts,
  },
});

jest.mock("simple-git/promise", () =>
  jest.fn(path => {
    return {
      status: function() {
        if (path.includes("dirty_git")) {
          console.log("git is not clean");
          return Promise.resolve({ files: ["file: //"] });
        }

        return Promise.resolve({ files: [] });
      },
    };
  })
);

jest.mock("path", () => ({
  resolve: jest.fn((dir, path) => {
    if (path.includes("resolve_error")) {
      throw new Error("cannot resolve file");
    }

    if (
      path.includes("missing_package_json") ||
      path.includes("bad_package_json") ||
      path.includes("bad_supported_platforms") ||
      path.includes("bad_missing_zapp_account") ||
      path.includes("dirty_git")
    ) {
      return path;
    }

    if (dir.includes("missing_package_json")) {
      /* eslint-disable-next-line no-path-concat */
      return __dirname + "missing_file.json";
    }

    if (dir.includes("bad_package_json")) {
      /* eslint-disable-next-line no-path-concat */
      return __dirname + "/mocked_bad_package.json";
    }

    if (dir.includes("bad_supported_platforms")) {
      /* eslint-disable-next-line no-path-concat */
      return __dirname + "/mocked_bad_package_2.json";
    }

    if (dir.includes("bad_missing_zapp_account")) {
      /* eslint-disable-next-line no-path-concat */
      return __dirname + "/mocked_bad_package_3.json";
    }

    if (path.includes("package.json")) {
      /* eslint-disable-next-line no-path-concat */
      return __dirname + "/mocked_package.json";
    }

    return "plugins/my-plugin";
  }),
}));

jest.mock("../../../logger", () => ({
  log: jest.fn(),
  warn: jest.fn(),
}));

const logger = require("../../../logger");
const git = require("simple-git/promise");

const { configurator } = require("../configurator");

function clearMocks() {
  logger.log.mockClear();
  logger.warn.mockClear();
  git.mockClear();
}

describe("publish plugin configurator", () => {
  beforeEach(clearMocks);

  it("returns the configuration", async () => {
    const options = getOptions();
    expect(await configurator(options)).toMatchSnapshot();
    expect(logger.log.mock.calls).toMatchSnapshot();
  });

  it("throws when the plugin path cannot be resolved", async () => {
    const options = getOptions({ pluginPath: "resolve_error" });
    expect(configurator(options)).rejects.toMatchSnapshot();
  });

  it("throws when the package json cannot be found", async () => {
    const options = getOptions({ pluginPath: "missing_package_json" });
    expect(configurator(options)).rejects.toMatchSnapshot();
  });

  it("throws when the package.json doesn't contain the applicaster property", async () => {
    const options = getOptions({ pluginPath: "bad_package_json" });
    expect(configurator(options)).rejects.toMatchSnapshot();
  });

  it("throws when the package.json doesn't contain the zapp account owner Id", async () => {
    const options = getOptions({ pluginPath: "bad_missing_zapp_account" });
    expect(configurator(options)).rejects.toMatchSnapshot();
  });

  it("throws when the packages.json applicaster prop doesn't have list of supported platforms", async () => {
    const options = getOptions({ pluginPath: "bad_supported_platforms" });
    expect(configurator(options)).rejects.toMatchSnapshot();
  });

  it("throws if an invalid version is provided", async () => {
    const options = getOptions({ version: "invalid" });
    expect(configurator(options)).rejects.toMatchSnapshot();
  });

  it("throws when requesting to publish an unsupported platform", async () => {
    const options = getOptions({ singlePlatform: "foo" });
    expect(configurator(options)).rejects.toMatchSnapshot();
  });

  it("throws when git status is not clean", async () => {
    const options = getOptions({ pluginPath: "dirty_git" });
    expect(configurator(options)).rejects.toMatchSnapshot();
  });

  it("skips git check if called with skipGit flag", async () => {
    const options = getOptions({ skipGit: true });
    await configurator(options);
    expect(git).not.toHaveBeenCalled();
  });

  it("warns in the log if called with dryRun flag", async () => {
    const options = getOptions({ dryRun: true });
    await configurator(options);

    expect(logger.warn).toHaveBeenCalledWith(
      "you selected the dry run option. Your plugin will not be actually published"
    );
  });
});
