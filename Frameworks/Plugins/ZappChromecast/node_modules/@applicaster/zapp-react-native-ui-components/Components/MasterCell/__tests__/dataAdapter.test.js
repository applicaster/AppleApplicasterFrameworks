import * as R from "ramda";
import { defaultDataAdapter } from "../dataAdapter";
import { testCellStyle } from "./TestCellStyle";
import { entry } from "./testEntry";

let elementsBuilder = defaultDataAdapter(testCellStyle);
let state = "default";

describe("dataAdapter", () => {
  it("creates a tree of nodes", () => {
    expect(elementsBuilder({ entry, state })).toMatchSnapshot();
  });

  it("assigns values from the entry into the tree", () => {
    const imageUri = elementsBuilder({ entry, state })[0].elements[0].props.uri;

    expect(imageUri).toBeDefined();
    expect(imageUri).toEqual(entry.media_group[0].media_item[0].src);
    expect(imageUri).not.toEqual(entry.media_group[1].media_item[0].src);
  });

  it("throws an error if the data mapping object is invalid", () => {
    const cellStyleWithCorruptDataMapping = R.set(
      R.lensPath([
        "content_types",
        "default",
        "states",
        "default",
        0,
        "elements",
        0,
        "data",
        0,
      ]),
      { missing: "some", keys: 1234 },
      entry
    );
    const elementsBuilder = defaultDataAdapter(cellStyleWithCorruptDataMapping);

    expect(() => {
      elementsBuilder({ entry, state });
    }).toThrow(
      "Missing func in the data mapping, please revise or update cell styles configuration"
    );
  });

  describe("returns a tree view for state", () => {
    it("matching the state if it exists", () => {
      state = "focused";
      const viewTree = elementsBuilder({ entry, state });

      expect(viewTree).toMatchSnapshot();
      expect(viewTree[0].props.whoAmI).toEqual({
        contentType: "feed",
        state: "focused",
      });
    });

    it("fallback to the default if the state does not exist", () => {
      state = "some-other-state";
      const viewTree = elementsBuilder({ entry, state });

      expect(viewTree).toMatchSnapshot();
      expect(viewTree[0].props.whoAmI).toEqual({
        contentType: "feed",
        state: "default",
      });
    });

    it("fallback to the default if the state is not passed", () => {
      const viewTree = elementsBuilder({ entry });

      expect(viewTree).toMatchSnapshot();
      expect(viewTree[0].props.whoAmI).toEqual({
        contentType: "feed",
        state: "default",
      });
    });
  });

  describe("returns a tree view for a specific content type", () => {
    it("if the content type mapping exists ", () => {
      const entryWithVideoType = {
        ...entry,
        type: { value: "video" },
      };
      const viewTree = elementsBuilder({ entry: entryWithVideoType });

      expect(viewTree).toMatchSnapshot();
      expect(viewTree[0].props.whoAmI).toEqual({
        contentType: "video",
        state: "default",
      });
    });

    it("fallback to the default if the mapping for this content type does not exist", () => {
      const entryWithUnknownType = {
        ...entry,
        type: { value: "unknown" },
      };
      const viewTree = elementsBuilder({ entry: entryWithUnknownType });

      expect(viewTree).toMatchSnapshot();
      expect(viewTree[0].props.whoAmI).toEqual({
        contentType: "default",
        state: "default",
      });
    });
  });

  describe("returns elements inflated with correct data.", () => {
    const testArguments = ["foo", "bar"];
    const mockedReturnValue = "Unicorn";
    const mockedFunc = jest.fn().mockReturnValue(mockedReturnValue);
    const _testViewTree = (state, contentType = "default") => [
      {
        type: "View",
        data: [
          {
            func: mockedFunc,
            args: testArguments,
            propName: "test",
          },
        ],
      },
    ];

    const _testCellStyle = {
      content_types: {
        default: {
          states: {
            default: _testViewTree("default"),
          },
        },
      },
    };
    const testElBuilder = defaultDataAdapter(_testCellStyle);
    const entryWithVideoType = {
      ...entry,
      type: { value: "video" },
    };
    const viewTree = testElBuilder({ entry: entryWithVideoType });

    it("calls custom data function with passed arguments", () => {
      expect(mockedFunc).toHaveBeenCalled();
      expect(mockedFunc).toHaveBeenCalledWith(expect.anything(), testArguments);
    });
    it("uses custom function to inflate props with returned value", () => {
      expect(viewTree[0].props.test).toEqual(mockedReturnValue);
    });
  });
});
