// @flow
import * as R from "ramda";
import * as React from "react";
import { FlatList } from "react-native";
import { Focusable } from "../Focusable";
import {
  useFocusRefs,
  useInitialFocus,
} from "@applicaster/zapp-react-native-utils/focusManager";

type Props = {
  horizontal: boolean,
  numColumns?: Number,
  onListElementFocus: (any) => void,
  onListElementBlur: (any) => void,
  onListElementPress: (any) => void,
  keyExtractor: (any) => string,
  nextFocusDown: React.Ref<any>,
  nextFocusUp: React.Ref<any>,
  nextFocusRight: React.Ref<any>,
  nextFocusLeft: React.Ref<any>,
  focusableItemProps: any,
  data: [any],
  focused: boolean,
  initialScrollIndex?: number,
  withStateMemory: Boolean,
};

function FocusableListComponent(props: Props, ref) {
  const {
    horizontal,
    onListElementFocus,
    onListElementBlur,
    onListElementPress,
    nextFocusDown,
    nextFocusRight,
    nextFocusLeft,
    nextFocusUp,
    focusableItemProps,
    focused,
    initialScrollIndex = 0,
    withStateMemory = true,
  } = props;
  const componentRefs = useFocusRefs();
  const [renderedRefs, setRenderedRefs] = React.useState(false);

  const initialFocusOptions = withStateMemory
    ? { withStateMemory, refsList: componentRefs }
    : {};

  const updateFocusedIndex = useInitialFocus(
    focused,
    componentRefs[initialScrollIndex],
    initialFocusOptions
  );

  const onFocus = (element, renderArgs) => {
    const { index } = renderArgs;

    updateFocusedIndex?.(index);
    onListElementFocus(element, renderArgs);
  };

  const getNextFocus = (index) => {
    if (horizontal) {
      return {
        nextFocusDown,
        nextFocusUp,
        nextFocusLeft: componentRefs?.[index - 1] || nextFocusLeft,
        nextFocusRight: componentRefs?.[index + 1] || nextFocusRight,
      };
      // Logic for grids
    } else if (props.numColumns) {
      const numberOfRows = Math.ceil(componentRefs.length / props.numColumns);
      const currentRowIndex = Math.floor(index / props.numColumns);
      const isFirstRow = currentRowIndex === 0;
      const isLastRow = currentRowIndex + 1 === numberOfRows;
      const isLeftEdge = index % props.numColumns === 0;
      const isRightEdge =
        (index + 1) % props.numColumns === 0 ||
        componentRefs.length === index + 1;

      return {
        nextFocusDown: isLastRow
          ? nextFocusDown
          : componentRefs?.[index + props.numColumns],
        nextFocusUp: isFirstRow
          ? nextFocusUp
          : componentRefs?.[index - props.numColumns],
        nextFocusLeft: isLeftEdge ? nextFocusLeft : componentRefs?.[index - 1],
        nextFocusRight: isRightEdge
          ? nextFocusRight
          : componentRefs?.[index + 1],
      };
    } else {
      return {
        nextFocusLeft,
        nextFocusRight,
        nextFocusUp: componentRefs?.[index - 1] || nextFocusUp,
        nextFocusDown: componentRefs?.[index + 1] || nextFocusDown,
      };
    }
  };

  const renderItem = (renderArgs) => (
    <Focusable
      {...{
        ...getNextFocus(renderArgs.index),
        onFocus: (element) => onFocus?.(element, renderArgs),
        onBlur: (element) => onListElementBlur?.(element, renderArgs),
        onPress: (element) => onListElementPress?.(element, renderArgs),
        id: props?.keyExtractor(renderArgs.item),
        ...focusableItemProps,
      }}
      ref={(_ref) => {
        componentRefs[renderArgs.index] = _ref;
        if (renderArgs.index + 1 === props.data.length) {
          setRenderedRefs(true);
        }
      }}
    >
      {(focused, parentFocus, parentRef) =>
        props?.renderItem({
          ...renderArgs,
          focused,
          parentFocus,
          parentRef,
        })
      }
    </Focusable>
  );

  const flatListProps = React.useMemo(
    () =>
      R.omit([
        "onListElementFocus",
        "onListElementPress",
        "onListElementBlur",
        "nextFocusDown",
        "nextFocusRight",
        "nextFocusLeft",
        "nextFocusUp",
        "focusableItemProps",
        "renderItem",
      ])(props),
    [props]
  );

  return (
    <FlatList
      extraData={renderedRefs}
      ref={ref}
      {...{ ...flatListProps, renderItem }}
    />
  );
}

export const FocusableList = React.forwardRef(FocusableListComponent);
