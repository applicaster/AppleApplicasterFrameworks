/* eslint-disable prefer-promise-reject-errors */
import * as R from "ramda";

import { appLoader } from "../index";
import * as LocalizationLoader from "../loadLocalizations";
import * as LoadAnalytics from "../loadAnalyticsPlugins";
import * as LoadSplash from "../displaySplash";
import * as LoadDomPlugins from "../loadDomPlugins";
import * as LoadLocale from "../loadLocale";

const plugin1 = {
  module: jest.fn(),
  name: "Plugin 1",
  identifier: "plugin_1",
  type: "player",
};

const plugin2 = {
  module: jest.fn(),
  name: "Plugin 2",
  identifier: "plugin_2",
  type: "video_advertisement",
};

const mock_state = {
  localizations: { en: "http://en.url", fr: "http://fr.url" },
  plugins: [plugin1, plugin2],
  pluginConfiguration: [{}],
};

const mock_failState = R.mergeDeepRight(mock_state, {
  localizations: { fail: "http://fail.url" },
  plugins: [...mock_state.plugins, { name: "fail" }],
});

const dispatch = jest.fn();

const mock_failablePromise = (name, fail = false) =>
  fail
    ? Promise.reject(`${name} promise rejected`)
    : Promise.resolve(`${name} promise resolved`);

const loadLocalizations = jest
  .spyOn(LocalizationLoader, "loadLocalizations")
  .mockImplementation((localizations, dispatch) =>
    mock_failablePromise("localizations", !!localizations.fail)
  );

const loadAnalyticsPlugins = jest
  .spyOn(LoadAnalytics, "loadAnalyticsPlugins")
  .mockImplementation((plugins, pluginConfiguration) =>
    mock_failablePromise("analytics", plugins.length >= 3)
  );

const loadSplash = jest
  .spyOn(LoadSplash, "displaySplash")
  .mockImplementation(() => mock_failablePromise("splash"));

const loadDomPlugins = jest
  .spyOn(LoadDomPlugins, "loadDomPlugins")
  .mockImplementation(plugins =>
    mock_failablePromise("loadDomPlugins", plugins.length >= 3)
  );

const loadLocale = jest
  .spyOn(LoadLocale, "loadLocale")
  .mockImplementation(plugins => mock_failablePromise("loadLocale"));

function resetMocks() {
  loadLocalizations.mockClear();
  loadAnalyticsPlugins.mockClear();
  loadSplash.mockClear();
  loadDomPlugins.mockClear();
  loadLocale.mockClear();
}

describe("appLoader", () => {
  beforeEach(resetMocks);

  describe("when all loader resolve", () => {
    const getState = jest.fn(() => mock_state);

    it("runs all loaders", async () => {
      const { localizations, plugins, pluginConfigurations } = getState();
      expect(appLoader(dispatch, getState)).resolves.toMatchSnapshot();

      expect(loadLocalizations).toHaveBeenCalledWith(localizations, dispatch);

      expect(loadAnalyticsPlugins).toHaveBeenCalledWith(
        plugins,
        pluginConfigurations
      );

      expect(loadSplash).toHaveBeenCalledWith();

      expect(loadDomPlugins).toHaveBeenCalledWith(plugins);
    });
  });

  describe("when loaders reject", () => {
    const getState = jest.fn(() => mock_failState);

    it("runs all loaders", async () => {
      const { localizations, plugins, pluginConfigurations } = getState();
      expect(appLoader(dispatch, getState)).rejects.toMatchSnapshot();

      expect(loadLocalizations).toHaveBeenCalledWith(localizations, dispatch);

      expect(loadAnalyticsPlugins).toHaveBeenCalledWith(
        plugins,
        pluginConfigurations
      );

      expect(loadSplash).toHaveBeenCalledWith();

      expect(loadDomPlugins).toHaveBeenCalledWith(plugins);
    });
  });
});
