// @flow
import * as React from "react";
import * as R from "ramda";
import { ScrollView, Animated, Easing } from "react-native";

import type { ZappComponent } from "@applicaster/zapp-react-native-flow-types";
import { applyDecorators } from "@applicaster/zapp-react-native-ui-components/Decorators";
import { ComponentResolver } from "@applicaster/zapp-react-native-ui-components/Components/ComponentResolver";
import { riverFocusManager } from "@applicaster/zapp-react-native-utils/appUtils/RiverFocusManager";
import { objFromListWith } from "@applicaster/zapp-react-native-utils/objectUtils";

type Props = {
  riverComponents: [any],
  components: { [string]: ZappComponent },
  cellStyles: any,
  screenId: string,
  feed: ?string,
  isScreenWrappedInContainer: boolean,
  componentDidFinishAnimation: () => void,
  screenFocusableGroupId: string,
};

type State = {
  animatedValue: Animated.Value,
};

function styles(state) {
  return {
    flex: 1,
    opacity: state.animatedValue,
  };
}

export class ComponentsMapComponent extends React.PureComponent<Props, State> {
  constructor(props: Props) {
    super(props);
    this.componentIsLoaded = this.componentIsLoaded.bind(this);
    this.renderRiverComponent = this.renderRiverComponent.bind(this);
    this.onAnimationEnd = this.onAnimationEnd.bind(this);
    this.riverComponents = R.compose(
      objFromListWith(R.prop("id")),
      R.map(R.pick(["id", "position"]))
    )(props.riverComponents);
    this.animated = false;
    this.state = {
      animatedValue: new Animated.Value(0),
    };
  }

  riversAreLoaded() {
    const riverComponentIds = R.compose(
      R.map(R.prop("id")),
      R.prop("riverComponents")
    )(this.props);

    return R.compose(
      R.all(R.prop("loaded")),
      R.filter(riverComponent => riverComponentIds.includes(riverComponent.id))
    )(this.riverComponents);
  }

  getFeedUrl(feed, index) {
    try {
      const feedUrl = R.path(["entry", index, "content", "src"], feed);
      return (R.contains || R.includes)("fetchData?", feedUrl) ? feedUrl : null;
    } catch (error) {
      return null;
    }
  }

  renderRiverComponent(component, index) {
    const {
      feed,
      screenId,
      isScreenWrappedInContainer,
      screenFocusableGroupId,
    } = this.props;

    if (!this.riverComponents[component.id]) {
      this.riverComponents[component.id] = R.pick(
        ["id", "position"],
        component
      );
    }

    const feedUrl = this.getFeedUrl(feed, index);

    const focusableRiverData = riverFocusManager.screenFocusableData({
      screenFocusableGroupId: screenFocusableGroupId,
    });

    return (
      <ComponentResolver
        key={index}
        component={component}
        decorators={applyDecorators}
      >
        {(Component, CellRenderer) => {
          return (
            <Component
              componentPositionIndex={index}
              screenId={screenId}
              component={component}
              CellRenderer={CellRenderer}
              isScreenWrappedInContainer={isScreenWrappedInContainer}
              onLoadFinished={() => this.componentIsLoaded(component.id)}
              focusableRiverData={focusableRiverData}
              feedUrl={feedUrl}
            />
          );
        }}
      </ComponentResolver>
    );
  }

  componentIsLoaded(id) {
    if (this.riverComponents[id]) {
      this.riverComponents[id].loaded = true;
    }

    if (this.riversAreLoaded() && !this.animated) {
      this.animated = true;
      this.animate();
    }
  }

  onAnimationEnd() {
    this.props.componentDidFinishAnimation();
  }

  animate() {
    Animated.timing(this.state.animatedValue, {
      toValue: 1,
      duration: 10,
      easing: Easing.in(),
    }).start(this.onAnimationEnd);
  }

  render() {
    const { riverComponents } = this.props;

    return (
      <Animated.View style={styles(this.state)}>
        <ScrollView>
          {riverComponents.map(this.renderRiverComponent)}
        </ScrollView>
      </Animated.View>
    );
  }
}
