// @flow
import * as React from "react";

import { createReactRef } from "@applicaster/zapp-react-native-utils/reactUtils";
import { focusManager } from "@applicaster/zapp-react-native-utils/appUtils/focusManager";
import * as FOCUS_EVENTS from "@applicaster/zapp-react-native-utils/appUtils/focusManager/events";
import { noop } from "@applicaster/zapp-react-native-utils/functionUtils";

type Props = {
  initialFocus: ?boolean,
  id: string,
  groupId: ?string,
  preferredFocus: ?boolean,
  onRegister: ?({}) => void,
  onUnregister: ?({}) => void,
  willReceiveFocus: ?({}, ({}) => void) => void,
  onFocus: ({}) => void,
  hasReceivedFocus: ?({}, ({}) => void) => void,
  willLoseFocus: ?({}, ({}) => void) => void,
  onBlur: ?({}) => void,
  hasLostFocus: ?({}) => void,
  failedLostFocus: ?({}) => void,
  onPress: ({}) => void,
  children: (boolean, string) => React.ComponentType<any>,
  selected: ?boolean,
};
type State = {
  focused: boolean,
  boundingRect: {
    x: number,
    y: number,
    width: number,
    height: number,
    top: number,
    bottom: number,
    left: number,
    right: number,
  },
};

export class BaseFocusable extends React.Component<Props, State> {
  constructor(props) {
    super(props);
    const { initialFocus } = this.props;

    this.state = {
      focused: initialFocus || false,
    };

    this.onRegister = this.onRegister.bind(this);
    this.onUnregister = this.onUnregister.bind(this);
    this.setFocusedState = this.setFocusedState.bind(this);
    this.willReceiveFocus = this.willReceiveFocus.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.hasReceivedFocus = this.hasReceivedFocus.bind(this);
    this.willLoseFocus = this.willLoseFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.hasLostFocus = this.hasLostFocus.bind(this);
    this.failedLostFocus = this.failedLostFocus.bind(this);
    this.onPress = this.onPress.bind(this);
    this.ref = createReactRef();
  }

  componentDidMount() {
    this._isMounted = true;
    const component = this;
    focusManager.register({
      id: this.getId(),
      component: component,
    });
  }

  getId() {
    const { id, groupId = null } = this.props;
    return groupId ? `${groupId}-${id}` : id;
  }

  /**
   * returns the DOMRect of the underlying of the Focusable
   * @returns {Object} {x, y, width, height, top, bottom, left, right }
   */
  getRect() {
    let boundingRect = { left: null, right: null, top: null, bottom: null };

    if (this.ref && this.ref.current) {
      boundingRect = this.ref.current.getBoundingClientRect();
    }

    return boundingRect;
  }

  isMounted() {
    return this._isMounted;
  }

  componentWillUnmount() {
    this._isMounted = false;
    focusManager.unregister(this.getId(), { group: this.isGroup || false });
  }

  /**
   * will invoke the underlying component's onRegister method
   * @param {Object} focusable - sender
   * @returns {Promise}
   */
  onRegister(focusable) {
    const { onRegister = noop } = this.props;
    onRegister(focusable);
  }

  /**
   * will invoke the underlying component's onUnregister method
   * @param {Object} focusable - sender
   * @returns {Promise}
   */
  onUnregister(focusable) {
    const { onUnregister = noop } = this.props;
    onUnregister(focusable);
  }

  /**
   * will invoke the underlying component's willLoseFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  willLoseFocus(focusable, scrollDirection) {
    const { willLoseFocus = noop } = this.props;
    willLoseFocus(focusable, scrollDirection);
    focusManager.invokeHandler(FOCUS_EVENTS.WILL_LOSE_FOCUS, this);
  }

  /**
   * will invoke the underlying component's willReceiveFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  willReceiveFocus(focusable, scrollDirection) {
    const { willReceiveFocus = noop } = this.props;
    willReceiveFocus(focusable, scrollDirection);
    focusManager.invokeHandler(FOCUS_EVENTS.WILL_RECEIVE_FOCUS, this);
  }

  /**
   * will invoke the underlying component's focus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  onFocus(focusable, scrollDirection) {
    const { onFocus = noop } = this.props;
    this.setFocusedState(true);
    onFocus(focusable, scrollDirection);
    focusManager.invokeHandler(FOCUS_EVENTS.FOCUS, this);
  }
  /**
   * will invoke the underlying component's hasReceivedFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  hasReceivedFocus(focusable, scrollDirection) {
    const { hasReceivedFocus = noop } = this.props;
    hasReceivedFocus(focusable, scrollDirection);
    focusManager.invokeHandler(FOCUS_EVENTS.HAS_RECEIVED_FOCUS, this);
  }

  /**
   * will invoke the underlying component's hasLostFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  hasLostFocus(focusable, scrollDirection) {
    const { hasLostFocus = noop } = this.props;
    hasLostFocus(focusable, scrollDirection);
    focusManager.invokeHandler(FOCUS_EVENTS.HAS_LOST_FOCUS, this);
  }

  /**
   * will invoke the underlying component's failedLostFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  failedLostFocus(focusable, scrollDirection) {
    const { failedLostFocus = noop } = this.props;
    failedLostFocus(focusable, scrollDirection);
  }

  /**
   * will invoke the underlying component's onBlur method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  onBlur(focusable, scrollDirection) {
    const { onBlur = noop } = this.props;
    this.setFocusedState(false);
    onBlur(focusable, scrollDirection);
    focusManager.invokeHandler(FOCUS_EVENTS.BLUR, this);
  }

  /**
   * will invoke the underlying component's onPress method
   * @param {Object} focusable - sender
   * @param {Object} keyEvent
   * @returns {Promise}
   */
  onPress(focusable, keyEvent) {
    const { onPress = noop } = this.props;
    onPress(focusable, keyEvent);
  }

  /**
   * will tell if the item is in the given group
   * @param {Object} FocusableGroup to test
   * @returns {boolean}
   */
  isInGroup(group) {
    const { groupId } = this.props;
    const { id } = group.props;
    return id === groupId;
  }

  setFocusedState(focused) {
    if (this._isMounted) {
      this.setState({ focused });
    }
  }
}
