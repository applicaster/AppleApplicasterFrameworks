// @flow
import * as React from "react";
import { View } from "react-native";
import * as R from "ramda";
import { ErrorDisplay } from "./ErrorDisplay";
import { BufferAnimation } from "./BufferAnimation";
// eslint-disable-next-line max-len
import { TVEventHandlerComponent } from "@applicaster/zapp-react-native-tvos-ui-components/Components/TVEventHandlerComponent";

import {
  allowedOrientationsForScreen,
  releaseOrientationsForScreen,
  ORIENTATIONS,
} from "@applicaster/zapp-react-native-utils/appUtils/orientationHelper";

import { noop } from "@applicaster/zapp-react-native-utils/functionUtils";

import { isAppleMobile } from "../../Helpers/Platform";

import { AudioPlayer } from "../AudioPlayer";

import { ProgramInfo } from "./ProgramInfo";
import {
  sendVideoItemPlayEvent,
  sendVideoItemPlayStartTimedEvent,
  sendVideoItemPlayStopTimedEvent,
} from "../../Helpers/Analytics";

type Props = {
  Player: React.ComponentType<any>,
  PlayerControls: ?React.ComponentType<any>,
  PlayerLoadingView: ?React.ComponentType<any>,
  plugins: [],
  item: {
    type: {
      value: string,
    },
    title: string,
    summary: string,
    media_group: {},
    extensions: {},
  },
  navigator: {
    hideNavBar: () => void,
    showNavBar: () => void,
    goBack: () => void,
  },
  rate: number,
  duration: number,
};

type State = {
  playerState: "Stop" | "Play" | "Pause" | "Loading" | "Error",
  advertismentPlaying: boolean,
  isPlayerReady: boolean,
  showOverlay: boolean,
  ignoreSilentSwitch: "ignore" | "obey",
};

const PLAYER_STATES = {
  PLAY: "Play",
  PAUSE: "Pause",
  LOADING: "Loading",
  STOP: "Stop",
  ERROR: "Error",
};

function getContainerStyle() {
  return { flex: 1, backgroundColor: "rgba(0,0,0,1.0)" };
}

export class PlayerController extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);
    this.state = {
      playerState: PLAYER_STATES.LOADING,
      advertismentPlaying: false,
      isPlayerReady: false,
      showOverlay: false,
      ignoreSilentSwitch: "ignore",
    };

    this.style = {
      container: getContainerStyle(),
    };
    
    this.onLoad = this.onLoad.bind(this);
    this.onVideoEnd = this.onVideoEnd.bind(this);
    this.onPlaybackRateChange = this.onPlaybackRateChange.bind(this);
    this.updatePlayerState = this.updatePlayerState.bind(this);
    this.playerRemoteHandler = this.playerRemoteHandler.bind(this);
    this.onProgress = this.onProgress.bind(this);
    this.onError = this.onError.bind(this);
    this.onAdChangedState = this.onAdChangedState.bind(this);
    this.rate = 0;
    this.duration = null;
    this.currentTime = null;
    this.onFullscreenPlayerDidDismiss = this.onFullscreenPlayerDidDismiss.bind(
      this
    );
    this.playerRemoteHandler = this.playerRemoteHandler.bind(this);
  }

  componentDidMount() {
    const { navigator } = this.props;
    navigator.hideNavBar();
    allowedOrientationsForScreen(ORIENTATIONS.landscapeSensor);
    this._isMounted = true;
  }

  componentWillUnmount() {
    const { navigator } = this.props;
    navigator.showNavBar();
    releaseOrientationsForScreen();
  }

  updatePlayerState(playerState) {
    this.setState({ playerState });
  }

  onPlaybackRateChange(data) {
    this.rate = data.playbackRate;
    this.updatePlayerState(
      this.rate === 0 ? PLAYER_STATES.PAUSE : PLAYER_STATES.PLAY
    );
  }

  onFullscreenPlayerDidDismiss() {
    const { navigator } = this.props;
    navigator.goBack();
  }

  onLoad(data) {
    const { item } = this.props;
    const { duration } = data;
    this.duration = duration;
    sendVideoItemPlayEvent(item);
    sendVideoItemPlayStartTimedEvent(item, duration);
    this.updatePlayerState(PLAYER_STATES.PLAY);
    this.setState({
      playerState: PLAYER_STATES.PLAY,
      isPlayerReady: true,
    });
  }

  onError({ error }) {
    // eslint-disable-next-line no-console
    console.warn("onError", {
      localizedDescription: error.localizedDescription,
    });
    var didRun = false;
    if (isAppleMobile() && !didRun) {
      setTimeout(() => {
        this.props.navigator.goBack();
      }, 800);
      didRun = true;
    }
    this.setState({ playerState: PLAYER_STATES.ERROR });
  }

  getOverlayPlugin() {
    return R.compose(
      R.find(R.propEq("type", "player_overlay")),
      R.prop("plugins")
    )(this.props);
  }

  onProgress({ currentTime }) {
    this.currentTime = currentTime;

    const duration = this.duration;
    const { showOverlay } = this.state;
    const { item } = this.props;
    const isPlayNextFeed = !!item.extensions?.play_next_feed_url;

    const overlayPlugin = this.getOverlayPlugin();
    const overlayDuration = Number(R.path(["configuration", "overlay_duration"], overlayPlugin)) || 0;

    // eslint-disable-next-line max-len
    const overlayTrigger = R.path(["playableItem", "extensions", "overlay_timestamp"], this.props) || Number.MAX_SAFE_INTEGER;

    const triggerTime = Math.min(duration - overlayDuration, overlayTrigger);

    if (isPlayNextFeed && currentTime >= triggerTime && !showOverlay) {
      this.setState({ showOverlay: true });
    }
  }

  onVideoEnd() {
    const { item, navigator } = this.props;
    sendVideoItemPlayStopTimedEvent(
      item,
      this.duration,
      this.currentTime
    );

    navigator.goBack();

    this.updatePlayerState(PLAYER_STATES.STOP);
  }

  playerRemoteHandler(component, event) {
    const { item, navigator } = this.props;
    const { eventType } = event;

    const isUserFinishedWatchMovie = false;
    if (eventType === "menu") {
      navigator.goBack();
      sendVideoItemPlayStopTimedEvent(
        item,
        this.duration,
        this.currentTime,
        isUserFinishedWatchMovie
      );
    }
  }

  onAdChangedState({ advertismentPlaying }) {
    advertismentPlaying && this.setState({ advertismentPlaying });
  }

  getPlayerControls() {
    const { plugins } = this.props;
    const PlayerControls = R.find(
      R.propEq("type", "player_controls"),
      plugins
    );
    return PlayerControls;
  }

  getAudioPlayerConfig() {
    const { Player = {} } = this.props;
    return R.prop("__plugin_configuration", Player);
  }

  // Overlay Methods ---------------------------------------------
  hasOverlay() {
    const overlayPlugin = this.getOverlayPlugin();
    const play_next_feed_url = R.path(
      ["item", "extensions", "play_next_feed_url"],
      this.props
    );
    return overlayPlugin && play_next_feed_url;
  }

  renderOverlay() {
    const { item, navigator } = this.props;
    const { configuration, module: OverlayPluginComponent } = this.getOverlayPlugin() || {};
    const isPlayNextFeed = !!item.extensions?.play_next_feed_url;

    if (isPlayNextFeed) {
      return (
        <OverlayPluginComponent
          playableItem={item}
          configuration={configuration}
          navigator={navigator}
          dismissOverlay={(cb = noop) => {
            if (this._isMounted) {
              this.setState({ showOverlay: false }, cb);
            }
          }}
        />
      );
    }
  }

  render() {
    const { item = {}, Player } = this.props;
    const uri = item.content ? item.content.src : null;

    const { title, summary, type } = item;

    const { value: contentType } = type;
    const isAudioContent = contentType === "audio";
    const AudioPlayerConfig = this.getAudioPlayerConfig();
    const PlayerControls = this.getPlayerControls();

    const {
      playerState,
      advertismentPlaying,
      isPlayerReady,
      ignoreSilentSwitch,
      showOverlay,
    } = this.state;
    const isPlayerPaused = playerState === PLAYER_STATES.PAUSE;
    const isPlayerLoading = playerState === PLAYER_STATES.LOADING;
    const isPlayerError = !!(playerState === PLAYER_STATES.ERROR);

    return (
      <TVEventHandlerComponent tvEventHandler={this.playerRemoteHandler}>
        <View style={this.style.container}>
          <Player
            source={{
              uri,
              entry: item,
            }}
            onFullscreenPlayerDidDismiss={this.onFullscreenPlayerDidDismiss}
            playableItem={item}
            controls={!PlayerControls}
            onError={this.onError}
            onLoad={this.onLoad}
            onEnd={this.onVideoEnd}
            onPlaybackRateChange={this.onPlaybackRateChange}
            onProgress={this.onProgress}
            onAdChangedState={this.onAdChangedState}
            ignoreSilentSwitch={ignoreSilentSwitch}
          >
            {this._isMounted === true && showOverlay && this.renderOverlay()}

            {!showOverlay && isPlayerReady && (
              <View>
                {!isAudioContent &&
                  isPlayerPaused &&
                  advertismentPlaying === false && (
                  <ProgramInfo title={title} subtitle={summary} />
                )}
              </View>
            )}

            {isPlayerReady && !isPlayerLoading && isAudioContent && (
              <AudioPlayer
                audio_item={item}
                plugin_configuration={AudioPlayerConfig}
              />
            )}
          </Player>
          {isPlayerError && <ErrorDisplay />}
          {isPlayerLoading && <BufferAnimation />}
        </View>
      </TVEventHandlerComponent>
    );
  }
}
