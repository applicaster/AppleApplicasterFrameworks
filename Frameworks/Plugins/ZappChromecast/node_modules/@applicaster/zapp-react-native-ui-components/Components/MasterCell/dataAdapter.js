import * as R from "ramda";
import { isFunction } from "@applicaster/zapp-react-native-utils/functionUtils";

import { functionForName } from "./MappingFunctions";

/**
 * Uses passed function or retrieves function according to func name,
 * and performs the function on the entry with the provided args.
 * @param {Object} entry    Single entry of a feed
 * @param {String | Function} func     Func name or custom function
 * @param {Array} args      Additional arguments for the function
 */
function retrieveData(entry, func, args) {
  const functionSelector = _func =>
    isFunction(_func) ? _func : functionForName(_func);

  if (R.isNil(func)) {
    throw new Error(
      "Missing func in the data mapping, please revise or update cell styles configuration"
    );
  }
  // TODO: refactor for args to be variadic (...args)
  return functionSelector(func)(entry, args);
}

/**
 * Inflates the provided masterCell configuration with the data coming from a datasource entry
 * curried function of the form configInflater(entry)(masterCellConfig)
 * @param {Object} entry from the data source
 * @param {Object} masterCellConfig master cell configuration coming from zapp
 * @param {String} masterCellConfig.type of the component
 * @param {Object} masterCellConfig.style default style object for the component
 * @param {?Object} masterCellConfig.data func/args/propName that indicates how to extract
 * the data from the entry and to which prop it should be injected after manipulation
 * @param {?[Object]} element.elements Optional array of nested elements to render within the current node
 * @returns {Object} inflated configuration, ready to be rendered by the master cell's element mapper
 */
function configInflater(entry) {
  return function({ type, style, additionalProps = {}, data = [], elements }) {
    const props = R.reduce(
      (acc, curr) =>
        R.assoc(curr.propName, retrieveData(entry, curr.func, curr.args), acc),
      additionalProps,
      data
    );

    if (Array.isArray(elements)) {
      elements = R.map(configInflater(entry), elements);
    }

    return {
      type,
      style,
      props,
      elements,
    };
  };
}

/**
 * Return the proper view tree according to entry's content type and UI state.
 * Falls back to "default" content type or state.
 * @param {Object} entry  data source feed entry
 * @param {"selected" | "focused" | ...} state of the current cell
 * @param {Object} elements  master cell configuration
 */
function resolveElementsNode(entry, state, elements) {
  const contentType = R.path(["type", "value"], entry);

  return R.compose(
    R.either(R.prop(state), R.prop("default")),
    R.prop("states"),
    R.either(R.prop(contentType), R.prop("default"))
  )(elements.content_types);
}

/**
 * Data adapters take the elements in a master cell configuration, and
 * inflate all these elements with the data coming from a given data source entry,
 * using the configInflater function above.
 * curried function of the form dataAdapter(elements)(entry)
 * @param {Object} elements : master cell configuration
 * @param {Object} entry : data source feed entry containing the data to inject in the master cell configuration
 * @returns {Object} master cell configuration fully populated with the data coming from the data source entry
 */
export function defaultDataAdapter(elements) {
  return function elementsBuilder({ entry, state = "default" }) {
    return R.map(
      configInflater(entry),
      resolveElementsNode(entry, state, elements)
    );
  };
}
