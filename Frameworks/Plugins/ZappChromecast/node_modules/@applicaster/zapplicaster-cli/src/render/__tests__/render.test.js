const {
  injectDependencies,
  injectScripts,
  renderFile,
  saveConfigFile,
  renderConfigFile,
  renderTemplateFile,
} = require("../index");

const mockRenderFile = fileData => `file data ${JSON.stringify(fileData)}`;

jest.mock("ejs", () => ({
  ...require.requireActual("ejs"),
  renderFile: jest.fn((path, fileData, cb) =>
    cb(null, mockRenderFile(fileData))
  ),
}));

const ejs = require("ejs");

jest.mock("../../file", () => ({
  writeJsonToFile: jest.fn(fileName => {
    if (fileName.includes("THROW")) {
      throw new Error("errro");
    }
  }),
  writeFileAsync: jest.fn(),
}));

const { writeJsonToFile, writeFileAsync } = require("../../file");

jest.mock("path", () => ({
  ...require.requireActual("path"),
  resolve: jest.fn(require.requireActual("path").join),
}));

const { resolve, join } = require("path");

const FOO = "foo";
const BAR = "bar";
const FOO_VERSION = "0.0.1";
const BAR_VERSION = "1.3.2";

const dependencies = [
  {
    type: "dependencies",
    name: FOO,
    version: FOO_VERSION,
  },
  {
    type: "devDependencies",
    name: BAR,
    version: BAR_VERSION,
  },
];

function clearAllMocks() {
  writeJsonToFile.mockClear();
  writeFileAsync.mockClear();
  ejs.renderFile.mockClear();
}

describe("injectDependencies", () => {
  afterEach(clearAllMocks);

  it("adds dependencies from package.json", async () => {
    const templatePackageJsonPath = resolve(
      __dirname,
      "./fixtures/packageWithDependencies"
    );
    const templatePackageJson = require(resolve(
      templatePackageJsonPath,
      "./package.json"
    ));

    await injectDependencies(dependencies, templatePackageJsonPath);

    expect(writeJsonToFile).toHaveBeenCalledWith(
      resolve(templatePackageJsonPath, "./package.json"),
      Object.assign(templatePackageJson, {
        dependencies: {
          ...templatePackageJson.dependencies,
          [FOO]: FOO_VERSION,
        },
        devDependencies: {
          ...templatePackageJson.devDependencies,
          [BAR]: BAR_VERSION,
        },
      })
    );
  });

  it("adds dependencies and devDependencies properties if they don't exist in package.json", async () => {
    const templatePackageJsonPath = resolve(
      __dirname,
      "./fixtures/packageWithNoDependencies"
    );

    return expect(
      async () =>
        await injectDependencies(dependencies, templatePackageJsonPath)
    ).not.toThrow();
  });
});

describe("injectScripts", () => {
  const START_SCRIPT = "node_modules/.bin/react-native start --root .";
  // eslint-disable-next-line max-len
  const RUN_IOS_SCRIPT =
    "node_modules/.bin/react-native run-ios --project-path $ZAPP_APP_PATH --scheme Zapp-App --configuration Debug";
  const START_IOS_SCRIPT = "yarn run:ios & yarn start";

  const scripts = [
    { name: "start", command: START_SCRIPT },
    { name: "run:ios", command: RUN_IOS_SCRIPT },
    { name: "start:ios", command: START_IOS_SCRIPT },
  ];

  afterEach(clearAllMocks);

  it("adds scripts in package.json", async () => {
    const templatePackageJsonPath = resolve(
      __dirname,
      "./fixtures/packageWithDependencies"
    );
    const templatePackageJson = require(resolve(
      templatePackageJsonPath,
      "./package.json"
    ));

    await injectScripts(scripts, templatePackageJsonPath);

    expect(writeJsonToFile).toHaveBeenCalledWith(
      resolve(templatePackageJsonPath, "./package.json"),
      Object.assign(templatePackageJson, {
        scripts: {
          ...templatePackageJson.scripts,
          start: START_SCRIPT,
          "run:ios": RUN_IOS_SCRIPT,
          "start:ios": START_IOS_SCRIPT,
        },
      })
    );
  });

  it("creates script if it doesn't exist in package.json", async () => {
    const templatePackageJsonPath = resolve(
      __dirname,
      "./fixtures/packageWithNoDependencies"
    );

    return expect(
      async () => await injectScripts([], templatePackageJsonPath)
    ).not.toThrow();
  });
});

describe("renderFile", () => {
  afterEach(clearAllMocks);

  it("renders the template, at the specific path, with the injected data", async () => {
    const templatePath = join(__dirname, "index.js.ejs");
    const filePath = "foo.js";
    const renderData = { foo: "bar" };

    const expectedRenderedResult = mockRenderFile(renderData);

    await renderFile(templatePath, filePath, renderData);
    expect(ejs.renderFile).toHaveBeenCalledWith(
      resolve(templatePath),
      renderData,
      expect.any(Function)
    );

    expect(writeFileAsync).toHaveBeenCalledWith(
      filePath,
      expectedRenderedResult
    );
  });
});

describe("saveConfigFile", () => {
  const destinationPath = "path/to/workspace";
  const platform = "ios";
  const fileName = "foo.json";
  const jsonObject = { foo: "bar" };
  const path = join(destinationPath, "config", platform, fileName);

  afterEach(clearAllMocks);

  it("saves the provided file", async () => {
    await saveConfigFile({ destinationPath, platform }, fileName, jsonObject);

    return expect(writeJsonToFile).toHaveBeenCalledWith(path, jsonObject);
  });

  it("throws if an error occurs while writing the file", async () => {
    expect.assertions(1);
    try {
      await saveConfigFile({ destinationPath, platform }, "THROW", jsonObject);
    } catch (e) {
      expect(e).toMatchSnapshot();
    }
  });
});

describe("renderConfigFile", () => {
  const destinationPath = "path/to/workspace";
  const platform = "ios";
  const fileName = "custom_config.json";
  const mockCustomConfigContent = { custom: "config" };
  const getJsonContent = jest.fn(() => mockCustomConfigContent);
  const configuration = { destinationPath, platform };
  const path = join(destinationPath, "config", platform, fileName);

  afterEach(clearAllMocks);

  it("renders the configuration file", async () => {
    await renderConfigFile(configuration)({ name: fileName, getJsonContent });

    expect(getJsonContent).toHaveBeenCalledWith(configuration);
    expect(writeJsonToFile).toHaveBeenCalledWith(path, mockCustomConfigContent);
  });
});

describe("renderTemplateFile", () => {
  const destinationPath = "path/to/workspace";
  const platform = "ios";
  const configuration = {
    destinationPath,
    platform,
  };
  const templatePath = "path/to/template.js.ejs";
  const filePath = "dest/filePath.js";
  const mockFilePathFn = config => `dest/${config.platform}/filePath.js`;
  const filePathFn = jest.fn(mockFilePathFn);
  const plugins = { plugin1: "some_plugin" };

  afterEach(clearAllMocks);

  it("renders the template file", async () => {
    await renderTemplateFile(configuration, destinationPath, plugins)({
      templatePath,
      filePath,
    });

    expect(ejs.renderFile).toHaveBeenCalledWith(
      resolve(templatePath),
      expect.objectContaining({ configuration, plugins }),
      expect.any(Function)
    );

    expect(writeFileAsync).toHaveBeenCalledWith(
      resolve(destinationPath, filePath),
      mockRenderFile({ configuration, plugins })
    );
  });

  it("renders the template file by applying the function to get the path", async () => {
    filePathFn.mockClear();

    await renderTemplateFile(configuration, destinationPath, plugins)({
      templatePath,
      filePath: filePathFn,
    });

    expect(filePathFn).toHaveBeenCalledWith(configuration);

    expect(ejs.renderFile).toHaveBeenCalledWith(
      resolve(templatePath),
      expect.objectContaining({ configuration, plugins }),
      expect.any(Function)
    );

    expect(writeFileAsync).toHaveBeenCalledWith(
      resolve(destinationPath, mockFilePathFn(configuration)),
      mockRenderFile({ configuration, plugins })
    );

    filePathFn.mockClear();
  });
});
