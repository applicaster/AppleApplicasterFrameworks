// @flow
import * as React from "react";

import { focusManager } from "@applicaster/zapp-react-native-utils/appUtils/focusManager";
import { noop } from "@applicaster/zapp-react-native-utils/functionUtils";

type Props = {
  initialFocus: ?boolean,
  id: string,
  groupId: ?string,
  node: {},
  preferredFocus: ?boolean,
  onRegister: ?({}) => void,
  onUnregister: ?({}) => void,
  willReceiveFocus: ?({}, ({}) => void) => void,
  onFocus: ({}) => void,
  hasReceivedFocus: ?({}, ({}) => void) => void,
  willLoseFocus: ?({}, ({}) => void) => void,
  onBlur: ?({}) => void,
  hasLostFocus: ?({}) => void,
  failedLostFocus: ?({}) => void,
  onPress: ({}) => void,
  children: (boolean, string) => React.ComponentType<any>,
  selected: ?boolean,
};
type State = {
  focused: boolean,
};

export class BaseFocusable extends React.Component<Props, State> {
  constructor(props) {
    super(props);
    const { initialFocus } = this.props;

    this.state = {
      focused: initialFocus || false,
    };

    this.onRegister = this.onRegister.bind(this);
    this.onUnregister = this.onUnregister.bind(this);
    this.setFocusedState = this.setFocusedState.bind(this);
    this.willReceiveFocus = this.willReceiveFocus.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.hasReceivedFocus = this.hasReceivedFocus.bind(this);
    this.willLoseFocus = this.willLoseFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.hasLostFocus = this.hasLostFocus.bind(this);
    this.failedLostFocus = this.failedLostFocus.bind(this);
    this.onPress = this.onPress.bind(this);
    this.ref = React.createRef();
  }

  getId() {
    const { id, groupId = null } = this.props;
    return groupId ? `${groupId}-${id}` : id;
  }

  componentDidMount() {
    this._isMounted = true;
    const component = this;
    this.node = this.ref.current;

    focusManager.register({
      id: this.getId(),
      component: component,
    });
  }

  measureView(event, cb = noop) {
    if (this._isMounted && this.ref && this.ref.current) {
      this.ref.current.measure((x, y, width, height, pageX, pageY) => {
        const top = pageY;
        const bottom = top + height;
        const left = pageX;
        const right = left + width;

        const boundingRect = {
          x,
          y,
          pageX,
          pageY,
          width,
          height,
          top,
          bottom,
          left,
          right,
        };

        cb(boundingRect);
      });
    }
  }

  /**
   * returns the Rect of the underlying component of the Focusable
   * @returns {Object} {x, y, width, height, top, bottom, left, right }
   */
  getRect() {
    return new Promise(resolve => {
      this.measureView(null, rect => {
        resolve(rect);
      });
    });
  }

  isMounted() {
    return this._isMounted;
  }

  componentWillUnmount() {
    this._isMounted = false;
    focusManager.unregister(this.getId(), { group: this.isGroup || false });
  }

  /**
   * will invoke the underlying component's onRegister method
   * @param {Object} focusable - sender
   * @returns {Promise}
   */
  onRegister(focusable) {
    const { onRegister = noop } = this.props;
    onRegister(focusable);
  }

  /**
   * will invoke the underlying component's onUnregister method
   * @param {Object} focusable - sender
   * @returns {Promise}
   */
  onUnregister(focusable) {
    const { onUnregister = noop } = this.props;
    onUnregister(focusable);
  }

  /**
   * will invoke the underlying component's willLoseFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  willLoseFocus(focusable, scrollDirection) {
    const { willLoseFocus = noop } = this.props;
    willLoseFocus(focusable, scrollDirection);
  }

  /**
   * will invoke the underlying component's willReceiveFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  willReceiveFocus(focusable, scrollDirection) {
    const { willReceiveFocus = noop } = this.props;
    willReceiveFocus(focusable, scrollDirection);
  }

  /**
   * will invoke the underlying component's focus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  onFocus(focusable, scrollDirection) {
    const { onFocus = noop } = this.props;
    this.setFocusedState(true);
    onFocus(focusable, scrollDirection);
  }
  /**
   * will invoke the underlying component's hasReceivedFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  hasReceivedFocus(focusable, scrollDirection) {
    const { hasReceivedFocus = noop } = this.props;
    hasReceivedFocus(focusable, scrollDirection);
  }

  /**
   * will invoke the underlying component's hasLostFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  hasLostFocus(focusable, scrollDirection) {
    const { hasLostFocus = noop } = this.props;
    hasLostFocus(focusable, scrollDirection);
  }

  /**
   * will invoke the underlying component's failedLostFocus method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  failedLostFocus(focusable, scrollDirection) {
    const { failedLostFocus = noop } = this.props;
    failedLostFocus(focusable, scrollDirection);
  }

  /**
   * will invoke the underlying component's onBlur method
   * @param {Object} focusable - sender
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  onBlur(focusable, scrollDirection) {
    const { onBlur = noop } = this.props;
    this.setFocusedState(false);
    onBlur(focusable, scrollDirection);
  }

  /**
   * will invoke the underlying component's onPress method
   * @param {Object} focusable - sender
   * @param {Object} keyEvent
   * @returns {Promise}
   */
  onPress(focusable, keyEvent) {
    const { onPress = noop } = this.props;
    onPress(focusable, keyEvent);
  }

  /**
   * will tell if the item is in the given group
   * @param {Object} FocusableGroup to test
   * @returns {boolean}
   */
  isInGroup(group) {
    const { groupId } = this.props;
    const { id } = group.props;
    return id === groupId;
  }

  setFocusedState(focused) {
    this.setState({ focused });
  }
}
