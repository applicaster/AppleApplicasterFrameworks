import React from "react";
import { shallow } from "enzyme";
import { shallowToJson } from "enzyme-to-json";
import * as zappPipesRedux from "@applicaster/zapp-react-native-redux/ZappPipes";
import configureStore from "redux-mock-store";
import thunk from "redux-thunk";

import { zappPipesDataConnector } from "../index";
import { Hero } from "../../../Components/Hero";

const mockStore = configureStore([thunk]);
const initialState = { zappPipes: {} };
const store = mockStore(initialState);

const zappPipesSpy = jest
  .spyOn(zappPipesRedux, "loadPipesData")
  .mockImplementation(() => ({ type: "load_data", payload: "data" }));

const WrappedComponent = zappPipesDataConnector(Hero);

const componentProp = data => ({ data });

describe("zappPipesDataConnector", () => {
  describe("with standard dataSource", () => {
    const data = {
      source: "dataSourceUrl",
      type: "APPLICASTER_ATOM_FEED",
    };

    it("is a HoC", () => {
      expect(zappPipesDataConnector).toBeFunction();
      const wrapper = shallow(
        <WrappedComponent component={componentProp(data)} />,
        {
          context: { store },
        }
      );
      expect(shallowToJson(wrapper)).toMatchSnapshot();
      expect(wrapper.first().shallow()).toMatchSnapshot();
      expect(zappPipesSpy).toHaveBeenCalledWith(data.source);
    });
  });

  describe("with Applicaster Collection Id", () => {
    const data = {
      source: "1234",
      type: "APPLICASTER_COLLECTION",
    };

    it("is a HoC", () => {
      expect(zappPipesDataConnector).toBeFunction();

      const wrapper = shallow(
        <WrappedComponent component={componentProp(data)} />,
        {
          context: { store },
        }
      );

      expect(shallowToJson(wrapper)).toMatchSnapshot();
      expect(wrapper.first().shallow()).toMatchSnapshot();
      expect(zappPipesSpy).toHaveBeenCalledWith(
        "applicaster://fetchData?type=APPLICASTER_COLLECTION&collectionId=1234"
      );
    });
  });

  describe("with Applicaster Category Id", () => {
    const data = {
      source: "1234",
      type: "APPLICASTER_CATEGORY",
    };

    it("is a HoC", () => {
      expect(zappPipesDataConnector).toBeFunction();

      const wrapper = shallow(
        <WrappedComponent component={componentProp(data)} />,
        {
          context: { store },
        }
      );
      expect(shallowToJson(wrapper)).toMatchSnapshot();
      expect(wrapper.first().shallow()).toMatchSnapshot();
      expect(zappPipesSpy).toHaveBeenCalledWith(
        "applicaster://fetchData?type=APPLICASTER_CATEGORY&categoryId=1234&platform=ios"
      );
    });
  });

  describe("getDataSourceUrl", () => {
    it("returns null if data prop is empty", () => {
      const wrapper = shallow(
        <WrappedComponent component={componentProp({})} />,
        {
          context: { store },
        }
      );

      expect(
        wrapper
          .first()
          .shallow()
          .instance()
          .getDataSourceUrl()
      ).toBe(null);
    });

    it("returns null if data.source is falsy", () => {
      const wrapper = shallow(
        <WrappedComponent component={componentProp({ source: null })} />,
        {
          context: { store },
        }
      );

      expect(
        wrapper
          .first()
          .shallow()
          .instance()
          .getDataSourceUrl()
      ).toBe(null);
    });
  });

  describe("reloadDataSource", () => {
    const data = {
      source: "1234",
      type: "APPLICASTER_CATEGORY",
    };

    it("reloads the app's datasource", () => {
      store.clearActions();

      const wrapper = shallow(
        <WrappedComponent component={componentProp(data)} />,
        {
          context: { store },
        }
      );

      const actionsBefore = store.getActions();
      expect(actionsBefore).toMatchSnapshot();

      const heroProps = wrapper
        .first()
        .shallow()
        .props();
      heroProps.reloadData();

      const actionsAfter = store.getActions();
      expect(actionsAfter).toMatchSnapshot();
    });
  });
});
