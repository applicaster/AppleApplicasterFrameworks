import * as R from "ramda";
import {
  functionForName,
  imageSrcFromMediaItem,
  pathWithFallback,
  stringifyDateFromPath,
} from "../../MappingFunctions";
import { entry } from "../../__tests__/testEntry";

describe("functionForName", () => {
  it("returns a function matching the func name", () => {
    const myFunction = functionForName("stringify_date_from_path");
    expect(myFunction).toBeFunction();
    expect(myFunction.name).toBe("stringifyDateFromPath");
  });

  it("returns 'pathWithFallback' function as a fallback when no matching func name is found", () => {
    const myFunction = functionForName("does_not_exist");
    expect(myFunction.name).toBe("pathWithFallback");
  });

  it("returns 'pathWithFallback' function as a default", () => {
    const myFunction = functionForName(undefined);
    expect(myFunction.name).toBe("pathWithFallback");
  });
});

describe("pathWithFallback", () => {
  it("returns the value found in the obj, according to given path", () => {
    expect(pathWithFallback(entry, ["author", "name"])).toBe(entry.author.name);
  });

  it("returns an empty string if not found", () => {
    expect(pathWithFallback(entry, ["does_not_exist"])).toBe("");
  });
});

describe("stringifyDateFromPath", () => {
  it("returns a stringified format of the ISO8061 date found in path", () => {
    expect(stringifyDateFromPath(entry, ["published"])).toBe(
      new Date("2019/03/17 02:17:46 +0000").toDateString()
    );
  });

  it("returns an empty string if found value is not a valid ISO8061 date", () => {
    expect(stringifyDateFromPath(entry, ["title"])).toBe("");
  });

  it("returns an empty string if not found", () => {
    expect(stringifyDateFromPath(entry, ["does_not_exist"])).toBe("");
  });
});

describe("imageSrcFromMediaItem", () => {
  describe("returns the src value of first media_item", () => {
    it("when the matching key is found and the src is not empty", () => {
      const result = imageSrcFromMediaItem(entry, ["logo_thumbnail"]);

      expect(result).toEqual(entry.media_group[1].media_item[0].src);
      expect(result).not.toEqual("");
    });
  });

  it("returns a media item with the 'image_base' key as a fallback", () => {
    const result = imageSrcFromMediaItem(entry, ["does_not_exist"]);
    const fallback = entry.media_group[0].media_item[0];
    expect(result).toEqual(fallback.src);
    expect(fallback.key).toBe("image_base");
  });

  it("returns undefined if the key was found but the source was empty", () => {
    const badEntry = R.set(
      R.lensPath(["media_group", 0, "media_item", 0, "src"]),
      "",
      entry
    );
    expect(imageSrcFromMediaItem(badEntry, ["image_base"])).toBeUndefined();
  });
});
