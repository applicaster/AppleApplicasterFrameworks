import * as helpers from "../index";
import btoa from "btoa";

describe("url scheme helpers", () => {
  describe("parseUrl", () => {
    it("returns a valid object", () => {
      const scheme = "foo";
      const host = "host";
      const path = "/path/to/file";
      const queryString = "p=1&q=qVar";

      const query = {
        p: "1",
        q: "qVar",
      };

      const fragment = "hashValue";

      const urlString = `${scheme}://${host}${path}?${queryString}#${fragment}`;

      expect(helpers.parseUrl(urlString)).toEqual(
        expect.objectContaining({
          scheme,
          host,
          path,
          query,
          fragment,
        })
      );
    });

    it("handles present?data_source=&entry_id=", () => {
      const scheme = "app";
      const data_source_string = "data_source_string";
      const entry_id = "A1234";
      const urlString = `${scheme}://present?data_source=${data_source_string}&entry_id=${entry_id}`;

      expect(helpers.parseUrl(urlString)).toEqual(
        expect.objectContaining({
          scheme,
          host: "present",
          query: {
            data_source: data_source_string,
            entry_id,
          },
        })
      );
    });
  });

  describe("decodeUrl", () => {
    it("decodes an encoded url", () => {
      const decodedUrl = "feed://fetchData?type=foo&url=bar";
      const encodedUrl = encodeURIComponent(btoa(decodedUrl));

      expect(helpers.decodeUrl(encodedUrl)).toEqual(decodedUrl);
    });

    it("returns the original string if it fails to be decoded", () => {
      const urlString = "not encoded string";
      expect(helpers.decodeUrl(urlString)).toEqual(urlString);
    });
  });
});
