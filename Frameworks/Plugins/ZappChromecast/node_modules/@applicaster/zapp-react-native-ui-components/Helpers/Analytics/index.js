import * as R from "ramda";
import {
  postAnalyticEvent,
  startAnalyticsTimedEvent,
  endAnalyticsTimedEvent,
} from "@applicaster/zapp-react-native-tvos-app/AnalyticsManager";
import { mapKeys } from "@applicaster/zapp-react-native-utils/objectUtils";
import {
  ANALYTICS_CORE_EVENTS,
  ANALYTICS_ENTRY_EVENTS,
  ANALYTICS_COMPONENT_EVENTS,
  ANALYTICS_MENU_ITEM_EVENTS,
} from "../";

export function sendTapCellEvent(item, component, headerTitle, itemIndex) {
  const itemReadableIndex = itemIndex + 1;
  const analyticsProperties = R.compose(
    R.reject(R.isNil),
    R.merge(eventForEntry(item, itemReadableIndex))
  )(eventForComponent(component, headerTitle));
  postEvent(ANALYTICS_CORE_EVENTS.TAP_CELL, analyticsProperties);
}

export function sendVideoItemPlayStartTimedEvent(item, durationInMiliseconds) {
  const analyticsProperties = R.compose(
    R.reject(R.isNil),
    R.merge({
      [ANALYTICS_ENTRY_EVENTS.ITEM_DURATION]: durationInMiliseconds,
      [ANALYTICS_ENTRY_EVENTS.ITEM_PLAY_COMPLETED]: "NO",
    })
  )(eventForEntry(item));

  startAnalyticsTimedEvent(
    ANALYTICS_CORE_EVENTS.PLAY_VOD_ITEM,
    analyticsProperties
  );
}
export function sendVideoItemPlayStopTimedEvent(
  item,
  durationInMiliseconds,
  currentTime,
  isUserFinishedWatchMovie = null
) {
  let playCompleted = isUserFinishedWatchMovie ? "YES" : "NO";
  if (R.isNil(isUserFinishedWatchMovie)) {
    playCompleted = "YES";
  }

  const analyticsProperties = R.compose(
    R.reject(R.isNil),
    R.merge({
      [ANALYTICS_ENTRY_EVENTS.ITEM_TOTAL_TIME_PLAYED]:
        currentTime && currentTime.toString(),
      [ANALYTICS_ENTRY_EVENTS.ITEM_DURATION]:
        durationInMiliseconds && durationInMiliseconds.toString(),
      [ANALYTICS_ENTRY_EVENTS.ITEM_PLAY_COMPLETED]: playCompleted,
    })
  )(eventForEntry(item));
  endAnalyticsTimedEvent(
    ANALYTICS_CORE_EVENTS.PLAY_VOD_ITEM,
    analyticsProperties
  );
}
export function sendVideoItemPlayEvent(item) {
  const analyticsProperties = R.compose(R.reject(R.isNil))(eventForEntry(item));

  postEvent(playEventForType(item), analyticsProperties);
}

export function sendTapMenuItem({ item, index, isHome }) {
  const analyticsProperties = R.compose(R.reject(R.isNil))(
    eventForMenuItemEntry({ item, index, isHome })
  );

  postEvent(ANALYTICS_CORE_EVENTS.TAP_MENU_ICON, analyticsProperties);
  if (isHome) {
    postEvent(ANALYTICS_CORE_EVENTS.HOME_SCREEN_VIEWED, null);
  }
}

function playEventForType(item) {
  const itemType = item.type && item.type.value;

  if (itemType === "program") {
    return ANALYTICS_CORE_EVENTS.PROGRAM_ITEM_PLAY_WAS_TRIGGERED;
  } else if (itemType === "channel") {
    return ANALYTICS_CORE_EVENTS.CHANNEL_ITEM_PLAY_WAS_TRIGGERED;
  } else {
    return ANALYTICS_CORE_EVENTS.VOD_ITEM_PLAY_WAS_TRIGGERED;
  }
}

function postEvent(event, properties) {
  postAnalyticEvent(event, properties);
}

function eventForEntry(item, itemIndex) {
  const {
    title,
    content: { src },
    type: { value: valueType },
    id,
    screen_type,
    extensions,
  } = item;
  const analyticsCustomProps = entryAnalyticsCustomProperies(item);
  const isFreeParameter =
    extensions && extensions.free !== true ? "Paid" : "Free";

  return {
    [ANALYTICS_ENTRY_EVENTS.ITEM_TYPE]: valueType,
    [ANALYTICS_ENTRY_EVENTS.ITEM_TITLE]: title,
    [ANALYTICS_ENTRY_EVENTS.ITEM_ID]: id,
    [ANALYTICS_ENTRY_EVENTS.ITEM_LINK]: encodeURIComponent(src),
    [ANALYTICS_ENTRY_EVENTS.ITEM_TARGET]:
      screen_type || ANALYTICS_CORE_EVENTS.ITEM_NOT_AVAILABLE,
    [ANALYTICS_ENTRY_EVENTS.ITEM_INDEX]:
      (itemIndex && itemIndex.toString()) || null,
    [ANALYTICS_ENTRY_EVENTS.ITEM_INDEX_IS_FREE]: isFreeParameter,
    ...analyticsCustomProps,
  };
}

const entryAnalyticsCustomProperies = R.compose(
  R.ifElse(
    R.isNil,
    R.always({}),
    mapKeys(
      R.compose(
        R.concat(ANALYTICS_ENTRY_EVENTS.ITEM_CUSTOM_PROPERTY),
        R.concat(" ")
      )
    )
  ),
  R.path(["extensions", "analyticsCustomProperties"])
);

function eventForComponent(component, headerTitle) {
  const { id, component_type, styles, data, rules } = component;
  const { cell_style, family, header } = styles;
  const { visible } = header;
  const { connected, target, source, type } = data;
  const itemLimit = rules.item_limit ? rules.item_limit.toString() : "NO";
  return {
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_ID]: id,
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_TYPE]: component_type,
    [ANALYTICS_COMPONENT_EVENTS.CELL_STYLE]:
      cell_style || ANALYTICS_CORE_EVENTS.ITEM_NOT_AVAILABLE,
    [ANALYTICS_COMPONENT_EVENTS.CELL_FAMILY]: family,
    [ANALYTICS_COMPONENT_EVENTS.HAS_HEADERS]: visible ? "YES" : "NO",
    [ANALYTICS_COMPONENT_EVENTS.CONNECTED_SCREEN]: connected ? "YES" : "NO",
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_TARGET]:
      target || ANALYTICS_CORE_EVENTS.ITEM_NOT_AVAILABLE,
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_SOURCE]: encodeURIComponent(source),
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_SOURCE_TYPE]: type,
    [ANALYTICS_COMPONENT_EVENTS.ITEM_LIMIT]: itemLimit,
    [ANALYTICS_COMPONENT_EVENTS.HEADER_TITLE]: headerTitle,
  };
}

function eventForMenuItemEntry({ item, index, isHome }) {
  const {
    title,
    type,
    id,
    data: { target },
  } = item;
  const itemReadableIndex = index + 1;
  return {
    [ANALYTICS_MENU_ITEM_EVENTS.ITEM_INDEX]:
      (itemReadableIndex && itemReadableIndex.toString()) || null,
    [ANALYTICS_MENU_ITEM_EVENTS.ITEM_TYPE]: type,
    [ANALYTICS_MENU_ITEM_EVENTS.ITEM_TITLE]: title,
    [ANALYTICS_MENU_ITEM_EVENTS.ITEM_ID]: id,
    [ANALYTICS_MENU_ITEM_EVENTS.ITEM_TARGET]:
      target || ANALYTICS_CORE_EVENTS.ITEM_NOT_AVAILABLE,
    [ANALYTICS_MENU_ITEM_EVENTS.ITEM_HOME_SCREEN]: isHome ? "YES" : "NO",
  };
}
