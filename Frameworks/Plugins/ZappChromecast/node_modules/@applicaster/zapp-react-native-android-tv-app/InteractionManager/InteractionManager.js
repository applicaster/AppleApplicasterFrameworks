import * as React from "react";
import { DeviceEventEmitter } from "react-native";
import * as R from "ramda";

import {
  sendQuickBrickEvent,
  QUICK_BRICK_EVENTS,
} from "@applicaster/zapp-react-native-bridge/QuickBrick";

import {
  keyEventMapper,
  KEYS,
  ARROW_KEYS,
} from "@applicaster/zapp-react-native-utils/appUtils/keyCodes/keys";

import { keyCode } from "@applicaster/zapp-react-native-utils/appUtils/keyCodes";
import { FocusManagerContext } from "@applicaster/zapp-react-native-utils/focusManager";

type Props = {
  river: any,
  navigator: {
    goBack: () => void,
    canGoBack: () => boolean,
    currentRoute: string,
    replace: (any) => void,
  },
  children: React.Node,
};

export class InteractionManagerComponent extends React.Component<Props> {
  static contextType = FocusManagerContext;

  constructor(props) {
    super(props);
    this.onKeyDown = this.onKeyDown.bind(this);
  }

  componentDidMount() {
    DeviceEventEmitter.addListener("onTvKeyDown", this.onKeyDown);
  }

  componentWillUnmount() {
    DeviceEventEmitter.removeListener("onTvKeyDown", this.onKeyDown);
  }

  onKeyDown(event) {
    const { navigator } = this.props;
    const e = keyEventMapper(event.keyCode);

    if (keyCode(e).matches(KEYS.Back)) {
      if (navigator.canGoBack()) {
        navigator.goBack();
        this.context.resetFocus();
      } else if (this.isInHome()) {
        sendQuickBrickEvent(QUICK_BRICK_EVENTS.MOVE_APP_TO_BACKGROUND, {
          MOVE_APP_TO_BACKGROUND: true,
        });
      } else {
        const homeRiver = this.getHomeRiver();
        navigator.replace(homeRiver);
      }
    }

    if (keyCode(e).matches(KEYS.Enter)) {
      const { focused } = this.context;
      focused?.onPress?.(focused);
      return true;
    }

    if (keyCode(e).matchesAny(...ARROW_KEYS)) {
      const { focused, setFocus } = this.context;

      const direction = R.compose(
        R.replace("Arrow", ""),
        R.path(["value", "code"]),
        keyCode
      )(e);

      const nextFocus = focused?.props?.[`nextFocus${direction}`];
      if (nextFocus) {
        setFocus(nextFocus, { direction: R.toLower(direction) });
      }
      return true;
    }
  }

  getHomeRiver() {
    return R.compose(
      R.find(R.propEq("home", true)),
      R.values,
      R.prop("rivers")
    )(this.props);
  }

  isInHome() {
    const {
      navigator: { currentRoute },
    } = this.props;
    const homeRiver = this.getHomeRiver();
    const homeRiverPath = `/river/${homeRiver.id}`;
    return homeRiverPath === currentRoute;
  }

  render() {
    return this.props.children;
  }
}
