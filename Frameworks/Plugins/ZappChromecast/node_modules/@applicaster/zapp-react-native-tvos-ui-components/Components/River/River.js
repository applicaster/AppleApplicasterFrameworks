// @flow
import * as React from "react";
import * as R from "ramda";

import {
  ScrollView,
  StyleSheet,
  UIManager,
  findNodeHandle,
} from "react-native";

import { FeedLoader } from "@applicaster/zapp-react-native-ui-components/Components/FeedLoader";
import { riverFocusManager } from "@applicaster/zapp-react-native-utils/appUtils/RiverFocusManager";
import { FocusableGroup } from "@applicaster/zapp-react-native-ui-components/Components/FocusableGroup";
import { ScreenResolver } from "@applicaster/zapp-react-native-ui-components/Components/ScreenResolver";

import { ComponentsMap } from "./ComponentsMap";

type Props = {
  river: any,
  setMainOffsetUpdater: any => void,
  setMainFocusItemUpdater: any => void,
  feedUrl: string,
  isInsideContainer: boolean,
  parentScreenId: {},
  setIsScreenWrappedInContainer: any => void,
  screenData: {
    title: string,
  },
  navigator: { previousAction: string },

  screenDidLoad: () => void,
  screenDidAppear: () => void,
  screenDidDisappear: () => void,
  screenFocusedOnItem: () => void,
};

const riverStyles = StyleSheet.create({
  container: { flex: 1 },
});

export class RiverComponent extends React.Component<Props> {
  constructor(props) {
    super(props);
    this.screenPresented = false;
    this.onLayout = this.onLayout.bind(this);
    this.mainOffsetUpdater = this.mainOffsetUpdater.bind(this);
    this.mainFocusItemUpdater = this.mainFocusItemUpdater.bind(this);
    this.onContentSizeChange = this.onContentSizeChange.bind(this);
    this.componentDidFinishAnimation = this.componentDidFinishAnimation.bind(
      this
    );
    this.state = { scrollEnabled: true, customOffset: 0 };
    this.scrollViewRef = null;
    this.viewFrame = { x: 0, y: 0, width: 0, height: 0 };
    this.contentSize = { width: 0, height: 0 };
    this.currentScreenSummary = null;
    this.currentScreenTitle = null;

    this.applyContexts();
  }

  applyContexts() {
    const {
      setMainOffsetUpdater,
      setMainFocusItemUpdater,
      setIsScreenWrappedInContainer,
      isInsideContainer = false,
      screenDidLoad,
      river: { id },
    } = this.props;
    setMainOffsetUpdater(this.mainOffsetUpdater);
    setMainFocusItemUpdater(this.mainFocusItemUpdater);
    setIsScreenWrappedInContainer(isInsideContainer);
    screenDidLoad({ id, isInsideContainer });
  }

  onContentSizeChange(width, height) {
    this.contentSize = { width, height };
  }

  onLayout(event) {
    const {
      river: { id },
      isInsideContainer,
    } = this.props;

    const { x, y, width, height } = event.nativeEvent.layout;
    this.viewFrame = { x, y, width, height };
    const { currentScreenTitle, currentScreenSummary } = this;
    this.props.screenDidAppear({
      id,
      isInsideContainer,
      screenData: { title: currentScreenTitle, summary: currentScreenSummary },
    });
    // TODO: Uncommit it to start fixing bug where selection wrong item
    // const focusableRiverData = riverFocusManager.screenFocusableData({
    //   screenFocusableGroupId: this.screenFocusableGroupId(),
    // });
    // if (focusableRiverData) {
    //   const { contentOffsetY } = focusableRiverData;
    //   this.scrollViewRef.scrollTo({
    //     y: contentOffsetY,
    //     animated: false,
    //   });
    // }
  }

  componentWillUnmount() {
    const {
      navigator: { previousAction },
      river: { id },
      isInsideContainer,
      screenDidDisappear,
    } = this.props;
    if (previousAction === "POP") {
      riverFocusManager.clearScreenData({
        screenId: id,
        isInsideContainer: isInsideContainer,
      });
    }
    screenDidDisappear({ id, isInsideContainer });
  }
  screenFocusableGroupId() {
    const {
      river: { id },
      isInsideContainer,
    } = this.props;
    return riverFocusManager.screenFocusableGroupId({
      screenId: id,
      isInsideContainer,
    });
  }

  mainFocusItemUpdater({ groupId, itemId, componentId, itemIndex }) {
    this.updateScreenFocusableData({
      groupId,
      itemId,
      componentId,
      itemIndex,
    });
  }

  /**
   * Updated main scroll view content offset
   *
   * This function called from ScreenScrollingContext to
   * change main scroll view content offset based on inneer components
   *
   * @param {Object} event          React event of focusable item.
   * @param {Number} extraOffset    Extra offset that component may pass, can be used in
   * case component has header or some inner view.
   * @param {Object} containerFrame Full frame of the container of caller component .
   *
   */
  mainOffsetUpdater(
    event,
    extraOffset,
    containerFrame,
    groupId,
    itemId,
    componentId,
    itemIndex
  ) {
    const cellTag = event.tag;
    const nativeTag = findNodeHandle(this.scrollViewRef);
    UIManager.measureLayout(
      cellTag,
      nativeTag,
      e => {
        console.error(e); // eslint-disable-line no-console
      },
      (x, y, w, h) => {
        if (this.contentSize.height > this.viewFrame.height) {
          if (y + extraOffset + h > this.contentSize.height) {
            const newOffset = this.contentSize.height - this.viewFrame.height;
            this.updateScreenFocusableData({
              groupId,
              itemId,
              contentOffsetY: newOffset,
              componentId,
              itemIndex,
            });
            this.scrollViewRef &&
              this.scrollViewRef.scrollTo({
                y: newOffset,
                animated: true,
              });
          } else {
            // This is added because if iOS FocusGuide will not see focusable view it will select nav bar.
            // We're setting scrollingEnabled = false to remove auto content update by focus engine.
            // this prevents animation jumps in the scrollview when the offset changes
            const extraOffsetToGetPrevVisibleFocus = 1;
            const newOffset =
              y - extraOffsetToGetPrevVisibleFocus - extraOffset;
            this.updateScreenFocusableData({
              groupId,
              itemId,
              contentOffsetY: newOffset,
              componentId,
              itemIndex,
            });
            this.scrollViewRef &&
              this.scrollViewRef.scrollTo({
                y: newOffset,
                animated: true,
              });
          }
        } else {
          this.updateScreenFocusableData({ groupId, itemId, componentId });
        }
      }
    );
  }

  updateScreenFocusableData({
    groupId,
    itemId,
    contentOffsetY = 0,
    componentId,
    itemIndex,
  }) {
    if (this.screenPresented === true) {
      riverFocusManager.setScreenFocusableData({
        groupId,
        itemId,
        contentOffsetY,
        screenFocusableGroupId: this.screenFocusableGroupId(),
        componentId,
        itemIndex,
      });
    }
  }

  renderComponents(feed = null) {
    const {
      river: { id, ui_components },
      isInsideContainer,
      screenData,
    } = this.props;

    this.currentScreenTitle =
      (feed && feed.title) || (screenData && screenData.title) || null;
    this.currentScreenSummary = (feed && feed.summary) || null;

    return (
      <ScrollView
        scrollEnabled={false}
        onContentSizeChange={this.onContentSizeChange}
        onLayout={this.onLayout}
        ref={view => {
          this.scrollViewRef = view;
        }}
      >
        <ComponentsMap
          screenFocusableGroupId={this.screenFocusableGroupId()}
          componentDidFinishAnimation={this.componentDidFinishAnimation}
          isScreenWrappedInContainer={isInsideContainer}
          screenId={id}
          feed={feed}
          riverComponents={ui_components}
          title={this.currentScreenTitle}
          summary={this.currentScreenSummary}
        />
      </ScrollView>
    );
  }

  renderScreenPlugin() {
    const { river } = this.props;
    const { type, id } = river;

    return (
      <ScreenResolver screenType={type} screenId={id} screenData={river} />
    );
  }

  render() {
    const { feedUrl, screenData, river } = this.props;
    const { type } = river;

    if (type !== "general_content") {
      return this.renderScreenPlugin();
    }

    const connectedFeedURL = R.path(["content", "src"], screenData);
    const _feedUrl = feedUrl || connectedFeedURL;

    return (
      <FocusableGroup
        id={this.screenFocusableGroupId()}
        style={riverStyles.container}
      >
        {!_feedUrl ? (
          this.renderComponents()
        ) : (
          <FeedLoader feedUrl={_feedUrl}>
            {feed => this.renderComponents(feed)}
          </FeedLoader>
        )}
      </FocusableGroup>
    );
  }

  componentDidFinishAnimation() {
    this.screenPresented = true;
    const {
      navigator: { previousAction },
    } = this.props;
    riverFocusManager.focusOnSelectedItem({
      screenFocusableGroupId: this.screenFocusableGroupId(),
      screenFocusedOnItem: this.props.screenFocusedOnItem,
      previousAction,
    });
  }
}
