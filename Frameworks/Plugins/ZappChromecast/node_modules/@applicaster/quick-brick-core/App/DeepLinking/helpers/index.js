// @flow
import * as R from "ramda";
import url from "url";
import atob from "atob";
import { isScreenPlayable } from "@applicaster/zapp-react-native-utils/navigationUtils/itemTypes";

type UrlSchemeParams = { [string]: any };

type UrlScheme = {
  host: ?string,
  path: ?string,
  scheme: ?string,
  query: ?UrlSchemeParams,
  fragment: ?string,
};
/**
 * parses a url string into an object, providing values for the different parts of the url
 * @param {String} urlString to parse
 * @returns {Object} url object - see UrlScheme type above
 */
export function parseUrl(urlString: string): UrlScheme {
  const { protocol, hostname: host, pathname: path, query, hash } = url.parse(
    urlString,
    true,
    true
  );

  const { data_source, entry_id } = query;
  const scheme = R.replace(":", "", protocol || "");
  const fragment = R.replace("#", "", hash || "");

  if (query.data_source) {
    query.data_source = decodeUrl(data_source);
  }

  if (query.entry_id) {
    query.entry_id = decodeUrl(entry_id);
  }

  return {
    scheme,
    host,
    path,
    query,
    fragment,
  };
}

// regex to test if a string is a valid base 64 encoded string
// https://stackoverflow.com/questions/8571501/how-to-check-whether-a-string-is-base64-encoded-or-not
const isBase64 = R.test(
  /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/
);

/**
 * tries to decode a url encoded to a base64 string.
 * returns the original string if decoding is not possible or fails
 * @param {String} urlString
 * @returns {String}
 */
export function decodeUrl(urlString: string): string {
  if (!isBase64(urlString)) {
    return urlString;
  }

  try {
    return atob(decodeURIComponent(urlString));
  } catch (error) {
    console.warn("couldn't decode url", { error }); // eslint-disable-line no-console
    return urlString;
  }
}

export function handlePresentNavigation({ data = null, navigator, rivers }) {
  if (R.isNil(data)) {
    goToHome({ navigator, rivers });
  } else {
    navigateTo({ data, navigator });
  }
}

export function findRiver({ screen_id, rivers }) {
  return rivers[screen_id] || null;
}

function getHomeRiver({ rivers }) {
  return R.compose(R.find(R.propEq("home", true)), R.values)(rivers);
}

function goToHome({ navigator, rivers }) {
  const homeRiver = getHomeRiver({ rivers });
  navigator.replace(homeRiver);
}

function navigateTo({ data, navigator }) {
  if (isScreenPlayable(navigator.currentRoute)) {
    navigator.goBack(); // TODO: check it on start
  }

  navigator.push(data);
}
