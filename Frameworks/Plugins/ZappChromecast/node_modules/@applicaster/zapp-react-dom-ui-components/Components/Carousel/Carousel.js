// @flow
import * as React from "react";
import * as R from "ramda";

import { shiftArray } from "@applicaster/zapp-react-native-utils/arrayUtils";

import { Cell } from "../Cell";
import { Header } from "../Header";

type Props = {
  items: [{}],
  componentId: string,
  component: {},
  CellRenderer: React.componentType<{ item: Object, state: string }>,
  styles: {},
  shouldScrollHorizontally: ?(?[any]) => boolean,
  shouldScrollVertically: ?(?[any]) => boolean,
  riverOffsetUpdater: (string, number, ?boolean) => void,
  offsetUpdater: (string, number, ?boolean) => void,
  id: string,
  navigator: {},
  verticalAnimationOffset: ?number,
  horizontalAnimationOffset: ?number,
  header: {
    title: string,
    visible: boolean,
    data: {},
    style: ?{},
  },
};

type State = {
  items: [
    {
      id: string,
      render: () => React.Element<any>,
    }
  ],
};

export class CarouselComponent extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);

    const { items } = this.props;

    this.onFocus = this.onFocus.bind(this);
    this.shiftArray = this.shiftArray.bind(this);
    this.renderItem = this.renderItem.bind(this);
    this.willReceiveFocus = this.willReceiveFocus.bind(this);

    if (items.length === 2) {
      // if the carousel has only 2 items, we duplicate the entries in order to make sure
      // the cyclic animations are working, and the hero behaves as expected
      items.push(...items);
    }

    this.state = { items: shiftArray(-1)(items.map(this.renderItem)) };
  }

  onFocus(focusable, direction) {
    const {
      shouldScrollHorizontally,
      shouldScrollVertically,
      riverOffsetUpdater,
      offsetUpdater,
      verticalAnimationOffset,
      horizontalAnimationOffset,
    } = this.props;

    const verticalOffset = verticalAnimationOffset || 0;
    const horizontalOffset = horizontalAnimationOffset || 0;

    if (shouldScrollVertically && shouldScrollVertically()) {
      riverOffsetUpdater("vertical", verticalOffset - focusable.getRect().top);
    }

    if (shouldScrollHorizontally && shouldScrollHorizontally(focusable)) {
      offsetUpdater("horizontal", horizontalOffset - focusable.getRect().left);
    }
  }

  willReceiveFocus(focusable, direction) {
    if (direction && direction.isHorizontal) {
      const { offsetUpdater } = this.props;
      const { width } = focusable.getRect();
      const offset = direction.value === "right" ? 1 : -1;

      offsetUpdater("horizontal", offset * width, false);
      this.shiftArray(offset);
    }
  }

  shiftArray(offset: number) {
    this.setState(R.evolve({ items: shiftArray(offset) }));
  }

  renderItem(item: {}, index: number) {
    const {
      componentId,
      component,
      CellRenderer,
      shouldScrollHorizontally,
      navigator,
      shouldScrollVertically,
    } = this.props;

    const hasPreferredFocus = index === 0;

    return {
      id: item.id,
      render: () => (
        <Cell
          key={index}
          index={index}
          componentId={componentId}
          component={component}
          CellRenderer={CellRenderer}
          item={item}
          shouldScrollHorizontally={shouldScrollHorizontally}
          shouldScrollVertically={shouldScrollVertically}
          onFocus={this.onFocus}
          willReceiveFocus={this.willReceiveFocus}
          hasPreferredFocus={hasPreferredFocus}
          navigator={navigator}
        />
      ),
    };
  }

  render() {
    const { styles, header } = this.props;
    const { items } = this.state;

    return (
      <div>
        <Header {...header} />
        <div style={styles}>{items.map(item => item.render())}</div>
      </div>
    );
  }
}
