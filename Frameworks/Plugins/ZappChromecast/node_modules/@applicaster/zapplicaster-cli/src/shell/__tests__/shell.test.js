const { curlFile, curlMultipleFiles, unzip } = require("../index");
const R = require("ramda");
const logger = require("../../logger");

jest.mock("shelljs");
const shelljs = require("shelljs");

const loggerSpy = jest.spyOn(logger, "log");
const loggerWarnSpy = jest.spyOn(logger, "warn").mockImplementation(jest.fn());

function clearAllMocks() {
  loggerSpy.mockClear();
  loggerWarnSpy.mockClear();
  shelljs.exec.mockClear();
  shelljs.mv.mockClear();
  shelljs.rm.mockClear();
}

// silences the console for the tests
jest.spyOn(console, "log").mockImplementation(() => ({}));

describe("curlFile", () => {
  const fileUrl = "http://host.com/file.ext";
  const destinationPath = "/path/to/files";

  afterEach(() => {
    clearAllMocks();
  });

  it("invokes the logger", () => {
    curlFile(fileUrl, destinationPath);

    expect(loggerSpy).toHaveBeenCalledWith(`downloading ${fileUrl} with cURL`);
  });

  it("invokes the cURL command in the shell", () => {
    curlFile(fileUrl, destinationPath);

    expect(shelljs.exec).toHaveBeenCalledWith(`curl -O ${fileUrl}`);
  });

  it("moves the file to the destination", () => {
    curlFile(fileUrl, destinationPath);
    const fileName = R.compose(
      R.last,
      R.split("/")
    )(fileUrl);

    expect(shelljs.mv).toHaveBeenCalledWith(fileName, destinationPath);
  });

  it("throws an error if the command fails", () => {
    expect(() =>
      curlFile("FAILING_COMMAND", destinationPath)
    ).toThrowErrorMatchingSnapshot();
  });
});

describe("curlMultipleFiles", () => {
  const folder = "https://host.com/folder";
  const files = ["foo.ext", "bar.ext"];
  const destinationPath = "path/to/files";

  afterEach(() => {
    clearAllMocks();
  });

  it("invokes the logger", () => {
    curlMultipleFiles(folder, files, destinationPath);

    expect(loggerSpy).toHaveBeenCalledWith(
      `downloading ${folder}/{${files.join(",")}} with cURL`
    );
  });

  it("invokes the cURL command in the shell", () => {
    curlMultipleFiles(folder, files, destinationPath);

    expect(shelljs.exec).toHaveBeenCalledWith(
      `curl -O --remote-name-all ${folder}/{${files.join(",")}}`
    );
  });

  it("moves the files to the destination", () => {
    curlMultipleFiles(folder, files, destinationPath);
    expect(shelljs.mv).toHaveBeenCalledTimes(files.length);
    expect(shelljs.mv.mock.calls).toMatchSnapshot();
  });

  it("throws an error if something wrong happens", () => {
    files.push("FAILING_COMMAND");

    expect(() =>
      curlMultipleFiles(folder, files, destinationPath)
    ).toThrowErrorMatchingSnapshot();
  });
});

describe("unzip", () => {
  const file = "path/to/file.zip";
  const destination = "destination/path";

  afterEach(() => {
    clearAllMocks();
  });

  it("invokes the logger", () => {
    unzip(file, destination);
    expect(loggerSpy).toHaveBeenCalledWith(`unpacking ${file}`);
  });

  it("runs the unzip command in the shell", () => {
    unzip(file, destination);
    expect(shelljs.exec).toHaveBeenCalledWith(
      `unzip -o ${file} -d ${destination}`
    );
  });

  it("removes the zip", () => {
    unzip(file, destination);
    expect(shelljs.rm).toHaveBeenCalledWith(file);
  });

  it("recovers errors and warns the user when unzipping fails", () => {
    expect(() => unzip("FAILING_COMMAND", destination)).not.toThrow();
    unzip("FAILING_COMMAND", destination);
    expect(shelljs.rm).not.toHaveBeenCalled();
    expect(logger.warn).toHaveBeenCalledWith(
      "An error occured while unzipping assets - you may have to do this manually"
    );
  });
});
