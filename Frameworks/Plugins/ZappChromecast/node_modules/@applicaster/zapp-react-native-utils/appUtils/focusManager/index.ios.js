import { NativeModules } from "react-native";
import * as R from "ramda";

const { FocusableManagerModule } = NativeModules;

/**
 * Request native tvOS focus engine to focus on requested item immidiatelly
 *
 * @param {String}  groupId      Id of the selected item
 * @param {String}  itemId      Id of the selected group
 * @param {function} callback Callback from native side that focusable item was focused
 *
 */
export function forceFocusableFocus(groupId, itemId, callback = null) {
  FocusableManagerModule.forceFocus(groupId, itemId, () => {
    callback && callback();
  });
}

/**
 * Request native tvOS focus engine to set this item as preffered to focus without forceing to focus on it
 *
 * @param {String}  groupId      Id of the selected item
 * @param {String}  itemId      Id of the selected group
 *
 */
export function setPreferredFocus(groupId, itemId) {
  FocusableManagerModule.setPreferredFocus(groupId, itemId);
}

export const focusManager = (function () {
  const focusables = {};
  const focusableGroups = {};
  let currentFocus = null;

  /**
   * Make focus on focusable item.
   *
   * @param {Object}  focusableItem Item to focus
   * @param {function} callback Callback from native side that focusable item was focused
   *
   */
  function forceFocusOnItem({ focusableItem, callback }) {
    if (R.compose(R.not, R.isNil)(focusableItem)) {
      focusableItem.willReceiveFocus(null);
      setFocus(focusableItem.props.id, null, {}, callback);
    }
  }

  /**
   * Try to focus on item with id
   *
   * @param {String}  itemId Unique item id to focus.
   * @param {function} callback Callback from native side that focusable item was focused
   *
   */
  function forceFocusOnFocusable({ itemId, callback }) {
    if (R.isNil(itemId)) {
      return;
    }

    forceFocusOnItem({ focusableItem: focusables[itemId], callback });
  }

  /**
   * Try to focus on first item inside subchildren of the group wherre first focusable item has initialFocus = true.
   *
   * @param {String}  groupId Unique group id where item will  be searched
   * @param {function} callback Callback from native side that focusable item was focused
   *
   */
  function forceFocusOnInitialFocusable({ groupId, callback }) {
    if (R.isNil(groupId)) {
      return;
    }
    const focusableItem = findInitiallyFocusedItemInGroup({
      groupId,
    });

    forceFocusOnItem({ focusableItem, callback });
  }

  /**
   * Find first item inside subchildren of the group wherre first focusable item,
   * has initialFocus = true in specific group.
   *
   * @param {String}  groupId Unique group id where item will  be searched
   * @param {function} callback Callback from native side that focusable item was focused
   *
   */
  function findInitiallyFocusedItemInGroup({ groupId }) {
    if (R.isNil(groupId)) {
      return;
    }
    // Define focusables by groupId
    const focusableByGroups = R.compose(
      R.groupBy(R.prop("groupId")),
      R.values
    )(focusables);

    // Try to find intial focusable item in a group
    const findFocusableInGroup = R.curry((predicate, group) =>
      R.compose(
        (focusables) =>
          focusables
            ? R.find((focusable) => predicate(focusable), focusables)
            : null,
        (group) => {
          return R.prop(group.id, focusableByGroups);
        }
      )(group)
    );

    // Predicate that matches search result
    const predicate = (focusable) => {
      return focusable.props.initialFocus === true;
    };

    let searchedInitialFocusableItem = findFocusableInGroup(predicate, groupId);
    // In case can not find current group try to search in inner group first matchable item
    if (!searchedInitialFocusableItem) {
      // Search groups that has parrent as current searcheble group
      const childGroupArray = R.compose(
        R.values,
        R.filter((group) => group.props.parentFocusableGroupId === groupId)
      )(focusableGroups);

      // Try recursivelly find initially focused item in all groups one by one
      R.find((group) => {
        findInitiallyFocusedItemInGroup({
          focusableGroup: group,
        });
      })(childGroupArray);
    }
    return searchedInitialFocusableItem;
  }

  function registerGroup(id, component) {
    focusableGroups[id] = component;
    component.onRegister(component);
    return component;
  }

  function registerItem(id, component) {
    focusables[id] = component;
    component.onRegister(component);
    return component;
  }

  function unregisterGroup(id) {
    const focusableGroup = focusableGroups[id];
    focusableGroup?.onUnregister(focusableGroup);
    delete focusableGroups[id];
  }

  function unregisterItem(id) {
    const focusableItem = focusables[id];
    if (id === currentFocus) {
      currentFocus = null;
    }

    if (focusableItem) {
      focusableItem.onUnregister(focusableItem);
    }

    delete focusables[id];
  }

  function register({ id, component }) {
    const { isGroup = false } = component;
    return isGroup ? registerGroup(id, component) : registerItem(id, component);
  }

  function unregister(id, { group = false } = {}) {
    group ? unregisterGroup(id) : unregisterItem(id);
  }

  function setFocus(
    id,
    direction,
    { groupFocusedChanged = false } = {},
    callback
  ) {
    blur(direction);
    currentFocus = id;

    const currentGroup = getCurrentGroup();
    if (groupFocusedChanged && currentGroup) {
      currentGroup.hasLostFocus(currentGroup, direction);
    }

    focus(direction, callback);
  }

  function getCurrentFocus() {
    return focusables[currentFocus] || null;
  }

  function getCurrentGroup() {
    return getGroupById(R.path(["props", "groupId"], getCurrentFocus()));
  }

  function getGroupById(groupId) {
    return focusableGroups[groupId] || focusables[groupId];
  }

  function blur(direction) {
    const currentFocusable = getCurrentFocus();
    if (currentFocusable && !currentFocusable.isGroup) {
      currentFocusable.blur(direction);
      currentFocusable.hasLostFocus(getCurrentFocus(), direction);
    }
  }

  function focus(direction, callback) {
    const currentFocusable = getCurrentFocus();
    if (currentFocusable && !currentFocusable.isGroup) {
      currentFocusable.setFocus(direction, callback);
      currentFocusable.hasReceivedFocus(getCurrentFocus(), direction);
    }
  }

  function press() {
    getCurrentFocus().press(null);
  }

  return {
    register,
    unregister,
    getCurrentFocus,
    getGroupById,
    setFocus,
    press,
    forceFocusOnFocusable,
    forceFocusOnInitialFocusable,
  };
})();
