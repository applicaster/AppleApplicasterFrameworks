const processSpy = jest.spyOn(process, "exit").mockImplementation(jest.fn());
const consoleSpy = jest.spyOn(console, "error").mockImplementation(jest.fn());

describe("when env is not test", () => {
  const ENV = process.env;

  beforeEach(() => {
    jest.resetModules();
    process.env = { ...ENV, NODE_ENV: "NOT_TEST" };
  });

  afterEach(() => {
    process.env = ENV;
    processSpy.mockClear();
    consoleSpy.mockClear();
  });

  it("exits the process when logger.error is called", () => {
    const logger = require("../index");
    const error = new Error("error");
    error.stack = "stack";

    logger.error("error message", error);

    expect(processSpy).toHaveBeenCalledWith(1);
    expect(consoleSpy.mock.calls).toMatchSnapshot();
  });
});

describe("when env is not test and process exit code is defined", () => {
  const ENV = process.env;
  const EXIT_CODE = 2;

  beforeEach(() => {
    jest.resetModules();
    process.env = { ...ENV, NODE_ENV: "NOT_TEST" };
    process.exitCode = EXIT_CODE;
  });

  afterEach(() => {
    process.env = ENV;
    processSpy.mockClear();
    consoleSpy.mockClear();
    delete process.exitCode;
  });

  it("exits the process when logger.error is called and uses the process exit code", () => {
    const logger = require("../index");
    const error = new Error("error");

    logger.error("error message", error);

    expect(processSpy).toHaveBeenCalledWith(EXIT_CODE);
  });
});

describe("when error passed has no stack", () => {
  afterEach(() => {
    consoleSpy.mockClear();
  });

  it("doesn't print the stack", () => {
    const logger = require("../index");

    logger.error("error message", "error without a stack");
    expect(consoleSpy.mock.calls).toMatchSnapshot();
  });
});
