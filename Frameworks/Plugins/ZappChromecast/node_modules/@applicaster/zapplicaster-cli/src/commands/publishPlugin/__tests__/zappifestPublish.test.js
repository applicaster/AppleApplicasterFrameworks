const getConfig = (config = {}) => ({
  platforms: ["android", "ios"],
  pluginPath: "plugins/my-plugn",
  dryRun: false,
  zappOwnerAccountId: "A1234",
  ...config,
});

jest.mock("path", () => ({
  resolve: jest.fn((path, platformpath) => {
    if (path.includes("resolve_error")) {
      throw new Error("cannot resolve manifest");
    }

    if (path.includes("zappifest_error")) {
      /* eslint-disable-next-line no-path-concat */
      return __dirname + "/zappifest_error.json";
    }

    /* eslint-disable-next-line no-path-concat */
    return __dirname + "/" + platformpath;
  }),
}));

jest.mock("../../../shell", () => ({
  runInShellAsync: jest.fn(command => {
    return command.includes("zappifest_error")
      ? Promise.reject(new Error("zappifest failed"))
      : Promise.resolve(true);
  }),
}));

jest.mock("../../../logger", () => ({
  log: jest.fn(),
}));

const { zappifestPublish } = require("../zappifestPublish");
const { runInShellAsync } = require("../../../shell");
const logger = require("../../../logger");
const { inspect } = require("util");

function clearMocks() {
  logger.log.mockClear();
  runInShellAsync.mockClear();
}

describe("publish zappifests", () => {
  beforeEach(clearMocks);

  it("runs the zappifest command for all platforms", async () => {
    const configuration = getConfig();

    const expectedResult = new Array(configuration.platforms.length)
      .fill()
      .map(() => true);

    expect(await zappifestPublish(configuration)).toEqual(expectedResult);

    expect(runInShellAsync).toHaveBeenCalledTimes(
      configuration.platforms.length
    );

    configuration.platforms.forEach((val, index) => {
      expect(runInShellAsync).toHaveBeenNthCalledWith(
        index + 1,
        `zappifest publish --manifest ${__dirname}/manifests/${val}.json --account A1234`
      );
    });
  });

  it("only logs in the console when running with dry run flag", async () => {
    const configuration = getConfig({ dryRun: true });

    const expectedResult = new Array(configuration.platforms.length)
      .fill()
      .map(() => true);

    expect(await zappifestPublish(configuration)).toEqual(expectedResult);
    expect(runInShellAsync).not.toHaveBeenCalled();

    expect(logger.log).toHaveBeenCalledTimes(
      1 + configuration.platforms.length * 2
    );

    expect(logger.log).toHaveBeenNthCalledWith(
      1,
      "Running with --dry-run option - not actually pushing to zapp"
    );

    configuration.platforms.forEach((val, index) => {
      expect(logger.log).toHaveBeenNthCalledWith(
        index * 2 + 2,
        expect.stringMatching(
          /running zappifest publish --manifest .*(ios|android)\.json/
        )
      );

      expect(logger.log).toHaveBeenNthCalledWith(
        index * 2 + 3,
        `with manifest: ${inspect(require(`./manifests/${val}.json`))}`
      );
    });
  });

  it("it throws if a manifest cannot be found", async () => {
    const configuration = getConfig({ pluginPath: "resolve_error" });
    expect(zappifestPublish(configuration)).rejects.toMatchSnapshot();
  });

  it("it throws if the zappifest command fails", async () => {
    const configuration = getConfig({ pluginPath: "zappifest_error" });
    expect(zappifestPublish(configuration)).rejects.toMatchSnapshot();
  });
});
