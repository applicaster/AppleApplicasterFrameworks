const {
  writeJsonToFile,
  copyFolder,
  copyFiles,
  destinationFileNameMapper,
} = require("../index");

jest.mock("fs", () => require("../../../test_helpers/fsMock"));
const fs = require("fs");

jest.mock("../../logger", () => ({
  warn: jest.fn(),
}));

const logger = require("../../logger");

describe("writeJsonTofile", () => {
  it("writes a json to a file", async () => {
    const json = { foo: "bar" };
    const filePath = "someFile.json";

    await writeJsonToFile(filePath, json);

    expect(fs.writeFile).toHaveBeenCalledWith(
      filePath,
      JSON.stringify(json, null, 2),
      expect.any(Function)
    );
  });
});

describe("copyFiles", () => {
  const sourcePath = "some/source/path";
  const destinationPath = "some/destination/Path";

  beforeEach(() => {
    fs.__resetFiles();
    fs.writeFile("foo.json", { foo: "bar" }, jest.fn());
    fs.writeFile("bar.json", { bar: "baz" }, jest.fn());
    fs.writeFile("qux.json", { qux: 42 }, jest.fn());
    fs.copyFileSync.mockClear();
  });

  describe("when there is no package.json to copy", () => {
    it("copies the files", () => {
      copyFiles(sourcePath, ["foo.json", "bar.json"], destinationPath);
      expect(fs.copyFileSync).toHaveBeenCalledTimes(2);
      expect(fs.copyFileSync.mock.calls).toMatchSnapshot();
    });
  });

  describe("when destination path has package.json", () => {
    beforeEach(() => {
      fs.__addMockedFiles(`${destinationPath}/package.json`, "");
      logger.warn.mockClear();
    });

    afterEach(() => {
      logger.warn.mockClear();
      fs.__resetFiles();
    });

    it("overrides it", () => {
      const sourcePath = "some/source/path";
      const destinationPath = "some/destination/Path";

      copyFiles(sourcePath, ["foo.json", "package.json"], destinationPath);
      expect(fs.copyFileSync).toHaveBeenCalledTimes(2);

      expect(fs.copyFileSync).toHaveBeenCalledWith(
        `${sourcePath}/foo.json`,
        `${destinationPath}/foo.json`
      );
    });
  });

  describe("when destination path has no package.json", () => {
    it("doesn't skips the copy", () => {
      const sourcePath = "some/source/path";
      const destinationPath = "some/destination/Path";

      copyFiles(sourcePath, ["foo.json", "package.json"], destinationPath);
      expect(fs.copyFileSync).toHaveBeenCalledTimes(2);

      expect(fs.copyFileSync.mock.calls).toMatchSnapshot();
      expect(logger.warn).not.toHaveBeenCalled();
    });
  });

  afterAll(() => {
    fs.__resetFiles();
  });
});

describe("copyFolder", () => {
  beforeAll(() => {
    fs.__resetFiles();
    fs.writeFile("foo.json", { foo: "bar" }, jest.fn());
    fs.writeFile("bar.json", { bar: "baz" }, jest.fn());
  });

  beforeEach(() => {
    fs.copyFileSync.mockClear();
  });

  it("copies the file in the folder", async () => {
    const sourcePath = "some/source/path.json";
    const destinationPath = "some/destination/path.json";

    await copyFolder(sourcePath, destinationPath);

    expect(fs.readdir).toHaveBeenCalledWith(sourcePath, expect.any(Function));
    expect(fs.copyFileSync).toHaveBeenCalledTimes(2);
  });

  afterAll(() => {
    fs.__resetFiles();
  });
});

describe("destinationFileNameMapper", () => {
  it("doesn't transform other file names", () => {
    const input = "some/path/to/some/file.json";
    expect(destinationFileNameMapper(input)).toEqual(input);
  });

  it("transforms _package.json into package.json", () => {
    const input = "some/path/_package.json";
    expect(destinationFileNameMapper(input)).toEqual("some/path/package.json");
  });
});
