const R = require("ramda");
const webpack = require("webpack");
const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");

/**
 * As a rule of thumb, we don't want to transpile node_modules in a webpack project, since most web dependencies
 * are already transpiled, and that would take really long
 * However, some quick-brick packages, and a few dependencies are not transpiled to ES5 compliant javascript code
 * In order to allow the app to run in these conditions, they are removed from the node_modules exclusion rules for
 * the babel-loader
 * Modules others than our own should not be excluded ideally, unless no other option can be used
 */
// eslint-disable-next-line max-len
// const NODE_MODULES_EXCLUSIONS = /node_modules\/(?!(@applicaster\/(quick-brick-*|zapp-react-*)))|(?!(query-string))/;
const NODE_MODULES_EXCLUSIONS = [
  /@applicaster\/quick-brick-*/,
  /@applicaster\/zapp-react-*/,
  /query-string/,
  /strict-uri-encode/,
  /split-on-first/,
];


function getAlias() {

  if (process.env.NODE_ENV !== "development") {
    return {};
  }
  
  try {
    return require("../package.json").applicaster.moduleMap;
  } catch (e) {
    // eslint-disable-next-line no-console
    console.warn(e);
    return {}
  }
}
const resolveAlias = getAlias();

//  "postinstall": "npm install babel-cli@6.26.0 cross-env@5.0.5 webpack@3.6.0",
// NODE_ENV=development
/**
 * Development webpack config designed to be loaded by express development server
 */
module.exports = {
  /**
   * The scripts in entry are combined in order to create our bundle
   */

  /**
   * Output contains detailed information about the bundle.js
   * In this case, bundle.js is never created but server by webpack-dev-middleware in ./server
   */
  output: {
    path: path.resolve(__dirname, "./public"),
    /**
     * Public path is necessary for webpack HMR to reload correctly when on a path other than '/'
     */
    publicPath: "./",
    filename: "[hash:10].bundle.js",
  },
  plugins: [
    /**
     * Causes the relative path of the module to be used in HMR
     * Recommended by docs for development configurations: https://webpack.js.org/plugins/named-modules-plugin/
     */
    new webpack.NamedModulesPlugin(),
    /**
     * Defines the env as 'development', which triggers different behaviors in some scripts
     * To see more, search project for 'development'
     */

    new HtmlWebpackPlugin({
      title: "<%= configuration.buildParams.app_name %>",
      appMountId: "zapp_app_container",
      template: "./index.html",
    }),
  ],
  /**
   * Resolve allows files to be imported without specifying an extension as long as they match one specified, i.e.
   * import component from './component'
   */
  resolve: {
    extensions: [".web.js", ".js", ".json", ".jsx", ".ts", ".tsx", ".web.ts", ".web.tsx"],
    alias: {
      webworkify: "webworkify-webpack2",
      "react-native$": "react-native-web",
      "react-router-native$": "react-router-dom",
      ...resolveAlias,
    },
  },
  module: {
    rules: [
      {
        test: /.(ts|tsx|web.ts|web.tsx|js|jsx|web.js|web.jsx)$/,
        loader: "babel-loader",
        exclude: moduleName =>
          R.test(/node_modules/, moduleName) &&
          R.none(R.test(R.__, moduleName), NODE_MODULES_EXCLUSIONS),
        options: {
          presets: [
            [
              "@applicaster/quick-brick",
              { env: { targets: { chrome: "38" } }, platform: "web" },
            ],
          ],
        },
      },
      {
        test: /\.css$/,
        loader: "style-loader!css-loader",
      },
      {
        test: /\.mp4$/,
        loader: "url-loader?limit=10000&mimetype=video/mp4",
      },
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: [
          {
            loader: "file-loader",
            options: {
              name: "[name].[ext]",
              outputPath: "assets/<%= configuration.platform %>/",
            },
          },
        ],
      },
      {
        test: /\.(woff(2)?|ttf|eot|svg)(\?v=\d+\.\d+\.\d+)?$/,
        use: [
          {
            loader: "file-loader",
            options: {
              name: "[name].[ext]",
              outputPath: "fonts/",
            },
          },
        ],
      },
    ],
  },
};
