// @flow
import * as React from "react";
import * as R from "ramda";
import { StyleSheet, View } from "react-native";
import SnapCarousel from "react-native-snap-carousel";

import { useNavigation } from "@applicaster/zapp-react-native-utils/reactHooks/navigation";
import { Focusable } from "@applicaster/zapp-react-native-ui-components/Components/Focusable";
import { Cell } from "../Cell";

import {
  useInitialFocus,
  useFocusManager,
} from "@applicaster/zapp-react-native-utils/focusManager";

type Props = {
  data: [{ id: string | number }],
  focused: boolean,
  keyExtractor: (any) => string,
  parentFocus: {},
  nextFocusUp: React.Ref,
  nextFocusDown: React.Ref,
  component: { id: string | number, data: { target: string } },
  header: { title: string, visible: boolean },
  CellRenderer: React.Node,
};

const carouselStyles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: "row",
  },
});

export function Carousel(props: Props) {
  const {
    data,
    focused,
    nextFocusUp,
    nextFocusDown,
    component,
    header,
    CellRenderer,
  } = props;

  const { isFocused } = useFocusManager();
  const carouselId = `carousel-focusable${component.id}`;
  const carouselRef = React.useRef(null);
  const [activeId, setActiveId] = React.useState(data[0].id);
  const [activeIndex, setActiveIndex] = React.useState(0);
  const carouselFocusable = React.useRef(null);
  const navigator = useNavigation();

  useInitialFocus(focused, carouselFocusable);

  const moveFocus = (direction) => {
    if (direction === "right") {
      carouselRef.current.snapToNext(true);
    } else {
      carouselRef.current.snapToPrev(true);
    }
    /**
     * Reset focus before transitioning the list with two elements.
     * It's a solution to get rid of the glitch where 2 elements are focused at the same time
     * */
    data.length === 2 && setActiveId(null);
  };

  const navigateTo = (item) => {
    const targetScreen = component?.data?.target;
    const targetRoute = R.merge({ screen_type: targetScreen }, item);
    navigator.push(targetRoute);
  };

  const onFocus = (element, { direction, reset } = {}) => {
    if (direction && !reset) {
      moveFocus(direction);
    }
  };

  // eslint-disable-next-line react/prop-types
  const renderItem = ({
    item,
    index,
  }: {
    item: { id: string | number },
    index: number,
  }) => {
    const cellProps = {
      parentFocus: props.parentFocus,
      focused: isFocused(carouselId) && item.id === activeId,
      componentId: component?.id,
      item,
      CellRenderer,
      navigator,
      hasHeader: header.visible,
    };

    return (
      <View>
        <Cell {...cellProps} />
      </View>
    );
  };

  const onBeforeSnapToItem = React.useMemo((index) => {
    setActiveId(data?.[index]?.id);
    setActiveIndex(index);
  }, []);

  return (
    <View style={carouselStyles.container}>
      <Focusable
        onFocus={onFocus}
        onPress={() => navigateTo(data?.[activeIndex])}
        id={carouselId}
        ref={carouselFocusable}
        nextFocusRight={carouselFocusable}
        nextFocusLeft={carouselFocusable}
        nextFocusUp={nextFocusUp}
        nextFocusDown={nextFocusDown}
      >
        {() => null}
      </Focusable>

      <SnapCarousel
        shouldOptimizeUpdates
        initialNumToRender={4}
        onBeforeSnapToItem={onBeforeSnapToItem}
        ref={carouselRef}
        data={data}
        horizontal
        renderItem={renderItem}
        itemWidth={842}
        sliderWidth={1920}
        loop
        inactiveSlideScale={1}
        inactiveSlideOpacity={1}
        scrollEnabled={false}
      />
    </View>
  );
}
