// @flow
import * as React from "react";
import * as R from "ramda";
import axios from "axios";
import { View, ActivityIndicator } from "react-native";
import { sessionStorage } from "@applicaster/zapp-react-native-bridge/ZappStorage/SessionStorage";
import { loadAppContextData } from "@applicaster/zapp-react-native-redux";
import { FeedLoader } from "@applicaster/zapp-react-native-ui-components/Components/FeedLoader";
import { getAppStylesColor } from "@applicaster/zapp-react-native-utils/stylesUtils";

import { parseUrl, findRiver, handlePresentNavigation } from "../helpers";

const URL_SCHEME_HANDLER_TYPES = {
  PRESENT: "present",
};

type Props = {
  url: String,
  navigator: any,
  rivers: {},
  onFinish: any,
  styles: {},
  setAppReady: () => {},
  setAppNotReady: () => {},
  dispatch: () => {},
};

type State = {
  urlToLoad: String,
  handlerFinishedTask: boolean,
  data: {},
  feedLoaderFinishedJob: ({}, {}) => {},
};

const containerStyles = {
  flex: 1,
  alignItems: "center",
  justifyContent: "center",
  backgroundColor: "rgba(0,0,0,1.0)",
  paddingTop: 500,
};

export class URLSchemeHandlerComponent extends React.PureComponent<
  Props,
  State
> {
  constructor(props: Props) {
    super(props);

    this.handlePresentUrlScheme = this.handlePresentUrlScheme.bind(this);
    this.handleUrlScheme = this.handleUrlScheme.bind(this);

    this.setCustomLayout = this.setCustomLayout.bind(this);
    this.buildCustomLayoutURLs = this.buildCustomLayoutURLs.bind(this);
    this.reloadApplicationWithCustomLayout = this.reloadApplicationWithCustomLayout.bind(
      this
    );

    this.state = {
      urlToLoad: null,
      handlerFinishedTask: false,
      data: null,
      feedLoaderFinishedJob: null,
    };
  }

  componentDidMount() {
    this.handleUrlScheme();
  }

  componentDidUpdate(prevProps) {
    const { handlerFinishedTask, data } = this.state;
    if (handlerFinishedTask) {
      const { navigator, rivers, onFinish } = this.props;
      onFinish && onFinish();

      handlePresentNavigation({ data, navigator, rivers });
    }
  }

  handleUrlScheme() {
    const { url } = this.props;
    if (!url) {
      this.setState({ handlerFinishedTask: true });
    }

    const { host, query = {} } = parseUrl(decodeURIComponent(url));

    if (host === URL_SCHEME_HANDLER_TYPES.PRESENT) {
      this.handlePresentUrlScheme(query);
    } else {
      this.setState({ handlerFinishedTask: true });
    }
  }

  async setCustomLayout({ rivers_configuration_id }) {
    const sessionData = await sessionStorage.getAllItems("applicaster.v2");
    const data = this.buildCustomLayoutURLs(
      sessionData,
      rivers_configuration_id
    );
    return this.reloadApplicationWithCustomLayout(data);
  }

  buildCustomLayoutURLs(data, rivers_configuration_id) {
    const {
      accountsAccountId,
      bundleIdentifier,
      app_family_id,
      version_name,
      store,
    } = data;

    if (
      accountsAccountId &&
      bundleIdentifier &&
      version_name &&
      app_family_id &&
      store
    ) {
      const accountId = accountsAccountId.replace(/"/g, "");
      const appBundleIdentifier = bundleIdentifier.replace(/"/g, "");
      const versionName = version_name.replace(/"/g, "");
      const familyId = app_family_id.replace(/"/g, "");
      const storeKey = store.replace(/"/g, "");

      // eslint-disable-next-line max-len
      const riversUrl = `https://assets-secure.applicaster.com/zapp/accounts/${accountId}/apps/${appBundleIdentifier}/${storeKey}/${versionName}/rivers/${rivers_configuration_id}.json`;
      // eslint-disable-next-line max-len
      const cellStylesUrl = `https://assets-secure.applicaster.com/zapp/accounts/${accountId}/app_families/${familyId}/layouts/${rivers_configuration_id}/cell_styles.json`;

      return { riversUrl, cellStylesUrl };
    } else {
      throw new Error(
        `Can not create url to load new layout ${rivers_configuration_id}`
      );
    }
  }

  async reloadApplicationWithCustomLayout({ riversUrl, cellStylesUrl }) {
    const { setAppReady, setAppNotReady, dispatch } = this.props;
    setAppNotReady();
    const { data: rivers } = await axios.get(riversUrl);
    const { data: cellStyles } = await axios.get(cellStylesUrl);
    loadAppContextData(dispatch, { cellStyles, rivers });
    setAppReady();
    this.setState({ handlerFinishedTask: true });
  }

  handlePresentUrlScheme({
    screen_id = null,
    data_source,
    entry_id,
    rivers_configuration_id = null,
  }) {
    let isEntryUrlScheme = data_source && entry_id;
    const { rivers } = this.props;
    const screenRiver = findRiver({ screen_id, rivers });
    if (rivers_configuration_id) {
      this.setCustomLayout({ rivers_configuration_id });
    } else if (isEntryUrlScheme) {
      const feedLoaderFinishedJob = ({ feed, error }) => {
        if (!error && R.not(R.isNil(feed))) {
          const { entry } = feed;
          // eslint-disable-next-line eqeqeq
          const targetEntry = R.find(e => e.id == entry_id, entry);
          this.setState({ handlerFinishedTask: true, data: targetEntry });
        } else {
          this.setState({ handlerFinishedTask: true });
        }
      };

      this.setState({ urlToLoad: data_source, feedLoaderFinishedJob });
    } else if (R.not(R.isNil(screenRiver))) {
      // If data source exist creating new entry item with screen id, otherwise use screen without DS from rivers
      const data = data_source
        ? R.merge({ content: { src: data_source } }, { screen_type: screen_id })
        : screenRiver;
      this.setState({ handlerFinishedTask: true, data: data });
    } else {
      this.setState({ handlerFinishedTask: true });
    }
  }

  render() {
    const { styles } = this.props;
    const { urlToLoad, feedLoaderFinishedJob } = this.state;
    const appStyles = R.path(["universal"], styles);
    const color = getAppStylesColor("loading_spinner_color", appStyles);
    return (
      <View style={containerStyles}>
        <FeedLoader
          feedUrl={urlToLoad}
          onFeedLoaded={feed => {
            feedLoaderFinishedJob &&
              feedLoaderFinishedJob({ feed, error: null });
          }}
          onError={error =>
            feedLoaderFinishedJob &&
            feedLoaderFinishedJob({ feed: null, error })
          }
        >
          {() => <ActivityIndicator color={color} size="large" />}
        </FeedLoader>
      </View>
    );
  }
}
