const getConfig = (config = {}) => ({
  pluginPath: "plugin/my-plugin",
  platforms: ["android", "ios"],
  version: "1.5.0",
  dryRun: false,
  ...config,
});

jest.mock("../../../file", () => ({
  writeJsonToFile: jest.fn(path =>
    path.includes("write_error")
      ? Promise.reject(new Error("cannot write manifest"))
      : Promise.resolve(true)
  ),
}));

jest.mock("path", () => ({
  resolve: jest.fn(path => {
    if (path.includes("resolve_error")) {
      throw new Error("cannot resolve file");
    }
    /* eslint-disable-next-line no-path-concat */
    return __dirname + "/mock_manifest_config.js";
  }),
}));

jest.mock("../../../logger", () => ({
  log: jest.fn(),
}));

const { writeJsonToFile } = require("../../../file");
const { generateManifest } = require("../generateManifest");
const logger = require("../../../logger");
const mock_manifest_config = require("./mock_manifest_config");

function clearMocks() {
  logger.log.mockClear();
  writeJsonToFile.mockClear();
}

describe("generate manifest", () => {
  beforeEach(clearMocks);

  it("generates the manifest for all provided platforms", async () => {
    const configuration = getConfig();
    const expectedResult = new Array(configuration.platforms.length)
      .fill()
      .map(() => true);

    expect(await generateManifest(configuration)).toEqual(expectedResult);

    expect(writeJsonToFile).toHaveBeenCalledTimes(
      configuration.platforms.length
    );

    configuration.platforms.forEach((val, index) => {
      expect(writeJsonToFile).toHaveBeenNthCalledWith(
        index + 1,
        `${configuration.pluginPath}/manifests/${val}.json`,
        expect.objectContaining(
          mock_manifest_config({
            platform: val,
            version: configuration.version,
          })
        )
      );
    });

    expect(logger.log).not.toHaveBeenCalled();
  });

  it("logs and skips the file writing with the dry run flag", async () => {
    const configuration = getConfig({ dryRun: true });
    expect(await generateManifest(configuration)).toEqual([true, true]);
    expect(writeJsonToFile).not.toHaveBeenCalled();

    expect(logger.log).toHaveBeenCalledTimes(
      configuration.platforms.length * 2
    );
    expect(logger.log.mock.calls).toMatchSnapshot();
  });

  it("throws if the config file cannot be found", async () => {
    const configuration = getConfig({ pluginPath: "resolve_error" });

    expect(generateManifest(configuration)).rejects.toMatchSnapshot();
  });

  it("throws if the manifests cannot be written", async () => {
    const configuration = getConfig({ pluginPath: "write_error" });
    expect(generateManifest(configuration)).rejects.toMatchSnapshot();
  });
});
