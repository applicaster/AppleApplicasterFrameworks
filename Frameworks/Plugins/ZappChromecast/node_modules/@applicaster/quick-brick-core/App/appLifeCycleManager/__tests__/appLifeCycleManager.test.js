import * as React from "react";
import { View, Text } from "react-native";
import { create, act } from "react-test-renderer";

const Component = () => (
  <View>
    <Text>I'm a component</Text>
  </View>
);

const QuickBrickManager = {
  sendQuickBrickEvent: jest.fn(),
};

const LOADING_ERROR = new Error("loading failed");

const appLoader = jest.fn((_dispatch, _getState) => {
  if (_getState().shouldFail) return Promise.reject(LOADING_ERROR);
  return Promise.resolve();
});
const dispatch = jest.fn();

const state = {
  rivers: {},
  plugins: {},
  appSettings: { runtimeConfigurationUrls: { rivers: "http://rivers.url" } },
};

const QUICK_BRICK_READY_EVENT = "quickBrickReady";

jest.spyOn(console, "warn").mockImplementation(() => jest.fn());

const actions = {};

jest.mock("@applicaster/zapp-react-native-utils/reactHooks/actions", () => ({
  useActions: jest.fn(() => ({ actions })),
}));

const { appLifeCycleManager } = require("../index");

describe("appLifeCycleManager", () => {
  const decorator = appLifeCycleManager(appLoader, QuickBrickManager);

  beforeEach(() => {
    console.warn.mockClear(); // eslint-disable-line no-console
    appLoader.mockClear();
    QuickBrickManager.sendQuickBrickEvent.mockClear();
    dispatch.mockClear();
  });

  it("returns a function to decorate a component", () => {
    expect(decorator).toBeFunction();
  });

  it("runs the loaders, then sends quickBrickReady event", (done) => {
    const DecoratedComponent = decorator(Component);

    let wrapper;

    const testCallback = () => {
      expect(dispatch).toHaveBeenCalledWith(
        expect.objectContaining({ type: "SET_APP_READY" })
      );

      expect(QuickBrickManager.sendQuickBrickEvent).toHaveBeenCalledWith(
        QUICK_BRICK_READY_EVENT
      );
      done();
    };

    act(() => {
      wrapper = create(
        <DecoratedComponent
          dispatch={dispatch}
          {...state}
          testCallback={testCallback}
        />
      );
    });

    expect(wrapper.toJSON()).toMatchSnapshot();
    expect(appLoader).toHaveBeenCalled();
    expect.assertions(4);
  });

  it("sends the quickBrickReady event when a loader doesn't resolves", (done) => {
    const DecoratedComponent = decorator(Component);

    let wrapper;

    const testCallback = () => {
      expect(dispatch).toHaveBeenCalledWith(
        expect.objectContaining({ type: "SET_APP_READY" })
      );

      expect(QuickBrickManager.sendQuickBrickEvent).toHaveBeenCalledWith(
        QUICK_BRICK_READY_EVENT
      );

      expect(console.warn.mock.calls).toMatchSnapshot(); // eslint-disable-line no-console

      done();
    };

    act(() => {
      wrapper = create(
        <DecoratedComponent
          dispatch={dispatch}
          {...state}
          shouldFail
          testCallback={testCallback}
        />
      );
    });

    expect(wrapper.toJSON()).toMatchSnapshot();
    expect(appLoader).toHaveBeenCalled();
    expect.assertions(5);
  });
});
