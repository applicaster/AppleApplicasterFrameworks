import * as R from "ramda";

import { subscriber } from "@applicaster/zapp-react-native-utils/functionUtils";

import { Hook } from "./Hook";
import { HOOKS_TYPE, HOOKS_EVENTS } from "./constants";

/**
 * creates a hooksManager object to handle the hooks process.
 * it is based on the `subscriber` object
 * @param {object} options
 * @param {object} rivers map of rivers in the app
 * @param {object} targetScreen rivers which we are navigating to
 * @param {Array<object>} plugins array of plugins in the app
 * @returns {object} hooksManager object - see Navigator for usage
 */
export function HooksManager({ rivers, targetScreen, plugins }) {
  const hooksManager = subscriber();

  /**
   * attaches the screen data to the hook object if the hook
   * is a screen
   * @param {object} hook object
   * @returns {object} hook object with river data
   */
  function addScreenDataIfNeeded(hook) {
    const { screen_id } = hook;
    return R.mergeDeepLeft(hook, screen_id ? rivers[screen_id] : {});
  }

  /**
   * retrieves the hook module in the plugins and adds it to
   * the hook object if it exists,
   * @param {object} hook object
   * @returns {object} hook with plugin module
   */
  function getHookModule(hook) {
    return R.compose(
      R.merge(hook),
      R.pick(["module", "configuration"]),
      R.find(R.propEq("identifier", hook.identifier))
    )(plugins);
  }

  /**
   * returns a Hook object
   * curried function of the form (x, y) => z => Hook
   * @param {Array<object>} hooks list of sibling hooks to run in the same process
   * @param {object} manager hook manager to attach the hook to
   * @param {object} hook data from the rivers configuration
   * @returns {Hook} object
   */
  function constructHook(hooks, manager) {
    return function(hook) {
      return new Hook({ hook, hooks, manager });
    };
  }

  /**
   * orders the hooks according to their weight
   * @param {Array<object>} hooks to sort out
   * @returns {Array<object>} sorted hooks
   */
  function orderHooksByWeight(hooks) {
    return R.sortBy(R.compose(Number, R.prop("weight")), hooks);
  }

  /**
   * extracts the hooks form the target river. returns null if there are none
   * if there are hooks, gathers all required data and constructs a Hook object
   * @param {string} hookType see constants/HOOK_TYPES
   * @param {river} river to look for hooks to run
   * @returns {Array<Hooks>} list of hooks to go through
   */
  function getHooks(hookType, river) {
    if (riverIsPlayer(river)) {
      river.hooks = {
        [hookType]: injectPlayerHooks(hookType),
      };
    }

    const hooks = R.path(["hooks", hookType], river);

    if (!R.length(hooks)) {
      return null;
    }

    return R.compose(
      R.map(
        R.compose(
          constructHook(hooks, hooksManager),
          getHookModule,
          addScreenDataIfNeeded
        )
      ),
      orderHooksByWeight
    )(hooks);
  }

  /**
   * tells wether the current river is related to a player plugin, or the default player
   * @param {Object} river
   * @returns {boolean}
   */
  function riverIsPlayer(river) {
    const { screenType } = river;

    if (screenType) {
      return screenType === "playable";
    }

    const { type } = river;

    return R.compose(
      R.propEq("category", "player"),
      R.defaultTo({}),
      R.find(R.propEq("identifier", type))
    )(plugins);
  }

  /**
   * Injects the hooks for the player
   * @param {String} hookType type of hook
   * @returns {Array<Object>}
   */
  function injectPlayerHooks(hookType) {
    const applicaster2VodHook = {
      identifier: "applicaster2_vod_loader_hook",
      weight: 1,
    };

    const playerhooks = R.compose(
      R.sortBy(R.prop("weight")),
      R.concat([applicaster2VodHook]),
      R.map(plugin => ({
        identifier: plugin.identifier,
        weight: R.path(["module", "weight"], plugin) || 1,
      })),
      R.filter(R.pathEq(["module", "hasPlayerHook"], true))
    )(plugins);

    return playerhooks;
  }

  /**
   * creates the callback to invoke in order to proceed to the next hook
   * covers the scenarios of failure & flow blocking
   * @param {<Hook>} hookPlugin object for which the callback is built
   * @param {Array<Hook>} restOfHooks to run
   * @returns {function} callback function
   */
  function hookCallback(hookPlugin, restOfHooks) {
    /**
     * callback invoked after a hook is executed
     * @param {object} options
     * @param {boolean} success result of the hook execution
     * @param {?Error} error returned by the hook if relevant
     * @param {object} payload returned by the hook, to be passed along to the next hook
     */
    return function({ success, error, payload, callback }) {
      if (error) {
        hookPlugin.setStateAndNotify(HOOKS_EVENTS.ERROR, {
          error,
          hookPlugin,
          payload,
          callback,
        });
      }

      if (!success) {
        hookPlugin.setStateAndNotify(HOOKS_EVENTS.CANCEL, {
          hookPlugin,
          payload,
        });
      } else {
        hookPlugin.lastHook
          ? completeHook(hookPlugin, payload)
          : handleNextHook(restOfHooks, payload);
      }
    };
  }

  /**
   * flags a hook as succeeded, and pass hook data along
   * @param {Hook} hookPlugin
   * @param {object} payload returned by the hook plugin
   */
  function completeHook(hookPlugin, payload) {
    hookPlugin.setStateAndNotify(HOOKS_EVENTS.SUCCESS, {
      hookPlugin,
      payload,
    });
  }

  /**
   * presents a screen hook by triggering an event invoking the handler with
   * the appropriate route & payload
   * @param {Hook} hookPlugin to present
   * @param {object} payload to pass to the hook screen
   * @param {function} callback to invoke when the hook is succesful
   */
  hooksManager.presentScreenHook = function(hookPlugin, payload, callback) {
    const targetScreenRoute = `/hooks/${hookPlugin.screen_id}`;

    const routeData = {
      hookPlugin,
      payload,
      callback,
    };

    hookPlugin.setStateAndNotify(HOOKS_EVENTS.PRESENT_SCREEN_HOOK, {
      hookPlugin,
      route: targetScreenRoute,
      payload: routeData,
    });
  };

  /**
   * executes a headless hook
   * @param {Hook} hookPlugin to present
   * @param {object} payload to pass to the hook module
   * @param {function} callback to invoke when the hook is succesful
   */
  hooksManager.executeHook = function(hookPlugin, payload, callback) {
    try {
      hookPlugin.module.run(payload, callback, hookPlugin.configuration);
    } catch (e) {
      hookPlugin.setStateAndNotify(HOOKS_EVENTS.ERROR, {
        error: e,
        hookPlugin,
        payload,
      });
    }
  };

  /**
   * handles the next hook in the list of provided hooks, passing the payload along
   * @param {Array<Hook>} hooks to process
   * @param {object} payload to pass to the hook
   */
  function handleNextHook(hooks, payload) {
    const [hookPlugin, ...restOfHooks] = orderHooksByWeight(hooks);

    if (
      !hookPlugin.lastHook &&
      hookPlugin.shouldStartNextHook(R.head(restOfHooks))
    ) {
      handleNextHook(restOfHooks, payload);
    }

    hookPlugin.execute(payload, hookCallback(hookPlugin, restOfHooks));
  }

  /**
   * function exposes on the hooks manager to trigger the handling of the hooks for
   * the given targetScreen
   * @param {object} payload to send to the hooks
   * @returns {object} returns the hooks manager so methods can be chained
   */
  hooksManager.handleHooks = function(payload) {
    const preloadHooks = getHooks(HOOKS_TYPE.PRELOAD, targetScreen);
    if (preloadHooks) {
      handleNextHook(preloadHooks, payload);
    } else {
      hooksManager.invokeHandler(HOOKS_EVENTS.SUCCESS, {
        hookPlugin: { lastHook: true },
        payload,
      });
    }

    return hooksManager;
  };

  return hooksManager;
}
