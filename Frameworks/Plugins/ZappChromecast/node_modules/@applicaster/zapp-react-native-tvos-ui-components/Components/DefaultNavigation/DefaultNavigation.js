// @flow
import * as React from "react";
import { View } from "react-native";
import { NavigationTitle } from "./NavigationTitle";
import * as R from "ramda";
import { forceFocusableFocus } from "@applicaster/zapp-react-native-utils/appUtils/focusManager";

import {
  sendQuickBrickEvent,
  QUICK_BRICK_EVENTS,
} from "@applicaster/zapp-react-native-bridge/QuickBrick";

import { debounce } from "@applicaster/zapp-react-native-utils/functionUtils";
import { FocusableGroup } from "@applicaster/zapp-react-native-ui-components/Components/FocusableGroup";
import { topBarContainer, topBarDataContainer, menuContainer } from "./styles";
import {
  defaultMenuItems,
  navItemsFromProps,
  isHomeItemSelected,
  findItemByTarget,
  generateMappingData,
  findItemToFocus,
  isMenuFocused,
  focusableItemIdByData,
  menuGroupId,
  findHomeItem,
} from "./helpers.js";
import { NavigationContainer } from "./NavigationContainer";

import { onMenuItemFocus } from "@applicaster/zapp-react-native-ui-components/Helpers/ComponentCellSelectionHelper";
import { TVEventHandlerComponent } from "../TVEventHandlerComponent";

type Props = {
  activeRiver: any,
  navigator: any,
  children: React.ComponentType<any>,
  components: { [string]: React.ComponentType<any> },
  plugins: [{ module: any, type: string, name: string }],
  rivers: { [string]: any },
  pluginConfigurations: {},
  menuProps: { selected: string, nav_items: {}, styles: {} },
  homeId: string,
  isHidden: boolean,

  screenFocusBlocked: boolean,
  setScreenDidAppear: () => void,
  setScreenDidLoad: () => void,
  setScreenDidDisappear: () => void,
  setScreenFocusedOnItem: () => void,
};

type State = {
  screenTitle: string,
  screenSummary: string,
  isFocusableDisabled: boolean,
  screenFinishedFocus: boolean,
};

export class DefaultNavigationComponent extends React.Component<Props, State> {
  constructor(props) {
    super(props);
    this.ignoreBlockingFocus = false;
    this.onNavigationItemFocus = this.onNavigationItemFocus.bind(this);
    this.onNavigationItemBlur = this.onNavigationItemBlur.bind(this);
    this.handleRemoteEvent = this.handleRemoteEvent.bind(this);

    this.onNavigationDidUpdateFocus = this.onNavigationDidUpdateFocus.bind(
      this
    );

    this.invokeFocusedItem = null;
    this.state = {
      screenTitle: null,
      screenSummary: null,
      isFocusableDisabled: true,
      mappingData: generateMappingData(
        this.selectedTarget(),
        navItemsFromProps(props)
      ),
    };
    this.userScrollingTimer = null;
    this.currentSelectedItem = null;

    this.screenReadyForPresenation = this.screenReadyForPresenation.bind(this);
    this.screenReadyForLoad = this.screenReadyForLoad.bind(this);
    this.screenFinishedFocusing = this.screenFinishedFocusing.bind(this);
    this.screenDidDisappear = this.screenDidDisappear.bind(this);

    props.setScreenDidLoad(this.screenReadyForLoad);
    props.setScreenDidAppear(this.screenReadyForPresenation);
    props.setScreenFocusedOnItem(this.screenFinishedFocusing);
    props.setScreenDidDisappear(this.screenDidDisappear);
    this.userFinishedSelection = this.userFinishedSelection.bind(this);
    this.waitUntilUserSelectionFinish = debounce({
      fn: this.userFinishedSelection,
      immediate: false,
      context: this,
    });
  }

  screenReadyForLoad({ id, isInsideContainer = false }) {}

  screenReadyForPresenation({ id, isInsideContainer = false, screenData }) {
    if (isInsideContainer === false) {
      const { title, summary } = screenData;
      this.setState({ screenTitle: title, screenSummary: summary });
    }
  }

  screenFinishedFocusing() {
    this.setState({ isFocusableDisabled: false });
  }

  screenDidDisappear({ id, isInsideContainer = false }) {
    if (this.ignoreBlockingFocus === true) {
      this.ignoreBlockingFocus = false;
    } else {
      isInsideContainer === false &&
        this.setState({
          isFocusableDisabled: true,
        });
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    const navItems = navItemsFromProps(this.props);
    const newNavItems = navItemsFromProps(nextProps);
    const {
      menuProps: { selected },
    } = this.props;
    if (newNavItems && !R.equals(navItems, newNavItems)) {
      this.setState({
        mappingData: generateMappingData(selected, newNavItems),
      });
      return false;
    }

    return true;
  }

  selectedTarget() {
    const {
      menuProps: { selected },
    } = this.props;
    return selected;
  }

  onNavigationItemFocus({ e, item, index, isHome }) {
    this.setNavItemSelected(item.id);
    const { navigationItem } = item;
    const { navigator } = this.props;
    this.invokeFocusedItem = () => {
      navigator.replace(navigationItem);
      onMenuItemFocus({ e, item: navigationItem, index, isHome });
    };
  }

  setNavItemSelected(id, title, summary) {
    function mapper(item) {
      const selected = id === item.id;
      return {
        ...item,
        selected: selected,
        focused: selected,
      };
    }
    this.setState({
      screenTitle: title,
      screenSummary: summary,
      mappingData: R.map(mapper, this.state.mappingData),
    });
  }

  onNavigationItemBlur({ e, item, index }) {
    const indexOfItem = R.findIndex(R.propEq("id", item.id))(
      this.state.mappingData
    );

    const newMappingData = this.state.mappingData;
    newMappingData[indexOfItem].focused = false;
    this.setState({
      mappingData: newMappingData,
    });
  }

  userFinishedSelection() {
    if (this.userFocusedOnMenu()) {
      this.invokeFocusedItem && this.invokeFocusedItem();
      this.invokeFocusedItem = null;
    }
  }

  onNavigationDidUpdateFocus({ nativeEvent }) {
    const { isFocusingByUser } = nativeEvent;
    if (isFocusingByUser === true) {
      this.ignoreBlockingFocus = true;
      this.waitUntilUserSelectionFinish();
      this.state.isFocusableDisabled === true &&
        this.setState({ isFocusableDisabled: false });
    }
  }

  setFocusOnLastFocus(screenData) {
    const selected = this.selectedTarget();
    const item = findItemToFocus(this.state.mappingData, selected);
    const { id } = item;
    if (id) {
      const itemId = focusableItemIdByData(item);
      forceFocusableFocus(menuGroupId, itemId);
      if (screenData) {
        const { title, summary } = screenData;
        this.setNavItemSelected(id, title, summary);
      } else {
        this.setNavItemSelected(id);
      }
    }
  }

  getHomeItem() {
    const { homeId } = this.props;
    return findHomeItem(this.state.mappingData, homeId);
  }

  userFocusedOnMenu() {
    const { navigator } = this.props;
    return isMenuFocused(this.state.mappingData, navigator);
  }

  setFocusOnHomeItem() {
    const homeItem = this.getHomeItem();
    const { id } = homeItem;

    if (id) {
      const itemId = focusableItemIdByData(homeItem);
      forceFocusableFocus(menuGroupId, itemId);
      this.setNavItemSelected(id);
      return true;
    }
    return false;
  }

  handleRemoteEvent(comp, event) {
    const { eventType } = event;
    const { navigator, homeId } = this.props;
    const navigatorCanGoBack = navigator.canGoBack();

    if (eventType === "menu") {
      if (this.userFocusedOnMenu() === false || navigatorCanGoBack) {
        if (navigatorCanGoBack) {
          this.isComponentUpdating = true;
          navigator.goBack();
        } else {
          this.ignoreBlockingFocus = true;
          this.setFocusOnLastFocus();
        }
      } else {
        if (isHomeItemSelected(this.state.mappingData, homeId)) {
          this.moveAppToBackground();
        } else {
          const { navigationItem } = this.getHomeItem();
          this.ignoreBlockingFocus = true;
          this.setFocusOnHomeItem() && navigator.replace(navigationItem);
        }
      }
    }
  }

  moveAppToBackground() {
    sendQuickBrickEvent(QUICK_BRICK_EVENTS.MOVE_APP_TO_BACKGROUND);
  }

  navigationItemsForNavigationType(navigationType) {
    return R.filter(R.propEq("navigationType", navigationType))(
      this.state.mappingData
    );
  }

  navigationContainerWithParams(navigationType) {
    const {
      navigator,
      menuProps: { nav_items, selected, styles, ...restArgs },
    } = this.props;
    const selectedItem = findItemByTarget(this.state.mappingData, selected);
    const navigationItems = this.navigationItemsForNavigationType(
      navigationType
    );
    return (
      <NavigationContainer
        {...restArgs}
        menuStyles={styles}
        selectedItem={selectedItem}
        isFocusableDisabled={this.state.isFocusableDisabled}
        navigator={navigator}
        nav_items={navigationItems}
        style={{ menuContainer }}
        onNavigationItemFocus={this.onNavigationItemFocus}
        onNavigationItemBlur={this.onNavigationItemBlur}
        navigationType={navigationType}
        homeItemId={focusableItemIdByData(this.getHomeItem())}
      />
    );
  }

  render() {
    const {
      menuProps,
      isHidden,
      menuProps: { selected },
    } = this.props;
    const { screenTitle, screenSummary } = this.state;
    const { navigator } = this.props;
    const selectedItem = findItemByTarget(this.state.mappingData, selected);
    if (selectedItem) {
      const itemId = focusableItemIdByData(selectedItem);
      this.currentSelectedItem = itemId;
    }
    return isHidden ? null : (
      <TVEventHandlerComponent tvEventHandler={this.handleRemoteEvent}>
        <FocusableGroup
          style={topBarContainer}
          id={menuGroupId}
          onDidUpdateFocus={this.onNavigationDidUpdateFocus}
        >
          <View style={topBarDataContainer}>
            {this.navigationContainerWithParams(defaultMenuItems.LEFT)}
            {navigator.canGoBack() ? (
              <NavigationTitle
                title={screenTitle}
                summary={screenSummary}
                menuProps={menuProps}
              />
            ) : (
              this.navigationContainerWithParams(defaultMenuItems.CENTER)
            )}
            {this.navigationContainerWithParams(defaultMenuItems.RIGHT)}
          </View>
        </FocusableGroup>
      </TVEventHandlerComponent>
    );
  }
}
