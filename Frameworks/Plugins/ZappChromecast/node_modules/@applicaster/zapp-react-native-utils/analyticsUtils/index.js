import * as R from "ramda";

import {
  postAnalyticEvent,
  startAnalyticsTimedEvent,
  endAnalyticsTimedEvent,
} from "./manager";

import { millisecondsToTime } from "./dateFormatters";
import { mapKeys } from "../objectUtils";

import {
  ANALYTICS_CORE_EVENTS,
  ANALYTICS_ENTRY_EVENTS,
  ANALYTICS_COMPONENT_EVENTS,
  ANALYTICS_LAUNCH_EVENTS,
} from "./events";

import { NativeModules } from "react-native";

export function sendSelectCellEvent(item, component, headerTitle, itemIndex) {
  const analyticsProperties = R.compose(
    R.reject(R.isNil),
    R.merge(eventForEntry(item, itemIndex + 1))
  )(eventForComponent(component, headerTitle));
  postAnalyticEvent(ANALYTICS_CORE_EVENTS.TAP_CELL, analyticsProperties);
}

export function sendVideoItemPlayStartTimedEvent(item, durationInMiliseconds) {
  const durationTime = millisecondsToTime(durationInMiliseconds);

  const analyticsProperties = R.compose(
    R.reject(R.isNil),
    R.merge({
      [ANALYTICS_ENTRY_EVENTS.ITEM_DURATION]: durationTime,
      [ANALYTICS_ENTRY_EVENTS.ITEM_PLAY_COMPLETED]: "NO",
    })
  )(eventForEntry(item));

  startAnalyticsTimedEvent(
    ANALYTICS_CORE_EVENTS.PLAY_VOD_ITEM,
    analyticsProperties
  );
}
export function sendVideoItemPlayStopTimedEvent(item, durationInMiliseconds) {
  const durationTime = millisecondsToTime(durationInMiliseconds);

  const analyticsProperties = R.compose(
    R.reject(R.isNil),
    R.merge({
      [ANALYTICS_ENTRY_EVENTS.ITEM_DURATION]: durationTime,
      [ANALYTICS_ENTRY_EVENTS.ITEM_PLAY_COMPLETED]: "YES",
    })
  )(eventForEntry(item));
  endAnalyticsTimedEvent(
    ANALYTICS_CORE_EVENTS.PLAY_VOD_ITEM,
    analyticsProperties
  );
}
export function sendVideoItemPlayEvent(item) {
  const analyticsProperties = R.compose(R.reject(R.isNil))(eventForEntry(item));
  postAnalyticEvent(playEventForType(item), analyticsProperties);
}

export function sendLaunchEvent() {
  const { QuickBrickCommunicationModule } = NativeModules;

  if (!QuickBrickCommunicationModule) {
    // eslint-disable-next-line no-console
    console.warn("failed to initialize QuickBrickCommunicationModule", {
      NativeModules,
    });
    return;
  }

  const {
    accountId,
    bundleIdentifier,
    riversConfigurationId,
  } = QuickBrickCommunicationModule;

  postAnalyticEvent(
    ANALYTICS_CORE_EVENTS.LAUNCH_APP,
    eventForLaunch({
      accountId,
      bundleIdentifier,
      riversConfigurationId,
    })
  );
}

function playEventForType(item) {
  const itemType = item.type && item.type.value;

  if (itemType === "program") {
    return ANALYTICS_CORE_EVENTS.PROGRAM_ITEM_PLAY_WAS_TRIGGERED;
  } else if (itemType === "channel") {
    return ANALYTICS_CORE_EVENTS.CHANNEL_ITEM_PLAY_WAS_TRIGGERED;
  } else {
    return ANALYTICS_CORE_EVENTS.VOD_ITEM_PLAY_WAS_TRIGGERED;
  }
}

function eventForLaunch(appData) {
  const { versionName, bundleIdentifier, riversConfigurationId } = appData;

  return {
    [ANALYTICS_LAUNCH_EVENTS.VERSION_NAME]: versionName,
    [ANALYTICS_LAUNCH_EVENTS.BUNDLE_VERSION]: bundleIdentifier,
    [ANALYTICS_LAUNCH_EVENTS.UUID]: "",
    [ANALYTICS_LAUNCH_EVENTS.MORPHEOUS_VERSION]: "",
    [ANALYTICS_LAUNCH_EVENTS.RIVERS_CONFIGURATON_ID]: riversConfigurationId,
  };
}

function eventForEntry(item, itemIndex) {
  const {
    title,
    content: { src },
    type: { value: valueType },
    id,
    screen_type,
    extensions,
  } = item;
  const analyticsCustomProps = entryAnalyticsCustomProperties(item);
  const isFreeParameter =
    extensions && extensions.free !== true ? "Paid" : "Free";
  return {
    [ANALYTICS_ENTRY_EVENTS.ITEM_TYPE]: valueType,
    [ANALYTICS_ENTRY_EVENTS.ITEM_TITLE]: title,
    [ANALYTICS_ENTRY_EVENTS.ITEM_ID]: id,
    [ANALYTICS_ENTRY_EVENTS.ITEM_LINK]: encodeURIComponent(src),
    [ANALYTICS_ENTRY_EVENTS.ITEM_TARGET]:
      screen_type || ANALYTICS_CORE_EVENTS.ITEM_NOT_AVAILABLE,
    [ANALYTICS_ENTRY_EVENTS.ITEM_INDEX]: itemIndex || null,
    [ANALYTICS_ENTRY_EVENTS.ITEM_INDEX_IS_FREE]: isFreeParameter,
    ...analyticsCustomProps,
  };
}

const entryAnalyticsCustomProperties = R.compose(
  R.ifElse(
    R.isNil,
    R.always({}),
    mapKeys(
      R.compose(
        R.concat(ANALYTICS_ENTRY_EVENTS.ITEM_CUSTOM_PROPERTY),
        R.concat(" ")
      )
    )
  ),
  R.path(["extensions", "analyticsCustomProperties"])
);

function eventForComponent(component, headerTitle) {
  const { id, component_type, styles, data, rules } = component;
  const { cell_style, family, header } = styles;
  const { visible } = header;
  const { connected, target, source, type } = data;
  const itemLimit = rules.item_limit;
  return {
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_ID]: id,
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_TYPE]: component_type,
    [ANALYTICS_COMPONENT_EVENTS.CELL_STYLE]:
      cell_style || ANALYTICS_CORE_EVENTS.ITEM_NOT_AVAILABLE,
    [ANALYTICS_COMPONENT_EVENTS.CELL_FAMILY]: family,
    [ANALYTICS_COMPONENT_EVENTS.HAS_HEADERS]: visible,
    [ANALYTICS_COMPONENT_EVENTS.CONNECTED_SCREEN]: connected ? "YES" : "NO",
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_TARGET]:
      target || ANALYTICS_CORE_EVENTS.ITEM_NOT_AVAILABLE,
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_SOURCE]: source,
    [ANALYTICS_COMPONENT_EVENTS.COMPONENT_SOURCE_TYPE]: type,
    [ANALYTICS_COMPONENT_EVENTS.ITEM_LIMIT]: itemLimit,
    [ANALYTICS_COMPONENT_EVENTS.HEADER_TITLE]: headerTitle,
  };
}
