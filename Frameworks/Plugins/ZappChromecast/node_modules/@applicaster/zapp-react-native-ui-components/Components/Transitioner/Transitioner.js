// @flow
import * as React from "react";
import { View } from "react-native";
import * as R from "ramda";

import { AnimationManager } from "./AnimationManager";
import { Scene } from "./Scene";

export const NAV_ACTION_PUSH = "PUSH";
export const NAV_ACTION_REPLACE = "REPLACE";
export const NAV_ACTION_BACK = "POP";

type SceneProps = { children: React.Node };

/**
 * 1. If there is more than one scene, get back to the previous scene.
 * 2. If there is no scene to go back to, clone the new children as the scene to go back to.
 * @param {any} props Component's props
 * @param {any} state Component's state
 */
function scenesForBackTransition(props: SceneProps, { scenes }) {
  return scenes.length > 1 ? R.identity(scenes) : [props.children, scenes[0]];
}
type Props = {
  transitionConfig: Function,
  children: React.Node,
  navigator: {
    previousAction: string,
    currentRoute: string,
    routeData: (void) => { [string]: any },
  },
};

type State = {
  animatedValue: any,
  animating: Boolean,
  duration: number,
  easing: any,
  from: any,
  to: any,
  scenes: any,
};

const styles = {
  container: { flex: 1 },
};

export class TransitionerComponent extends React.PureComponent<Props, State> {
  constructor(props: Props) {
    super(props);

    this.animationManager = new AnimationManager(props);

    this.state = {
      scenes: [props.children], // starting with index: 0
      ...this.animationManager.initialState(),
    };

    this.pushTransitionStart = this.pushTransitionStart.bind(this);
    this.pushTransitionEnd = this.pushTransitionEnd.bind(this);
    this.backTransitionStart = this.backTransitionStart.bind(this);
    this.backTransitionEnd = this.backTransitionEnd.bind(this);
  }

  /**
   * Clone new children, append to scenes array,
   * and trigger push animation with callbacks.
   */
  pushTransitionStart() {
    this.setState(
      {
        scenes: R.append(this.props.children, this.state.scenes),
        ...this.animationManager.stateForAction(this.state, NAV_ACTION_PUSH),
      },
      () => {
        this.animationManager.animate(this.state, this.pushTransitionEnd);
      }
    );
  }

  /**
   * Trigger back animation.
   * The last scene in the array is removed in the "backTransitionEnd" callback,
   * only after the animation is complete.
   */
  backTransitionStart() {
    this.setState(
      {
        scenes: scenesForBackTransition(this.props, this.state),
        ...this.animationManager.stateForAction(this.state, NAV_ACTION_BACK),
      },
      () => {
        this.animationManager.animate(this.state, this.backTransitionEnd);
      }
    );
  }

  nextRouteIsPlayable(currentRoute, routeData) {
    const isPlayableType = (type) =>
      type === "video" || type === "audio" || type === "channel";

    return (
      currentRoute.includes("/playable/") ||
      isPlayableType(routeData?.type?.value) ||
      isPlayableType(routeData?.payload?.type?.value)
    );
  }

  componentDidUpdate(prevProps: Props) {
    const currentRoute = this.props.navigator?.currentRoute;
    if (currentRoute !== prevProps.navigator.currentRoute) {
      if (this.state.animating) return; // Extremly rare scenario, just a safety precaution.
      const routeData = this.props.navigator?.routeData?.();

      if (this.nextRouteIsPlayable(currentRoute, routeData)) {
        // We're checking here if the next route is the player route
        // or a player hook. If it is, we're skipping the transition as
        // this can create a player to mount twice, and video will start to play twice
        return;
      }

      const { scenes } = this.state;
      switch (this.props.navigator.previousAction) {
        case NAV_ACTION_PUSH:
          this.pushTransitionStart();
          break;
        case NAV_ACTION_BACK:
          this.backTransitionStart();
          break;
        case NAV_ACTION_REPLACE:
          // Instant modification of active scene without animations.
          this.setState({
            scenes: R.update(scenes.length - 1, this.props.children, scenes),
          });
          break;
        default:
          // Should never get here - disabling animation just to be on the safe side.
          this.setState({ animating: false });
          break;
      }
    }
  }

  // Sets state.animating to false
  pushTransitionEnd() {
    this.setState({
      animating: false,
    });
  }

  // Sets state.animating to false
  // and remove last scene from scenes stack
  backTransitionEnd() {
    this.setState({
      animating: false,
      scenes: R.init(this.state.scenes),
    });
  }

  // On initial state, both "to" and "from" point to a single scene
  // so only a single scene should be rendered,
  // instead of dangerous nulls or duplicates.
  renderSingleScene({ scenes, to }) {
    return (
      <View style={styles.container}>
        <Scene {...{ style: to.style }}>{scenes[to.index]}</Scene>
      </View>
    );
  }

  // Render two scenes consecutively -
  // the scenes' indexes determines which scene should be drawn first.
  // Looks redundant, but when written like this
  // we do not need to pass or generate keys.
  renderScenes({ scenes, from, to }) {
    const fromScene = (
      <Scene {...{ style: from.style, pointerEvents: "none" }}>
        {scenes[from.index]}
      </Scene>
    );
    const toScene = <Scene {...{ style: to.style }}>{scenes[to.index]}</Scene>;

    return from.index <= to.index ? (
      <View style={styles.container}>
        {fromScene}
        {toScene}
      </View>
    ) : (
      <View style={styles.container}>
        {toScene}
        {fromScene}
      </View>
    );
  }

  render() {
    const { from, to } = this.state;
    if (from.index === to.index) {
      return this.renderSingleScene(this.state);
    }

    return this.renderScenes(this.state);
  }
}
