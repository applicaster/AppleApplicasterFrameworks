import * as R from "ramda";
import { bootstrapZappPipes } from "@applicaster/zapp-react-native-bridge/ZappPipes";

import { actionCreator } from "../helpers";
import { createSelector } from "reselect";

import { ZappPipesAdapter } from "./zappPipesAdapter";

let cachedPlugins;
let cachedProviders;
let zappPipes;

/**
 * sets the zappPipes adapter with the provided bootstrapper function
 */
export function setZappPipesAdapter() {
  zappPipes = new ZappPipesAdapter({ bootstrapper: bootstrapZappPipes });
}

// constants
export const ZAPP_PIPES_REQUEST_START = "ZAPP_PIPES_REQUEST_START";
export const ZAPP_PIPES_REQUEST_COMPLETE = "ZAPP_PIPES_REQUEST_COMPLETE";
export const ZAPP_PIPES_REQUEST_FAIL = "ZAPP_PIPES_REQUEST_FAIL";

// actions

/**
 * redux action creator to start the Zapp Pipes loading process
 * @param {String} dataSourceUrl to load through zapp pipes
 * @returns {Object} redux action
 */
export function zappPipesRequestStart(dataSourceUrl) {
  return actionCreator(ZAPP_PIPES_REQUEST_START, { dataSourceUrl });
}

/**
 * redux action creator to complete the Zapp Pipes loading process
 * and inscribe the response in the redux store
 * @param {String} dataSourceUrl of the request
 * @param {Object} data returned by Zapp Pipes for the fiven dataSourceUrl
 * @param {Object} meta property of the action, used for specific actions in middlewares
 * @returns {Object} redux action
 */
export function zappPipesRequestComplete(dataSourceUrl, data, meta) {
  return actionCreator(
    ZAPP_PIPES_REQUEST_COMPLETE,
    { dataSourceUrl, data },
    meta
  );
}

/**
 * redux action creator to fail Zapp Pipes loading process
 * and add the error object in redux store
 * @param {String} dataSourceUrl of the request
 * @param {Object} error error object returned from Zapp Pipes
 * @param {Object} meta property of the action, used for middlewares
 * @returns {Object} redux action
 */
export function zappPipesRequestFail(dataSourceUrl, error, meta) {
  return actionCreator(ZAPP_PIPES_REQUEST_FAIL, { dataSourceUrl, error }, meta);
}

/**
 * redux thunk action which performs the zapp pipes requests on the given dataSourceUrl
 * then dispatches the proper action depending on the response received
 * @param {String} dataSourceUrl to load
 * @param {Options} options
 * @param {Boolean} options.clearCache will force to reload the dataSourceUrl even if it is already in the store
 * @param {Object} options.meta property, used for specific actions in the middlewares
 * @returns {Promise<Object>} redux thunk action
 */
export function loadPipesData(
  dataSourceUrl,
  { clearCache = false, meta = null } = {}
) {
  if (!dataSourceUrl) {
    // Todo better error management
    return;
  }
  return (dispatch, getState) => {
    // If dataSource key already exist, it is either loading, already loaded, or failed -
    // skip the second request to the same url(If first was successful).
    const currentState = getState().zappPipes[dataSourceUrl];
    if (!clearCache && currentState && !currentState.error) {
      return;
    }

    // request starts
    dispatch(zappPipesRequestStart(dataSourceUrl));

    const { plugins } = getState();

    // if there are new plugins, we recreate the cached providers
    if (!cachedProviders || !R.equals(cachedPlugins, plugins)) {
      cachedProviders = R.compose(
        R.map(R.prop("module")),
        R.filter(R.propEq("type", "data_source_provider"))
      )(plugins);
    }

    // We set up the adapter if it is not initialized.
    if (!zappPipes) {
      setZappPipesAdapter();
    }

    // bootstrapping zappPipes adapter. Does nothing if cached providers
    // are identical
    zappPipes.bootstrap(cachedProviders);

    // Request is sent to Zapp Pipes adapter. We keep the same callback
    // pattern for consistency with the native API.
    zappPipes.get(dataSourceUrl, pipesResponse => {
      const { response, code } = pipesResponse;
      // zapp pipes request returns a code in its payload. if all is ok, code is 200.
      // All other codes are failures
      // eslint-disable-next-line eqeqeq
      if (code == 200) {
        // Request succeeded, we dispatch the complete action with the response
        dispatch(zappPipesRequestComplete(dataSourceUrl, response, meta));
      } else {
        // request failed, we dispatch the failure action with the response
        // Will send this to Sentry when it is implemented
        // eslint-disable-next-line no-console
        console.warn("zapp pipes returned an error :(", pipesResponse);
        dispatch(zappPipesRequestFail(dataSourceUrl, response, meta));
      }
    });
  };
}

// selector
// TODO : use reselect for smart selector to retrieve a dataSourceUrl
export function zappPipesSelector(state) {
  return state.zappPipes;
}

export function getZappPipesData(dataSourceUrl) {
  return createSelector(zappPipesSelector, R.prop(dataSourceUrl));
}

// reducer

function reducer(state = {}, { type, payload }) {
  switch (type) {
    case ZAPP_PIPES_REQUEST_START:
      return R.merge(state, {
        [payload.dataSourceUrl]: {
          loading: true,
          url: payload.dataSourceUrl,
        },
      });

    case ZAPP_PIPES_REQUEST_COMPLETE:
      return R.merge(state, {
        [payload.dataSourceUrl]: {
          url: payload.dataSourceUrl,
          loading: false,
          data: payload.data,
        },
      });

    case ZAPP_PIPES_REQUEST_FAIL:
      return R.merge(state, {
        [payload.dataSourceUrl]: {
          url: payload.dataSourceUrl,
          loading: false,
          error: payload.error,
        },
      });

    default:
      return state;
  }
}

export default reducer;
