// @flow
import * as React from "react";
import { Platform } from "react-native";
import { connectToStore } from "@applicaster/zapp-react-native-redux";
import { loadPipesData } from "@applicaster/zapp-react-native-redux/ZappPipes";
import * as R from "ramda";

import type {
  ZappComponentProps,
  ZappDecoratedComponentProps,
} from "@applicaster/zapp-react-native-flow-types";

export function zappPipesDataConnector(
  Component: React.ComponentType<ZappComponentProps>
): React.ComponentType<ZappDecoratedComponentProps> {
  class ZappPipesConnector extends React.Component<ZappDecoratedComponentProps> {
    constructor(props) {
      super(props);

      this.getDataSourceUrl = this.getDataSourceUrl.bind(this);
      this.getZappPipesData = this.getZappPipesData.bind(this);
      this.reloadDataSource = this.reloadDataSource.bind(this);
    }

    componentDidMount() {
      const dataSourceUrl = this.getDataSourceUrl();

      if (dataSourceUrl) {
        this.props.loadPipesData(dataSourceUrl);
      }
    }

    reloadDataSource() {
      const dataSourceUrl = this.getDataSourceUrl();

      if (dataSourceUrl) {
        this.props.loadPipesData(dataSourceUrl, { clearCache: true });
      }
    }

    getDataSourceUrl() {
      const { component, feedUrl } = this.props;

      if (feedUrl) {
        return feedUrl;
      }

      if (component.data) {
        const {
          component: {
            data: { source, type },
          },
        } = this.props;

        if (source) {
          if (type === "APPLICASTER_COLLECTION" && !R.includes("://", source)) {
            return `applicaster://fetchData?type=${type}&collectionId=${source}`;
          }

          if (type === "APPLICASTER_CATEGORY" && !R.includes("://", source)) {
            return `applicaster://fetchData?type=${type}&categoryId=${source}&platform=${Platform.OS}`;
          }

          return source;
        }
      }

      return null;
    }

    applyItemLimit(zappPipesData) {
      if (!zappPipesData || !zappPipesData.data) {
        return zappPipesData;
      }

      const { data } = zappPipesData;
      const {
        component: {
          rules: { item_limit },
        },
      } = this.props;

      if (item_limit && data.entry && data.entry.length) {
        return {
          ...zappPipesData,
          data: {
            ...data,
            entry: R.slice(
              0,
              Math.min(Number(item_limit), R.length(data.entry)),
              data.entry
            ),
          },
        };
      }

      return zappPipesData;
    }

    getZappPipesData() {
      const { zappPipes } = this.props;
      const dataSourceUrl = this.getDataSourceUrl();

      if (dataSourceUrl) {
        return this.applyItemLimit(zappPipes[dataSourceUrl]);
      } else {
        return { error: "No Zapp Pipes Data" };
      }
    }

    render() {
      const props = R.omit(["zappPipes", "loadPipesData"], this.props);
      return (
        <Component
          {...props}
          zappPipesData={this.getZappPipesData()}
          reloadData={this.reloadDataSource}
        />
      );
    }
  }

  return connectToStore(R.pick(["zappPipes"]), { loadPipesData })(
    ZappPipesConnector
  );
}
