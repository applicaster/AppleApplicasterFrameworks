// @flow
import * as R from "ramda";
import { ASSETS, STYLES } from "./Keys";

/**
 * fixes color - Zapp colors are AARRGGBB and output needs to be RRGGBBAA
 *
 * @param {string} input colorString
 * @returns {string} transformed color string
 */
export function fixColorHexCode(colorHex: string): string {
  return colorHex && `#${colorHex.slice(3, 9)}${colorHex.slice(1, 3)}`;
}

/**
 * returns the color value of a given style
 * @param {string} color name of color style to pick
 * @param {Object} appStyles dictionary of styles for the app
 * @returns {string} color string for the requested style
 */
export function getAppStylesColor(color: string, appStyles: {}): string {
  return R.compose(
    fixColorHexCode,
    R.defaultTo(""),
    R.path([color, "color"])
  )(appStyles || {});
}

/**
 * This call is quite safe:
 * - cellStyles is always initialized as an empty object by default in the redux store.
 * - component.styles is always present
 * Take care: The returned cellStyle can be undefined, component should provide fallback or throw.
 * @param {object} cellStyles     From cell_styles.json - map of ids to master cells
 * @param {object} component      UI component from rivers.json
 * @returns {(object|undefined)}  Master Cell || Cell Styles Plugin configuration || undefined
 */
export function extractMasterCell({ cellStyles, component: { styles } }) {
  const masterCell = cellStyles[styles.master_cell_id];

  if (!masterCell) {
    return undefined;
  }

  // TODO: Support master cells that have a plugin configuration
  // For now this is just a safety fallback to prevent crashes during
  // development of the cell-styles-as-plugins feature
  if (masterCell.plugin_identifier) {
    return undefined;
  }

  return masterCell;
}

/**
 * retrieves an asset
 * @param {string} assetKey
 * @param {Object} remoteConfigurations
 * @returns {string}
 */
export function getAppAsset(
  assetKey: string,
  remoteConfigurations: { [string]: any }
): string {
  return getAppProperty("assets", assetKey, remoteConfigurations);
}

/**
 * retrieves a style key
 * @param {string} assetKey
 * @param {Object} remoteConfigurations
 * @returns {string}
 */

export function getAppStyle(
  styleKey: string,
  styles: { [string]: any }
): string {
  return getAppProperty("styles", styleKey, { styles });
}
/**
 * retrieves an app property from remote configurations
 * @param {string} prop "styles" | "assets"
 * @param {string} key
 * @param {Object} remoteConfigurations
 * @returns {string}
 */
function getAppProperty(
  prop: string,
  key: string,
  remoteConfigurations: { [string]: any }
): string {
  const APP_PROPS = {
    styles: STYLES,
    assets: ASSETS,
  };

  const appProperties = APP_PROPS[prop];

  const propPath = R.path([prop, "tv"], remoteConfigurations)
    ? "tv"
    : "universal";

  if (!R.keys(appProperties).includes(key)) {
    // eslint-disable-next-line no-console
    console.warn(
      `Requesting unknown asset ${key} - check the available assets:`,
      { [prop]: appProperties }
    );
  }

  return R.path([prop, propPath, appProperties[key]], remoteConfigurations);
}

function transformStringBooleans(stringValue) {
  if (stringValue !== "true" && stringValue !== "false") {
    return stringValue;
  }

  return stringValue === "true";
}

/**
 * map of transformation function to apply to sanitize the fields
 * present in the manifest configuration
 */
const transforms = {
  switch: transformStringBooleans,
  number_input: (num) => (num === null || num === "" ? null : Number(num)),
  color_picker: fixColorHexCode,
};

/**
 * Applies a tranformation for a given type of manifest field. Falls back to
 * the identity function if the type is not declared in the transforms map
 * Curried function of the form applyTransform(type)(value)
 * @param {String} type to apply the transformation for
 * @returns {Function}
 * @param {Any} value to transform
 * @returns {Any} sanitized value
 */
function applyTransform(type: string): (any) => any {
  return transforms[type] || R.identity;
}

/**
 * map of type checks to apply to each manifest field in order to check if
 * the provided value is valid for that given manifest type
 */
const typeChecks = {
  switch: R.is(Boolean),
  number_input: R.is(Number),
  text_input: R.is(String),
};

/**
 * This function checks if a provided value is valid for the provided type
 * curried function of the form isInvalidForType(type)(value);
 * returns true if the value is invalid, and false if the value is ok.
 * @param {*} type
 * @returns {Function}
 * @param {Any} value to check
 * @returns {boolean}
 */
function isInvalidForType(type: string): (any) => boolean {
  return function (value: any): boolean {
    return R.compose(
      R.not,
      R.apply(R.__, [value]),
      R.propOr(R.T, type)
    )(typeChecks);
  };
}

/**
 * Checks if a value is valid for a provided type. Checks if the the type is correct,
 * but also if the value is not empty, not null, and not NaN
 * curried function of the form isInvalidValue(type)(value). Returns true if the value
 * is invalid, and false otherwise
 * @param {String} type
 * @returns {Function}
 * @param {Any} value to check for
 * @returns {boolean}
 */
function isInvalidValue(type: string): (any) => boolean {
  return function (value) {
    return R.anyPass([
      R.isEmpty,
      R.isNil,
      Number.isNaN,
      isInvalidForType(type),
    ])(value);
  };
}

type ManifestField<T> = {
  key: string,
  type: string,
  initial_value: T,
  group?: boolean,
  fields?: [ManifestField<any>],
};

type PluginConfiguration = {
  [string]: any,
};

/**
 * This function will sanitize a value from a provided configuration, by trying
 * to apply the relevant transform, and resolving to the default value
 * if the resulting value is invalid (null, empty, NaN, or incorrect type)
 * Curried function of the form castOrDefault(field)(configuration)
 * @param {Object} field plugin manifest field
 * @param {String} field.type type of the manifest field
 * @param {Any} field.initial_value default value provided in the manifest for that field
 * @param {String} field.key key of the manifest field
 * @returns {Function}
 * @param {Object} configuration retrieved from the server
 */
function castOrDefault<T>({
  type,
  initial_value,
  key,
}: ManifestField<T>): (PluginConfiguration) => T {
  const transform = applyTransform(type);

  return function (configuration: PluginConfiguration): T {
    return R.compose(
      // checking if transformed value is valid, and if not, using default
      R.when(isInvalidValue(type), R.always(transform(initial_value))),
      transform, // applying transform
      R.prop(key) // extracting the key from the configuration object
    )(configuration);
  };
}

/**
 * Flattens the manifest configuration fields which contains group into
 * a flat list of fields
 * @param {Array<Object>} fields to flatten
 * @returns {Array<Object>} flatten fields
 */
function flattenFields(fields: [ManifestField<any>]): [ManifestField<any>] {
  return R.compose(
    R.flatten,
    R.map(R.when(R.has("fields"), R.prop("fields"))),
    R.flatten
  )(fields);
}

/**
 * This function takes 2 styles objects in key:value pairs,
 * remove all undefined values and return merged styles.
 * @param {object} defaultStyle default fallback styles in key:value pairs
 * @param {object} customStyle remote configuration of styles in key:value pairs
 * @returns {(object|undefined)} merged styles in key:value pairs
 */
export function mergeStyles(defaultStyle, customStyle) {
  const filteredCustomStyle = R.reject(R.isNil, customStyle);
  return { ...defaultStyle, ...filteredCustomStyle };
}

/**
 * This function is mapping default styles from plugin manifest to styles
 * in ke:value pairs
 * @param {object} styles - object from manifest structure styles.fields
 * @returns styles in key:value pairs
 */
export function parseDefaultStyles(
  styles: [ManifestField<any>]
): { [string]: any } {
  return R.compose(
    R.reduce((acc, { type, key, initial_value }) => {
      return R.assoc(key, applyTransform(type)(initial_value), acc);
    }, {}),
    flattenFields
  )(styles);
}

/**
 * This function is casting default styles to expected format
 * @param {object} fields - array of configuration fields form manifest
 * @returns array of {key, value, mapper:(function)}
 */
export function populateConfigurationValues(
  fields: [ManifestField<any>]
): (PluginConfiguration) => { [string]: any } {
  return function (configuration: PluginConfiguration): { [string]: any } {
    return R.compose(
      R.reduce((values, field) => {
        const fieldValue = castOrDefault(field)(configuration);
        return R.assoc(field.key, fieldValue, values);
      }, {}),
      flattenFields
    )(fields);
  };
}
