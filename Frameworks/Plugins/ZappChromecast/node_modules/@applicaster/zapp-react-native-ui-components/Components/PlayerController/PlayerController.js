// @flow
import * as React from "react";
import { View } from "react-native";
import * as R from "ramda";

import { playerManager } from "@applicaster/zapp-react-native-utils/appUtils/playerManager";
import {
  sendVideoItemPlayStartTimedEvent,
  sendVideoItemPlayEvent,
  sendVideoItemPlayStopTimedEvent,
} from "@applicaster/zapp-react-native-utils/analyticsUtils/index";

import {
  platformSelect,
  getPlatform,
} from "@applicaster/zapp-react-native-utils/reactUtils";
import { noop } from "@applicaster/zapp-react-native-utils/functionUtils";

// eslint-disable-next-line max-len
import { TVEventHandlerComponent } from "@applicaster/zapp-react-native-tvos-ui-components/Components/TVEventHandlerComponent";

import {
  allowedOrientationsForScreen,
  releaseOrientationsForScreen,
  ORIENTATIONS,
} from "@applicaster/zapp-react-native-utils/appUtils/orientationHelper";

import { AudioPlayer } from "../AudioPlayer";
import { BufferAnimation } from "./BufferAnimation";
import { DISPLAY_STATES } from "../../Contexts/DisplayStateContext";
import { ErrorDisplay } from "./ErrorDisplay";
import { ProgramInfo } from "./ProgramInfo";

type Props = {
  Player: React.ComponentType<any>,
  PlayerLoadingView: ?React.ComponentType<any>, // ðŸ‘€ we are not receiving this prop
  plugins: [],
  item: {
    author: {},
    content: {
      src: string,
      type: string,
    },
    extensions: {
      startPlayNextOverlay: ?number,
      play_next_feed_url: ?string,
      image: string,
    },
    id: string,
    link: {},
    media_group: [{}],
    published: string,
    summary: string,
    title: string,
    type: {
      value: string,
    },
    updated: string,
  },
  navigator: {
    goBack: () => void,
    showNavBar: () => void,
    hideNavBar: () => void,
  },
  displayState: string,
  playerContent: ?{},
  setPlayerContent: ({}) => void,
  setDisplayState: string => void,
  setPlayerContent: (?{}) => void,
};

type State = {
  advertismentPlaying: boolean,
  autoplay: boolean,
  error: {} | null,
  loadedVideo: boolean,
  fullscreen: boolean,
  canplay: boolean,
  muted: boolean,
  paused: boolean,
  playerState: string,
  rate: number,
  selectedAudioTracks: {},
  selectedTextTracks: {},
  showOverlay: boolean,
  textTracks: [{}],
  volume: 0 | 1,
};

const style = platformSelect({
  web: {
    display: "flex",
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
    minWidth: "100vw",
    minHeight: "100vh",
    backgroundColor: "black",
  },
  native: { flex: 1 },
});

export class PlayerController extends React.PureComponent<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      advertismentPlaying: false,
      autoplay: true,
      error: null,
      fullscreen: false,
      canplay: false,
      muted: false,
      paused: false,
      playerState: "loadstart",
      rate: 0,
      selectedAudioTracks: {},
      selectedTextTracks: {},
      showOverlay: false,
      textTracks: [{}],
      volume: 0,
      loadedVideo: false,
    };

    // The methods need to be binded to the class, they will be accessed from outside of the class
    this.onClose = this.onClose.bind(this);
    this.onCanPlay = this.onCanPlay.bind(this);
    this.onEnded = this.onEnded.bind(this);
    this.onError = this.onError.bind(this);
    this.onLoadedData = this.onLoadedData.bind(this);
    this.onPause = this.onPause.bind(this);
    this.onPlay = this.onPlay.bind(this);
    this.onProgress = this.onProgress.bind(this);
    this.onRatechange = this.onRatechange.bind(this);
    this.onTimeUpdate = this.onTimeUpdate.bind(this);
    this.onFullscreenPlayerWillPresent = this.onFullscreenPlayerWillPresent.bind(
      this
    );
    this.onFullscreenPlayerDidPresent = this.onFullscreenPlayerDidPresent.bind(
      this
    );
    this.onFullscreenPlayerWillDismiss = this.onFullscreenPlayerWillDismiss.bind(
      this
    );
    this.onFullscreenPlayerDidDismiss = this.onFullscreenPlayerDidDismiss.bind(
      this
    );
    this.onExternalPlaybackChange = this.onExternalPlaybackChange.bind(this);

    // Existing methods
    this.onAdChangedState = this.onAdChangedState.bind(this);
    this.playerRemoteHandler = this.playerRemoteHandler.bind(this);
    this.updatePlayerState = this.updatePlayerState.bind(this);
    this.assignPlayerRef = this.assignPlayerRef.bind(this);
    this.playerEvent = this.playerEvent.bind(this);

    // Local instance variables and methods
    this.currentTime = null;
    this.duration = null;
  }

  componentDidMount() {
    const { navigator } = this.props;
    navigator.hideNavBar();
    this._isMounted = true;

    allowedOrientationsForScreen(ORIENTATIONS.landscapeSensor);

    playerManager
      .registerPlayer(this.player)
      .on("close", this.onClose)
      .on("canplay", this.onCanPlay)
      .on("canplaythrough", this.updatePlayerState)
      .on("ended", this.onEnded)
      .on("error", this.onError)
      .on("loadeddata", this.onLoadedData)
      .on("loadedmetadata", this.updatePlayerState)
      .on("loadstart", this.updatePlayerState)
      .on("pause", this.onPause)
      .on("play", this.onPlay)
      .on("playing", this.updatePlayerState)
      .on("progress", this.onProgress)
      .on("ratechange", this.onRatechange)
      .on("seeked", this.updatePlayerState)
      .on("seeking", this.updatePlayerState)
      .on("stalled", this.updatePlayerState)
      .on("suspend", this.updatePlayerState)
      .on("timeupdate", this.onTimeUpdate)
      .on("volumechange", this.onVolumeChange)
      .on("waiting", this.updatePlayerState)
      .on("onFullscreenPlayerWillPresent", this.onFullscreenPlayerWillPresent)
      .on("onFullscreenPlayerDidPresent", this.onFullscreenPlayerDidPresent)
      .on("onFullscreenPlayerWillDismiss", this.onFullscreenPlayerWillDismiss)
      .on("onFullscreenPlayerDidDismiss", this.onFullscreenPlayerDidDismiss)
      .on("onExternalPlaybackChange", this.onExternalPlaybackChange)
      .on("onAdStateChange", this.onAdChangedState);

    const {
      displayState,
      setDisplayState,
      setPlayerContent,
      item,
    } = this.props;

    setPlayerContent(item);
    if (displayState === DISPLAY_STATES.DEFAULT) {
      setDisplayState(DISPLAY_STATES.PLAYER);
    }
  }

  componentWillUnmount() {
    const { setDisplayState, navigator } = this.props;
    this._isMounted = false;
    playerManager.unregisterPlayer();
    releaseOrientationsForScreen();
    setDisplayState(DISPLAY_STATES.DEFAULT);
    navigator.showNavBar();
  }

  componentDidUpdate(prevProps) {
    if (!R.equals(prevProps.item, this.props.item)) {
      const { setPlayerContent, item } = this.props;
      setPlayerContent(item);
      playerManager.setSource(R.prop("content", item));
    }
  }

  // Player manager events that need to be handled -------------------------------------------------------------
  onClose() {
    const { setPlayerContent, setDisplayState, navigator, item } = this.props;

    setDisplayState(DISPLAY_STATES.DEFAULT);
    setPlayerContent(null);
    sendVideoItemPlayStopTimedEvent(item, this.duration);

    navigator.goBack();

    this.updatePlayerState("close");
  }

  onCanPlay() {
    this.duration = playerManager.getDuration();
    this.setState({ playerState: "canplay", canplay: true, rate: 1 });
  }

  onEnded(event, data) {
    const { setPlayerContent, setDisplayState, item, navigator } = this.props;
    const { showOverlay } = this.state;
    setDisplayState(DISPLAY_STATES.DEFAULT);
    setPlayerContent(null);
    sendVideoItemPlayStopTimedEvent(item, this.duration);

    this.updatePlayerState("ended");

    if (!showOverlay) {
      navigator.goBack();
    }
  }

  onError(event, data) {
    const { error } = event.target;
    // eslint-disable-next-line no-console
    console.error("onError", { error });
    this.setState({ error, playerState: "error" });
  }

  onLoadedData(event, data) {
    const { type = "loadeddata" } = event || {};
    this.setState({ loadedVideo: true, playerState: type });
  }

  onPause(event, data) {
    const { type = "pause" } = event || {};
    this.setState({ playerState: type, paused: true, rate: 0 });
  }

  onPlay(event, data) {
    const { type = "play" } = event || {};
    const { item } = this.props;
    sendVideoItemPlayEvent(item);
    sendVideoItemPlayStartTimedEvent(item, this.duration);

    this.setState({ playerState: type, paused: false, rate: 1 });
  }

  onProgress(event, data) {
    const { item } = this.props;
    const { duration } = data;
    this.duration = duration;
    sendVideoItemPlayEvent(item);
    sendVideoItemPlayStartTimedEvent(item, this.duration);
  }

  onRatechange(event, data) {
    this.setState({ rate: data.playbackRate });
    this.updatePlayerState(this.state.rate === 0 ? "pause" : "play");
  }

  onTimeUpdate(event, dispose) {
    if (!this.hasOverlay()) {
      dispose();
    }
    const { item } = this.props;
    const isPlayNextFeed = !!item.extensions?.play_next_feed_url;
    
    const currentTime = playerManager.getCurrentTime();
    const duration = playerManager.getDuration();
    
    const overlayPlugin = this.getOverlayPlugin();
    const { showOverlay } = this.state;

    const overlayDuration =
      Number(R.path(["configuration", "overlay_duration"], overlayPlugin)) || 0;

    const overlayTrigger =
      R.path(["playableItem", "extensions", "overlay_timestamp"], this.props) ||
      Number.MAX_SAFE_INTEGER;
  
    const triggerTime = Math.min(duration - overlayDuration, overlayTrigger);

    if (isPlayNextFeed && currentTime >= triggerTime && !showOverlay) {
      this.setState({ showOverlay: true });
      dispose();
    }
  }

  onVolumeChange(event, volumechange) {
    this.setState({ volumechange });
  }

  // Player control events that need to be handled ----------------------------------------------------------------
  getPlayerControls() {
    const { plugins } = this.props;

    const PlayerControls = R.find(R.propEq("type", "player_controls"), plugins);
    return PlayerControls;
  }

  showPlayerControls() {
    const { displayState } = this.props;
    return displayState === DISPLAY_STATES.HUD;
  }

  renderPlayerControls(PlayerControls) {
    const { item } = this.props;
    const { module: Component, configuration } = PlayerControls;

    return Component ? (
      <Component configuration={configuration} playerContent={item} />
    ) : null;
  }

  playerRemoteHandler(component, event) {
    const { item, navigator } = this.props;
    const { eventType } = event;

    if (eventType === "menu") {
      navigator.goBack();

      sendVideoItemPlayStopTimedEvent(item, this.currentTime);
    }
  }

  // Native fullscreen events that need to be handled -------------------------------------------------------------
  onFullscreenPlayerWillPresent(event, data) {
    return data;
  }

  onFullscreenPlayerDidPresent(event, data) {
    return data;
  }

  onFullscreenPlayerWillDismiss(event, data) {
    return data;
  }

  onFullscreenPlayerDidDismiss(event, data) {
    return data;
  }

  onExternalPlaybackChange(event, data) {
    return data;
  }

  // Player manager helper methods
  updatePlayerState(event, data) {
    const { type = "playing" } = event || {};
    this.setState({ playerState: type });
  }

  assignPlayerRef(ref) {
    this.player = ref;
  }

  playerEvent(event, ...args) {
    playerManager.invokeHandler(event, ...args);
  }

  onAdChangedState({ advertismentPlaying }) {
    advertismentPlaying && this.setState({ advertismentPlaying });
  }

  // Overlay Methods ---------------------------------------------
  changeOverlayState() {
    this.setState({ showOverlay: !this.state.showOverlay });
  }

  hasOverlay() {
    const overlayPlugin = this.getOverlayPlugin();
    const play_next_feed_url = R.path(
      ["item", "extensions", "play_next_feed_url"],
      this.props
    );
    return overlayPlugin && play_next_feed_url;
  }

  getOverlayPlugin() {
    return R.compose(
      R.find(R.propEq("type", "player_overlay")),
      R.prop("plugins")
    )(this.props);
  }

  getAudioPlayerConfig() {
    const { Player = {} } = this.props;
    return R.prop("__plugin_configuration", Player);
  }

  renderOverlay() {
    const { item, navigator } = this.props;
    const { configuration, module: OverlayPluginComponent } =
      this.getOverlayPlugin() || {};
    const isPlayNextFeed = !!item.extensions?.play_next_feed_url;

    if (isPlayNextFeed) {
      return (
        <OverlayPluginComponent
          playableItem={item}
          configuration={configuration}
          navigator={navigator}
          dismissOverlay={(cb = noop) => {
            if (this._isMounted) {
              this.setState({ showOverlay: false }, cb);
            }
          }}
        />
      );
    }
  }

  render() {
    const { item = {}, Player } = this.props;
    const uri = R.path(["content", "src"], item) || null;
    const PlayerControls = this.getPlayerControls();

    const { title, summary, type } = item;

    const isAndroidTv = getPlatform() === "android_tv";

    const { value: contentType } = type;
    const isAudioContent = contentType === "audio";

    const {
      playerState,
      advertismentPlaying,
      showOverlay,
      error,
      loadedVideo,
      fullscreen,
      muted,
      paused,
      autoplay,
      rate,
      selectedAudioTracks,
      selectedTextTracks,
      textTracks,
      volume,
    } = this.state;

    const isPlayerLoading =
      playerState === "waiting" || playerState === "loadstart";
    const isPlayerError = playerState === "error";

    return (
      <TVEventHandlerComponent tvEventHandler={this.playerRemoteHandler}>
        { isAndroidTv && showOverlay && this.renderOverlay()}

        {isAndroidTv && isAudioContent && (
          <AudioPlayer
            audio_item={item}
            plugin_configuration={this.getAudioPlayerConfig()}
          />
        )}

        {isAndroidTv &&
          this.showPlayerControls() &&
          this.renderPlayerControls(PlayerControls)}

        <View style={style}>
          <Player
            source={{
              uri,
              entry: item,
            }}
            playerEvent={this.playerEvent}
            playableItem={item}
            fullscreen={fullscreen}
            ref={this.assignPlayerRef}
            muted={muted}
            paused={paused}
            autoplay={autoplay}
            rate={rate}
            selectedAudioTracks={selectedAudioTracks}
            selectedTextTracks={selectedTextTracks}
            textTracks={textTracks}
            volume={volume}
            controls={!PlayerControls}
            onEnded={this.onEnded}
            onPlay={this.onPlay}
            onPause={this.onPause}
            onVideoBuffer={this.updatePlayerState}
            onRatechange={this.onRatechange}
            updatePlayerState={this.updatePlayerState}
          />
          {!isAndroidTv && loadedVideo && showOverlay && this.renderOverlay()}

          {!isAndroidTv && !isPlayerLoading && isAudioContent && (
            <AudioPlayer
              audio_item={item}
              plugin_configuration={this.getAudioPlayerConfig()}
            />
          )}

          {paused && !advertismentPlaying && !PlayerControls && (
            <ProgramInfo
              isAudioContent={isAudioContent}
              title={title}
              subtitle={summary}
            />
          )}
          
          {!isAndroidTv &&
            loadedVideo &&
            !showOverlay &&
            this.showPlayerControls() &&
            this.renderPlayerControls(PlayerControls)}

          {isPlayerError && <ErrorDisplay error={error} />}
          {isPlayerLoading && <BufferAnimation />}
        </View>
      </TVEventHandlerComponent>
    );
  }
}
