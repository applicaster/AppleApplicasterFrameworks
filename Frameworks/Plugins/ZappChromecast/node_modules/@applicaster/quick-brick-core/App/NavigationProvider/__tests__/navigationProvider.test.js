import React from "react";
import { View } from "react-native";
import { create, act } from "react-test-renderer";

import { useNavigation } from "@applicaster/zapp-react-native-utils/reactHooks/navigation";

import { NavigationProvider } from "../NavigationProvider";

const rivers = {
  A1234: {
    id: "A1234",
    navigations: [],
    ui_components: [],
  },
  B4567: {
    home: true,
    id: "B4567",
    navigations: [],
    ui_components: [],
  },
  C0987: {
    id: "C0987",
    navigations: [],
    ui_components: [],
    hooks: {
      postload_plugins: [],
      preload_plugins: [
        {
          screen_id: "hook_screen",
          identifier: "test-hook",
          type: "general",
          weight: 7,
        },
        {
          screen_id: "hook_screen2",
          identifier: "test-hook2",
          type: "general",
          weight: 7,
        },
      ],
    },
  },
  D6543: {
    id: "D6543",
    navigations: [],
    ui_components: [],
    hooks: {
      preload_plugins: [
        {
          screen_id: "failing_hook_screen",
          identifier: "failing-hook",
          type: "general",
          weight: 0,
        },
      ],
    },
  },
  hook_screen: {
    id: "hook_screen",
    type: "test-hook",
    general: {
      allow_screen_plugin_presentation: true,
    },
  },
  hook_screen2: {
    id: "hook_screen2",
    type: "test-hook2",
    general: {
      allow_screen_plugin_presentation: true,
    },
  },
  failing_hook_screen: {
    id: "failing_hook_screen",
    type: "failing-hook",
    general: {
      allow_screen_plugin_presentation: true,
    },
  },
};

// eslint-disable-next-line react/prop-types
const HookComponent = ({ callback, payload, ...otherProps }) => {
  if (payload?.id === "D6543") {
    callback({ success: false, payload });
    return null;
  }
  callback({ success: true, payload });
  return <View />;
};

const hookPlugin = {
  module: {
    Component: HookComponent,
    presentFullScreen: true,
  },
  type: "general",
  identifier: "test-hook",
  name: "Test Hook",
};

const hookPlugin2 = {
  module: {
    Component: HookComponent,
    presentFullScreen: true,
  },
  type: "general",
  identifier: "test-hook2",
  name: "Test Hook 2",
};

const failingHook = {
  module: {
    Component: HookComponent,
    presentFullScreen: true,
    isFlowBlocker: () => true,
  },
  type: "general",
  identifier: "failing-hook",
  name: "failing hook",
};

const ContextConsumer = () => {
  const { state, ...navigator } = useNavigation();

  const renderHook = () => {
    if (navigator.currentRoute.includes("/hooks/")) {
      const { hookPlugin, payload, callback } = navigator.routeData();
      const Component = hookPlugin.module.Component;

      return <Component payload={payload} callback={callback} />;
    }

    return null;
  };

  return (
    <View navigator={navigator} state={state}>
      {renderHook()}
    </View>
  );
};

const props = {
  rivers,
  plugins: [hookPlugin, hookPlugin2, failingHook],
};

describe("<NavigationProvider />", () => {
  let wrapper;

  it("renders correctly", () => {
    act(() => {
      wrapper = create(
        <NavigationProvider {...props}>
          <ContextConsumer />
        </NavigationProvider>
      );
    });

    expect(wrapper.toJSON()).toMatchSnapshot();
  });

  describe("navigator Properties", () => {
    act(() => {
      wrapper = create(
        <NavigationProvider {...props}>
          <ContextConsumer />
        </NavigationProvider>
      );
    });

    const view = wrapper.root.findByType(View);
    const { navigator } = view.props;

    it("exposes the active river", () => {
      expect(navigator.activeRiver).toEqual(rivers.B4567);
    });

    it("exposes the currentRoute", () => {
      expect(navigator.currentRoute).toEqual("/river/B4567");
    });

    it("exposes the previous action", () => {
      expect(navigator.previousAction).toEqual("REPLACE");
    });

    it("exposes a routeData function", () => {
      expect(navigator.routeData()).toEqual(rivers.B4567);
    });
  });

  describe("pushing a new route", () => {
    act(() => {
      wrapper = create(
        <NavigationProvider {...props}>
          <ContextConsumer />
        </NavigationProvider>
      );
    });

    const view = wrapper.root.findByType(View);

    it("sets the data to that route", () => {
      act(() => view.props.navigator.push(rivers.A1234));
      expect(view.props.navigator).toHaveProperty("activeRiver", rivers.A1234);
      expect(view.props.navigator).toHaveProperty(
        "currentRoute",
        "/river/B4567/river/A1234"
      );
      expect(view.props.navigator.routeData()).toEqual(rivers.A1234);
      expect(view.props.state.stack).toBeArrayOfSize(2);
    });
  });

  describe("replacing a current route", () => {
    act(() => {
      wrapper = create(
        <NavigationProvider {...props}>
          <ContextConsumer />
        </NavigationProvider>
      );
    });

    const view = wrapper.root.findByType(View);

    it("sets the data to that route", () => {
      act(() => view.props.navigator.replace(rivers.A1234));
      expect(view.props.navigator).toHaveProperty("activeRiver", rivers.A1234);
      expect(view.props.navigator).toHaveProperty(
        "currentRoute",
        "/river/A1234"
      );
      expect(view.props.navigator.routeData()).toEqual(rivers.A1234);
      expect(view.props.state.stack).toBeArrayOfSize(1);
    });
  });

  describe("going back", () => {
    describe("when there is no previous route", () => {
      act(() => {
        wrapper = create(
          <NavigationProvider {...props}>
            <ContextConsumer />
          </NavigationProvider>
        );
      });

      const view = wrapper.root.findByType(View);

      it("returns false when calling canGoBack", () => {
        let result;

        act(() => {
          result = view.props.navigator.canGoBack();
        });

        expect(result).toBe(false);
      });

      it("stays on the current route", () => {
        act(() => view.props.navigator.goBack());
        expect(view.props.navigator).toHaveProperty(
          "activeRiver",
          rivers.B4567
        );
        expect(view.props.navigator).toHaveProperty(
          "currentRoute",
          "/river/B4567"
        );
        expect(view.props.navigator.routeData()).toEqual(rivers.B4567);
        expect(view.props.state.stack).toBeArrayOfSize(1);
      });
    });

    describe("when there is one route and we're going in a hook", () => {
      act(() => {
        wrapper = create(
          <NavigationProvider {...props}>
            <ContextConsumer />
          </NavigationProvider>
        );
      });

      const view = wrapper.root.findByType(View);
      act(() => view.props.navigator.replace(rivers.A1234));

      it("returns true when calling goBack()", () => {
        act(() => view.props.navigator.push(rivers.C0987));
        expect(view.props.state.stack.length).toBeGreaterThan(1);
        expect(view.props.navigator.canGoBack()).toEqual(true);
      });

      // this test is skipped as it doesn't work on this version of react
      // where we can't properly test async actions within components
      it.skip("returns to the previous route when the hook is cancelled", () => {
        act(() => view.props.navigator.replace(rivers.A1234));
        act(() => view.props.navigator.push(rivers.D6543));

        expect(view.props.navigator).toHaveProperty(
          "activeRiver",
          rivers.A1234
        );
        expect(view.props.navigator).toHaveProperty(
          "currentRoute",
          "/river/A1234"
        );
        expect(view.props.navigator.routeData()).toEqual(rivers.A1234);
        expect(view.props.state.stack).toBeArrayOfSize(1);
      });
    });

    describe("when there is a previous route", () => {
      act(() => {
        wrapper = create(
          <NavigationProvider {...props}>
            <ContextConsumer />
          </NavigationProvider>
        );
      });

      const view = wrapper.root.findByType(View);

      act(() => view.props.navigator.push(rivers.A1234));
      act(() => view.props.navigator.push(rivers.B4567));

      it("returns true when calling canGoBack", () => {
        let result;

        act(() => {
          result = view.props.navigator.canGoBack();
        });

        expect(result).toBe(true);
      });

      it("returns to the previous route", () => {
        expect(view.props.state.stack).toBeArrayOfSize(3);

        act(() => view.props.navigator.goBack());

        expect(view.props.navigator).toHaveProperty(
          "activeRiver",
          rivers.A1234
        );
        expect(view.props.navigator).toHaveProperty(
          "currentRoute",
          "/river/B4567/river/A1234"
        );
        expect(view.props.navigator.routeData()).toEqual(rivers.A1234);
        expect(view.props.state.stack).toBeArrayOfSize(2);
      });
    });

    describe("when there is a previous route and there are hooks", () => {
      act(() => {
        wrapper = create(
          <NavigationProvider {...props}>
            <ContextConsumer />
          </NavigationProvider>
        );
      });

      const view = wrapper.root.findByType(View);
      act(() => view.props.navigator.push(rivers.A1234));
      act(() => view.props.navigator.push(rivers.C0987));

      it("returns to the previous entry in the stack which is not a hook", () => {
        expect(view.props.state.stack).toBeArrayOfSize(5);
        expect(view.props.navigator).toHaveProperty(
          "currentRoute",
          "/river/B4567/river/A1234/river/C0987"
        );
        expect(view.props.navigator.routeData()).toEqual(rivers.C0987);

        act(() => view.props.navigator.goBack());

        expect(view.props.state.stack).toBeArrayOfSize(2);
        expect(view.props.navigator).toHaveProperty(
          "currentRoute",
          "/river/B4567/river/A1234"
        );
        expect(view.props.navigator.routeData()).toEqual(rivers.A1234);
      });
    });
  });

  describe("when changing navBar visibility", () => {
    act(() => {
      wrapper = create(
        <NavigationProvider {...props}>
          <ContextConsumer />
        </NavigationProvider>
      );
    });

    const view = wrapper.root.findByType(View);

    it("updates the navbar visibility attribute", () => {
      act(() => view.props.navigator.hideNavBar());
      expect(view.props.state.navBar.visible).toBe(false);
      expect(view.props.navigator.isNavBarVisible).toBe(false);
    });
  });

  describe("set the navbar title", () => {
    act(() => {
      wrapper = create(
        <NavigationProvider {...props}>
          <ContextConsumer />
        </NavigationProvider>
      );
    });

    const view = wrapper.root.findByType(View);

    it("updates the navbar title attribute", () => {
      const screenTitle = "Screen Title";
      act(() => view.props.navigator.setScreenTitle(screenTitle));
      expect(view.props.state.navBar.title).toBe(screenTitle);
      expect(view.props.navigator.screenTitle).toBe(screenTitle);
    });
  });

  describe("set the navbar summary", () => {
    act(() => {
      wrapper = create(
        <NavigationProvider {...props}>
          <ContextConsumer />
        </NavigationProvider>
      );
    });

    const view = wrapper.root.findByType(View);

    it("updates the navbar summary attribute", () => {
      const screenSummary = "Screen Summary";
      act(() => view.props.navigator.setScreenSummary(screenSummary));
      expect(view.props.state.navBar.summary).toBe(screenSummary);
      expect(view.props.navigator.screenSummary).toBe(screenSummary);
    });
  });
});
