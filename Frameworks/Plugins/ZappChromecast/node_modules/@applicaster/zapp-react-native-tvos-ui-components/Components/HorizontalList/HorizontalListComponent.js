// @flow
import * as React from "react";
import * as R from "ramda";

import { BaseFlatList } from "../BaseFlatList";
import {
  flatListParams,
  customCellStyle,
  containerStyle,
  focusableGroupStyle,
} from "./styles";
import { ContainerWrapperView } from "../ContainerWrapperView";

import { Header } from "../Header";
import { FocusableGroup } from "@applicaster/zapp-react-native-ui-components/Components/FocusableGroup";
import { FixedFocusScrollableList } from "../FixedFocusScrollableList";
import { BaseCell } from "../BaseCell";
import { itemLimitForData } from "@applicaster/zapp-react-native-ui-components/Helpers/DataSourceHelper";

type State = {
  shouldSetContentFlex: boolean,
};

type Props = {
  CellRenderer: React.componentType<{ item: Object, state: string }>,
  isScreenWrappedInContainer: boolean,
  remoteConfigurations: { styles: {} },
};

export class HorizontalListComponent extends BaseFlatList<Props, State> {
  constructor(props) {
    super(props);
    this.state = {
      shouldSetContentFlex: false,
    };
    this.componentFocused = false;
    this.flatListRef = null;
    this.renderCell = this.renderCell.bind(this);
    this.updateContentOffset = this.updateContentOffset.bind(this);
    this.onLayout = this.onLayout.bind(this);
    this.dataSource = null;
  }

  onLayout(e) {
    const { x, y, width, height } = e.nativeEvent.layout;
    this.viewFrame = { x, y, width, height };
    this.updateContentFlexIfNeeded();
  }

  onContentSizeChange(contentWidth: number, contentHeight: number) {
    super.onContentSizeChange(contentWidth, contentHeight);
    this.updateContentFlexIfNeeded();
  }

  onFocus(event, index, groupId, itemId) {
    super.onFocus(event, index, groupId, itemId);
    this.updateContentOffset(index);
  }

  customOffsetForIndex(index) {
    const { paddingVertical = 0, marginTop = 0 } = focusableGroupStyle;
    return paddingVertical + marginTop + this.headerHeight;
  }

  shouldSetContentFlexFlag() {
    const {
      state: { shouldSetContentFlex },
      contentWidth,
      viewFrame: { width },
    } = this;

    return (
      !shouldSetContentFlex &&
      contentWidth !== 0 &&
      width !== 0 &&
      contentWidth <= width
    );
  }

  updateContentFlexIfNeeded() {
    if (this.shouldSetContentFlexFlag()) {
      this.setState({ shouldSetContentFlex: true });
    } else {
      // TODO: Uncommit it to start fixing bug where selection wrong item
      // if (this.componentFocused === false) {
      //   let savedInitialFocusedItemIndex = this.getSavedInitialFocusedItemIndex(
      //     this.dataSource
      //   );
      //   this.componentFocused = true;
      //   savedInitialFocusedItemIndex &&
      //     this.updateContentOffset(savedInitialFocusedItemIndex, false);
      // }
    }
  }

  contentInset() {
    if (this.props.isScreenWrappedInContainer) {
      return { top: 0, left: 0, bottom: 0, right: 0 };
    } else {
      return flatListParams.contentInset;
    }
  }

  contentOffset() {
    if (this.props.isScreenWrappedInContainer) {
      return { x: 0, y: 0 };
    } else {
      return flatListParams.contentOffset;
    }
  }

  updateContentOffset(index, animated = true) {
    const { zappPipesData, component } = this.props;
    const { data: entries } = zappPipesData;
    const { entry } = entries;
    const contentInset = this.contentInset();
    const contentOffset = this.contentOffset();
    const { contentWidth, viewFrame } = this;
    // Retrive full item count

    const itemLimit =
      R.path(["rules", "item_limit"], component) || Number.MAX_SAFE_INTEGER;

    // Calculate item limit
    const itemsCount = R.compose(
      R.min(itemLimit),
      R.length,
      R.defaultTo([]),
      R.keys
    )(entry);

    // Get width of one item
    const itemWidth = customCellStyle.width;

    // Calculate items can be on screen
    const itemsOnScreen = (viewFrame.width - contentInset.left) / itemWidth;
    // If items less that can be suited on screen, do not scroll

    if (itemsOnScreen > itemsCount) {
      return;
    }
    // Index of the item that have custom offset.
    // This in case on screen less items than can be scrolled. This allow to keep all items on screen
    const cusomOffsetItemIndex = itemsCount - Math.floor(itemsOnScreen);

    // If index with custom offset
    if (cusomOffsetItemIndex === index) {
      // Calculate new index
      let newOffset = contentWidth - itemWidth * itemsOnScreen;
      this.scrollToOffset(newOffset, animated);

      // Items that use default offset calculation before custom offoset
    } else if (cusomOffsetItemIndex >= index) {
      // Calculate new index
      let newOffset = contentOffset.x + itemWidth * index;
      this.scrollToOffset(newOffset, animated);
      // Else all items that after custom offset does not need to scroll, since cell reach end of the list
    }
  }

  scrollToOffset(offset, animated = true) {
    this.flatListRef && this.flatListRef.scrollToOffset({ offset, animated });
  }

  customFlatListParams() {
    return {
      ...flatListParams,
      contentContainerStyle:
        this.state.shouldSetContentFlex === true ? { flex: 1 } : null,
    };
  }

  renderCell({ item, index }) {
    const {
      CellRenderer,
      component: { id },
      componentPositionIndex,
    } = this.props;

    const { onFocus, onPress } = this;

    return (
      <BaseCell
        index={index}
        item={item}
        key={index}
        onPress={onPress}
        onFocus={onFocus}
        groupId={id}
        CellRenderer={CellRenderer}
        componentPositionIndex={componentPositionIndex}
      />
    );
  }

  prepareDataSource() {
    const {
      component,
      zappPipesData: { data },
    } = this.props;
    const { entry } = data;

    if (!this.dataSource) {
      this.dataSource = itemLimitForData(entry, component);
    }
    return this.dataSource;
  }

  render() {
    const {
      component,
      zappPipesData: { data },
      isScreenWrappedInContainer,
    } = this.props;

    const {
      id,
      styles: { header },
    } = component;

    this.props.onLoadFinished();
    const dataSource = this.prepareDataSource();

    const shouldHideComponent = !dataSource || dataSource.length === 0;

    if (shouldHideComponent) {
      // eslint-disable-next-line no-console
      console.warn(
        `component ${component.id} was ignored because its datasource is empty`,
        { dataSource: data }
      );
      return null;
    }

    return (
      <FocusableGroup
        onLayout={this.onLayout}
        style={focusableGroupStyle}
        id={id}
      >
        {header.visible && (
          <Header
            configuration={component.styles}
            {...header}
            item={data}
            isScreenWrappedInContainer={isScreenWrappedInContainer}
          />
        )}
        <ContainerWrapperView
          style={containerStyle}
          flatListParams={this.customFlatListParams()}
        >
          {args => (
            <FixedFocusScrollableList
              {...args}
              data={dataSource}
              renderCell={this.renderCell}
              onContentSizeChange={this.onContentSizeChange}
              onPress={this.onPress}
              onFocus={this.onFocus}
              setFlatListRef={flatListRef => (this.flatListRef = flatListRef)}
            />
          )}
        </ContainerWrapperView>
      </FocusableGroup>
    );
  }
}
