import React from "react";
import { View } from "react-native";
import { shallow } from "enzyme";
import { shallowToJson } from "enzyme-to-json";

import { AnimatedChild } from "../index";

const TestComponent = jest.fn(props => <View {...props} />);
TestComponent.displayName = "TestComponent";

const props = {
  animationConfig: {},
  currentStyles: animatedValue => ({
    opacity: animatedValue.interpolate({
      inputRange: [0, 1],
      outputRange: [1, 0],
    }),
  }),
  nextStyles: animatedValue => ({
    opacity: animatedValue.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
    }),
  }),
  containerStyles: {},
};

describe("<AnimatedChild />", () => {
  it("renders correctly", () => {
    const wrapper = shallow(
      <AnimatedChild {...props}>
        <TestComponent foo="bar" />
      </AnimatedChild>
    );

    expect(shallowToJson(wrapper)).toMatchSnapshot();
  });

  it("identifies children change based on key change", () => {
    const wrapper = shallow(
      <AnimatedChild {...props}>
        <TestComponent foo="bar" />
      </AnimatedChild>
    );

    expect(
      wrapper
        .instance()
        .childHasChanged(
          { children: { key: "foo" } },
          { children: { key: "bar" } }
        )
    ).toBe(true);

    expect(
      wrapper
        .instance()
        .childHasChanged(
          { children: { key: "foo" } },
          { children: { key: "foo" } }
        )
    ).toBe(false);
  });

  describe("when children changes", () => {
    const wrapper = shallow(
      <AnimatedChild {...props}>
        <TestComponent foo="bar" />
      </AnimatedChild>
    );

    let animateSpy;
    let childHasChangedSpy;

    beforeEach(() => {
      jest.useFakeTimers();
      animateSpy = jest.spyOn(wrapper.instance(), "animate");
      childHasChangedSpy = jest
        .spyOn(wrapper.instance(), "childHasChanged")
        .mockImplementation(() => true);
    });

    afterEach(() => {
      jest.clearAllTimers();
      animateSpy.mockRestore();
      childHasChangedSpy.mockRestore();
    });

    it("adds a the new children in the state", () => {
      wrapper.setProps({
        children: <TestComponent foo="baz" />,
      });

      expect(childHasChangedSpy).toHaveBeenCalled();
      expect(animateSpy).toHaveBeenCalled();
    });
  });

  describe("animationEnded", () => {
    const wrapper = shallow(
      <AnimatedChild {...props}>
        <TestComponent foo="bar" />
      </AnimatedChild>
    );

    it("resets the animatedValue, and sets the current children in state", () => {
      wrapper.instance().animationEnded();
      expect(wrapper.state()).toMatchSnapshot();
    });
  });
});
