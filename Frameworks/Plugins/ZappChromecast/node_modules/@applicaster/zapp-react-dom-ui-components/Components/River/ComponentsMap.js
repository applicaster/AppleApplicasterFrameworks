import * as React from "react";
import * as R from "ramda";

import { applyDecorators } from "@applicaster/zapp-react-native-ui-components/Decorators";
import { ComponentResolver } from "@applicaster/zapp-react-native-ui-components/Components/ComponentResolver";
import { objFromListWith } from "@applicaster/zapp-react-native-utils/objectUtils";

import { RiverContainer } from "./RiverContainer";

type Props = {
  riverComponents: [{}],
  feed: ?string,
  feed: string,
  isScreenWrappedInContainer: boolean,
  groupId: string,
};

export class ComponentsMap extends React.Component<Props> {
  constructor(props: Props) {
    super(props);
    this.componentIsLoaded = this.componentIsLoaded.bind(this);
    this.renderRiverComponent = this.renderRiverComponent.bind(this);

    this.riverComponents = R.compose(
      objFromListWith(R.prop("id")),
      R.map(R.pick(["id", "position"]))
    )(props.riverComponents);
  }

  riversAreLoaded() {
    const riverComponentIds = R.compose(
      R.map(R.prop("id")),
      R.prop("riverComponents")
    )(this.props);

    return R.compose(
      R.all(R.prop("loaded")),
      R.filter((riverComponent) =>
        riverComponentIds.includes(riverComponent.id)
      )
    )(this.riverComponents);
  }

  getFeedUrl(feed, index) {
    try {
      const feedUrl = R.path(["entry", index, "content", "src"], feed);
      return (R.contains || R.includes)("fetchData?", feedUrl) ? feedUrl : null;
    } catch (error) {
      return null;
    }
  }

  componentIsLoaded(id) {
    this.riverComponents[id].loaded = true;
  }

  renderRiverComponent(component, index) {
    const { id } = component;

    if (!this.riverComponents[component.id]) {
      this.riverComponents[component.id] = R.pick(
        ["id", "position"],
        component
      );
    }

    const { feed, isScreenWrappedInContainer, groupId } = this.props;

    const feedUrl = this.getFeedUrl(feed, index);

    return (
      <ComponentResolver
        key={index}
        component={component}
        decorators={applyDecorators}
      >
        {(Component, CellRenderer) => {
          return (
            <Component
              key={id}
              isScreenWrappedInContainer={isScreenWrappedInContainer}
              component={component}
              componentIndex={index}
              CellRenderer={CellRenderer}
              onLoadFinished={() => this.componentIsLoaded(component.id)}
              groupId={groupId}
              feedUrl={feedUrl}
            />
          );
        }}
      </ComponentResolver>
    );
  }

  hasScreenPicker() {
    const { riverComponents } = this.props;

    return R.compose(
      R.includes("screen_picker"),
      R.map(R.prop("component_type"))
    )(riverComponents);
  }

  render() {
    const { riverComponents, isScreenWrappedInContainer } = this.props;
    return (
      <RiverContainer
        isScreenWrappedInContainer={isScreenWrappedInContainer}
        marginTopOffset={this.hasScreenPicker() ? -100 : 0}
      >
        {riverComponents.map(this.renderRiverComponent)}
      </RiverContainer>
    );
  }
}
