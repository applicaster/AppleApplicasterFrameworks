// @flow
import * as React from "react";
import * as R from "ramda";

import { Focusable } from "@applicaster/zapp-react-native-ui-components/Components/Focusable";
import { getItemType } from "@applicaster/zapp-react-native-utils/navigationUtils";
import { SCREEN_TYPES } from "@applicaster/zapp-react-native-utils/navigationUtils/itemTypes";
import { focusManager } from "@applicaster/zapp-react-native-utils/appUtils/focusManager";
import { sendSelectCellEvent } from "@applicaster/zapp-react-native-utils/analyticsUtils";

type Props = {
  item: {
    id: string,
    title: string,
  },
  index: number,
  shouldScrollHorizontally: ?([any]) => boolean,
  shouldScrollVertically: ?([any]) => boolean,
  riverOffsetUpdater: (string, number) => number,
  offsetUpdater: (string, number) => number,
  componentId: string,
  component: {},
  selected: boolean,
  CellRenderer: React.componentType<{ item: Object, state: string }>,
  hasPreferredFocus: boolean,
  navigator: {
    push: ({}) => void,
  },
  onFocus: ?(any) => void,
  onBlur: ?(any) => void,
  onPress: ?(any) => void,
  willReceiveFocus: ?(any) => void,
  hasReceivedFocus: ?(any) => void,
  hasHeader: boolean,
  isScreenWrappedInContainer: ?boolean,
};

const offsets = {
  inContainerVerticalOffset: 230,
  vertical: 350,
  horizontal: 114,
};

const headerHeight = 42 + 48;

export class CellComponent extends React.Component<Props> {
  constructor(props) {
    super(props);
    this.onPress = this.onPress.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.willReceiveFocus = this.willReceiveFocus.bind(this);
    this.hasReceivedFocus = this.hasReceivedFocus.bind(this);
  }

  onPress() {
    const { onPress, item, index } = this.props;

    if (onPress) {
      onPress(item, index);
    } else {
      const { item, navigator, component } = this.props;
      const itemTargetScreen = R.path(["screen_type"], item);
      const componentTargetScreen = R.path(["data", "target"], component);
      const itemType = getItemType(item);

      sendSelectCellEvent(item, component, item.title, index);
      if (
        itemType !== SCREEN_TYPES.PLAYABLE &&
        componentTargetScreen &&
        !itemTargetScreen
      ) {
        navigator.push(R.merge(item, { screen_type: componentTargetScreen }));
        return;
      }
      navigator.push(item);
    }
  }

  onFocus(focusable) {
    const {
      item: { id, title },
      shouldScrollHorizontally,
      shouldScrollVertically,
      riverOffsetUpdater,
      offsetUpdater,
      hasHeader,
      isScreenWrappedInContainer,
    } = this.props;

    const offsetToUse = isScreenWrappedInContainer
      ? offsets.inContainerVerticalOffset
      : offsets.vertical;
    const verticalOffset = offsetToUse + (hasHeader ? headerHeight : 0);

    if (
      shouldScrollVertically &&
      shouldScrollVertically(focusable, id, title)
    ) {
      riverOffsetUpdater("vertical", verticalOffset - focusable.getRect().top);
    }

    if (
      shouldScrollHorizontally &&
      shouldScrollHorizontally(focusable, id, title)
    ) {
      const parent = focusManager.getGroupById(focusable.props.groupId);
      const parentRect = parent ? parent.getRect() : { left: 0 };
      const leftOffset = isScreenWrappedInContainer ? 0 : offsets.horizontal;

      offsetUpdater(
        "horizontal",
        leftOffset + parentRect.left - focusable.getRect().left
      );
    }
  }

  onBlur() {}

  willReceiveFocus() {}

  hasReceivedFocus() {}

  render() {
    const {
      item,
      index,
      selected,
      componentId,
      offsetUpdater,
      hasPreferredFocus,
      CellRenderer,
      onFocus,
      onBlur,
      willReceiveFocus,
      hasReceivedFocus,
    } = this.props;

    const { id } = item;
    const cellState = selected ? "selected" : "default";

    return (
      <Focusable
        id={`${id}-${index}`}
        groupId={componentId}
        onFocus={onFocus || this.onFocus}
        onBlur={onBlur || this.onBlur}
        onPress={this.onPress}
        willReceiveFocus={willReceiveFocus || this.willReceiveFocus}
        hasReceivedFocus={hasReceivedFocus || this.hasReceivedFocus}
        hasPreferredFocus={hasReceivedFocus || this.hasReceivedFocus}
        preferredFocus={hasPreferredFocus}
        offsetUpdater={offsetUpdater}
      >
        {(focused) => (
          <CellRenderer item={item} state={focused ? "focused" : cellState} />
        )}
      </Focusable>
    );
  }
}
