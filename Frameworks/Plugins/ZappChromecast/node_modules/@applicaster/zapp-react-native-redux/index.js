import {
  createStore,
  applyMiddleware,
  combineReducers,
  bindActionCreators,
  compose,
} from "redux";
import { connect } from "react-redux";
import thunk from "redux-thunk";
import { composeWithDevTools } from "remote-redux-devtools";
import * as R from "ramda";

import appContext, { loadAppContext } from "./AppContext";
import zappPipes, { setZappPipesAdapter } from "./ZappPipes";
import { appState } from "./appState";

/**
 * returns current enviroment
 *
 * @returns {string} enviroment
 */
export function getEnv() {
  if (process && process.env && process.env.NODE_ENV === "test") {
    return "test";
  }

  if (__DEV__) {
    return "development";
  }

  return "production";
}

/**
 * Creates the redux store for the Zapp App
 *
 * @export
 * @param {Object} options
 * @param {Object} options.additionalReducers optional map of reducers to add to the store
 * @param {Array<Function>} options.additionalMiddlewares optional array of middlewares to add to the store
 * @param {Object} options.initialState optional initial state to pass to the store
 * @param {String} options.env optional environment flag to pass to the store
 * @returns {Object} redux store
 */
export function createZappReduxStore({
  additionalReducers = {},
  additionalMiddlewares = [],
  initialState = {},
  env = getEnv(),
}) {
  setZappPipesAdapter();

  const reducers = combineReducers({
    ...additionalReducers,
    styles: appContext("styles"),
    rivers: appContext("rivers"),
    plugins: appContext("plugins"),
    components: appContext("components"),
    cellStyles: appContext("cellStyles"),
    appSettings: appContext("appSettings"),
    localizations: appContext("localizations"),
    pluginConfigurations: appContext("pluginConfigurations"),
    remoteConfigurations: appContext("remoteConfigurations"),
    zappPipes,
    appState,
  });

  const middlewares = [thunk, ...additionalMiddlewares];

  const reduxComposer =
    __DEV__ || process.env.NODE_ENV !== "production"
      ? composeWithDevTools
      : compose;

  return createStore(
    reducers,
    initialState,
    reduxComposer(applyMiddleware(...middlewares))
  );
}

/**
 * Loads app context data (styles, components, plugins, rivers) in the redux store
 *
 * @export
 * @param {*} dispatch function from the initialized redux store
 * @param {*} appContext app context data to load in the store
 */
export function loadAppContextData(dispatch, appContext) {
  // Here we want to iterate over the appContext object, and for each property (context name)
  // we want to load the corresponding context (appContext[property])
  // the loadAppContext signature is loadAppContext(contextName)(contextData) whereas
  // the signature of the contextMapper function is contextMapper(contextData, contextName).
  // Therefore, we use Ramda's flip function to switch argument order, and Ramda's uncurryN
  // function to align loadAppContext's signature to the contextMapper's signature
  // Then all we need is to dispatch the action, and we're good to go
  const contextMapper = R.compose(
    dispatch,
    // composition is left inline here since Ramda forces subsequent composed functions to be unary
    R.flip(R.uncurryN(2, loadAppContext))
  );

  R.forEachObjIndexed(contextMapper, appContext);
}

/**
 * Connects a component to the redux store
 *
 * @export
 * @param {Function} [mapStateToProps=() => ({})]: mapStateToProps function
 * @param {Object} [actions={}] map of action functions to bind
 * @returns {Function} connector function to apply to a component
 */
export function connectToStore(mapStateToProps, actions = {}) {
  const mapDispatchToProps = dispatch => ({
    ...bindActionCreators(actions, dispatch),
    dispatch,
  });

  return connect(mapStateToProps, mapDispatchToProps);
}
