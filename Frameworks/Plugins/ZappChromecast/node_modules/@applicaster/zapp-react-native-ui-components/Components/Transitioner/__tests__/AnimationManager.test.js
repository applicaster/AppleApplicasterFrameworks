import { AnimationManager } from "../AnimationManager";
import { NAV_ACTION_PUSH, NAV_ACTION_BACK } from "../Transitioner";

const DURATION = 123;

const singleTransitionConfig = {
  duration: DURATION,
  easing: jest.fn(),
  from: {
    style: {},
  },
  to: {
    style: {},
  },
};

function transitionConfig(animatedValue) {
  return {
    push: singleTransitionConfig,
    back: singleTransitionConfig,
  };
}

const animationManager = new AnimationManager({ transitionConfig });

describe("AnimationManager", () => {
  it("returns the animation manager with the injected transition configuration", () => {
    expect(animationManager).toMatchSnapshot();
    expect(animationManager.config).toMatchSnapshot();
    expect(animationManager.config.back).toEqual(singleTransitionConfig);
  });

  it("throws an error when the transitionConfig is not a proper function", () => {
    expect(() => {
      new AnimationManager(); // eslint-disable-line no-new
    }).toThrow();

    expect(() => {
      new AnimationManager({}); // eslint-disable-line no-new
    }).toThrow();
  });

  describe("initialState()", () => {
    it("returns a state composed from the initial configuration", () => {
      const initialState = animationManager.initialState();

      expect(initialState).toMatchSnapshot();
      expect(initialState.duration).toEqual(DURATION);
      expect(initialState.from.index).toEqual(initialState.to.index);
      expect(initialState.to.style).toEqual(singleTransitionConfig.to.style);
    });
  });

  describe("stateForAction()", () => {
    it("returns a matching state for the push action", () => {
      const state = { to: { index: 555 } };

      const stateForPush = animationManager.stateForAction(
        state,
        NAV_ACTION_PUSH
      );

      expect(stateForPush.animating).toEqual(true);
      expect(stateForPush.easing).toEqual(singleTransitionConfig.easing);
      expect(stateForPush.from.index).toEqual(state.to.index);
      expect(stateForPush.to.index).toEqual(state.to.index + 1);
    });

    it("returns a matching state for the back action when state has multiple scenes", () => {
      const state = { scenes: [{}, {}, {}, {}, {}], to: { index: 4 } };

      const stateForBack = animationManager.stateForAction(
        state,
        NAV_ACTION_BACK
      );

      expect(stateForBack.animating).toEqual(true);
      expect(stateForBack.from.index).toEqual(state.to.index);
      expect(stateForBack.to.index).toEqual(state.to.index - 1);
    });

    it("set from.index=1 and to.index=0 when state has a single scene", () => {
      const state = { scenes: [{}], to: { index: 0 } };

      const stateForBack = animationManager.stateForAction(
        state,
        NAV_ACTION_BACK
      );

      expect(stateForBack.animating).toEqual(true);
      expect(stateForBack.from.index).toEqual(1);
      expect(stateForBack.to.index).toEqual(0);
    });
  });

  describe("animate()", () => {
    it.skip("calls Animated.timing with the data provided in the state", () => {});
    it.skip("runs the callback when the animation ends", () => {});
  });
});
