import * as R from "ramda";
import * as pluginUtils from "../index";

const pluginMock = (name, identifier, type) => ({
  type,
  identifier,
  name,
  module: jest.fn(),
});

describe("findComponentByType", () => {
  const TestComponent = jest.fn();
  const TestComponent2 = jest.fn();
  const components = { TestComponent };
  const plugins = [
    {
      module: TestComponent2,
      type: "ui_component",
      name: "Test Component",
      identifier: "test-component-2",
    },
  ];

  const decorator1 = jest.fn(R.assoc("decoratedWithD1", "yes"));
  const decorator2 = jest.fn(R.assoc("decoratedWithD2", "yes"));

  const TestComponentDecoratedWith1 = decorator1(TestComponent);
  const TestComponentDecoratedWith1And2 = R.compose(
    decorator2,
    decorator1
  )(TestComponent);

  const TestComponent2DecoratedWith1 = decorator1(TestComponent2);
  const TestComponent2DecoratedWith1And2 = R.compose(
    decorator2,
    decorator1
  )(TestComponent2);

  const { findComponentByType } = pluginUtils;

  beforeEach(() => {
    decorator1.mockClear();
    decorator2.mockClear();
  });

  describe("when component is in Components", () => {
    const componentType = "test_component";

    beforeEach(() => {
      decorator1.mockClear();
      decorator2.mockClear();
    });

    it("returns the component without decoration if no decorator is provided", () => {
      const result = findComponentByType({ components, componentType });
      expect(result).toEqual(TestComponent);
    });

    it("gets the component from the map and apply the provided decorator", () => {
      const decorators = decorator1;

      const result = findComponentByType({
        components,
        componentType,
        decorators,
      });

      expect(result).toEqual(TestComponentDecoratedWith1);
      expect(decorator1).toHaveBeenCalledWith(TestComponent);
      expect(decorator2).not.toHaveBeenCalled();
    });

    it("gets the component from the map and apply the multiple decorators", () => {
      const decorators = [decorator1, decorator2];

      const result = findComponentByType({
        components,
        componentType,
        decorators,
      });

      expect(result).toEqual(TestComponentDecoratedWith1And2);
      expect(decorator1).toHaveBeenCalledWith(TestComponent);
      expect(decorator2).toHaveBeenCalledWith(TestComponentDecoratedWith1);
    });

    it("returns undefined if the component doesn't exist", () => {
      const result = findComponentByType({ components, componentType: "foo" });

      expect(result).toBeUndefined();
      expect(decorator1).not.toHaveBeenCalled();
      expect(decorator2).not.toHaveBeenCalled();
    });
  });

  describe("when component is in plugins", () => {
    const componentType = "test-component-2";
    beforeEach(() => {
      decorator1.mockClear();
      decorator2.mockClear();
    });

    it("finds the plugin", () => {
      const result = findComponentByType({
        componentType,
        components,
        plugins,
      });
      expect(result).toEqual(TestComponent2);
    });

    it("applies the decorators", () => {
      const decorators = [decorator1, decorator2];

      const result = findComponentByType({
        componentType,
        components,
        plugins,
        decorators,
      });

      expect(result).toEqual(TestComponent2DecoratedWith1And2);
      expect(decorator1).toHaveBeenCalledWith(TestComponent2);
      expect(decorator2).toHaveBeenCalledWith(TestComponent2DecoratedWith1);
    });
  });
});

describe("findPluginByIdentifier", () => {
  const { findPluginByIdentifier } = pluginUtils;

  const plugins = {
    foo: pluginMock("foo", "foo", "some_plugin_type"),
    bar: pluginMock("foo", "bar", "some_plugin_type"),
  };

  it("returns the plugin if it exists", () => {
    expect(findPluginByIdentifier("foo", plugins)).toEqual(plugins.foo);
  });

  it("returns undefined otherwise", () => {
    expect(findPluginByIdentifier("do_not_exist", plugins)).toBeUndefined();
  });
});

describe("findPluginByType", () => {
  const { findPluginByType } = pluginUtils;

  const plugins = {
    foo: pluginMock("foo", "foo", "nav_bar"),
    bar: pluginMock("foo", "bar", "article"),
    player: pluginMock("bar", "player", "player"),
  };

  it("returns the plugin if it exists", () => {
    expect(findPluginByType("nav_bar", plugins)).toEqual(plugins.foo.module);
  });

  it("returns undefined otherwise", () => {
    expect(findPluginByType("menu", plugins)).toBeUndefined();
  });

  it("finds the right plugin type through the map if applicable", () => {
    expect(findPluginByType("playable", plugins)).toEqual(
      plugins.player.module
    );
  });
});

describe("getNavigationPlugin", () => {
  const { getNavigationPlugin } = pluginUtils;

  const plugins = {
    menu: pluginMock("menu", "unique_id_1", "side_menu"),
    foo: pluginMock("foo", "unique_id_2", "article"),
  };

  const navigations = [
    { category: "nav_bar", navigation_type: "navigation_bar", nav_items: [] },
    { category: "menu", navigation_type: "side_menu", nav_items: [] },
  ];

  const defaultNavigationComponents = {
    Menu: jest.fn(),
    NavBar: jest.fn(),
  };

  it("returns the plugin if it exists", () => {
    expect(
      getNavigationPlugin({
        category: "menu",
        navigations,
        plugins,
        defaultNavigationComponents,
      })
    ).toEqual(plugins.menu.module);
  });

  it("returns the default component if provided and found", () => {
    expect(
      getNavigationPlugin({
        category: "nav_bar",
        navigations,
        plugins,
        defaultNavigationComponents,
      })
    ).toEqual(defaultNavigationComponents.NavBar);
  });

  it("returns undefined otherwise", () => {
    expect(
      getNavigationPlugin({ category: "navigation_bar", navigations, plugins })
    ).toBeUndefined();
  });
});

describe("findScreenPlugin", () => {
  const { findScreenPlugin } = pluginUtils;
  const someScreenPlugin = pluginMock(
    "someScreenPlugin",
    "unique_screen_plugin_id",
    "general"
  );
  const plugins = [
    someScreenPlugin,
    pluginMock("otherPlugin", "other_unique_id", "data_source_provider"),
  ];

  it("finds the plugin and returns its module", () => {
    expect(findScreenPlugin("some-screen-plugin")(plugins)).toEqual(
      someScreenPlugin.module
    );
  });
});
