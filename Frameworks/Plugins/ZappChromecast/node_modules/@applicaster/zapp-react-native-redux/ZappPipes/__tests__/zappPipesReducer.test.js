import configureStore from "redux-mock-store";
import thunk from "redux-thunk";
import * as R from "ramda";
import * as zappPipesModule from "@applicaster/zapp-react-native-bridge/ZappPipes";

import reducer, {
  ZAPP_PIPES_REQUEST_START,
  ZAPP_PIPES_REQUEST_COMPLETE,
  ZAPP_PIPES_REQUEST_FAIL,
  zappPipesRequestStart,
  zappPipesRequestComplete,
  zappPipesRequestFail,
  loadPipesData,
  zappPipesSelector,
  getZappPipesData,
  setZappPipesAdapter,
} from "../index";

const mockStore = configureStore([thunk]);
const dataSourceUrl = "some://url";
const data = { type: { value: "feed" }, entry: [{ type: "video" }] };
const initialState = {
  plugins: [{ type: "data_source_provider", module: "module" }],
  zappPipes: {},
};

const initialLoadedState = {
  ...initialState,
  zappPipes: { [dataSourceUrl]: data },
};

const error = { message: "request failed" };
const meta = { flag: true };

jest.spyOn(zappPipesModule, "bootstrapZappPipes").mockImplementation(() => ({
  get: jest.fn((url, cb) =>
    cb({
      code: 200,
      url,
      response: { type: { value: "feed" }, entry: [{ type: "video" }] },
    })
  ),
}));

describe("zappPipesRequestStart", () => {
  it("returns the proper action", () => {
    const action = zappPipesRequestStart(dataSourceUrl);
    expect(action).toHaveProperty("type", ZAPP_PIPES_REQUEST_START);
    expect(action).toHaveProperty("payload", { dataSourceUrl });
  });
});

describe("zappPipesRequestComplete", () => {
  it("returns the proper action", () => {
    const action = zappPipesRequestComplete(dataSourceUrl, data);
    expect(action).toHaveProperty("type", ZAPP_PIPES_REQUEST_COMPLETE);
    expect(action).toHaveProperty("payload", { dataSourceUrl, data });
  });

  it("accepts a meta property", () => {
    const action = zappPipesRequestComplete(dataSourceUrl, data, meta);
    expect(action).toHaveProperty("meta", meta);
  });
});

describe("zappPipesRequestFail", () => {
  it("returns the proper action", () => {
    const action = zappPipesRequestFail(dataSourceUrl, error);
    expect(action).toHaveProperty("type", ZAPP_PIPES_REQUEST_FAIL);
    expect(action).toHaveProperty("payload", { dataSourceUrl, error });
  });

  it("accepts a meta property", () => {
    const action = zappPipesRequestFail(dataSourceUrl, data, meta);
    expect(action).toHaveProperty("meta", meta);
  });
});

describe("loadPipesData", () => {
  describe("when adapter is not set", () => {
    it("it bootstraps it again", async () => {
      const store = mockStore(initialState);
      await store.dispatch(loadPipesData(dataSourceUrl));

      expect(zappPipesModule.bootstrapZappPipes).toHaveBeenCalled();
      expect.assertions(1);
    });
  });

  describe("when adapter is set", () => {
    beforeEach(() => {
      setZappPipesAdapter(zappPipesModule.bootstrapZappPipes);
    });

    it("returns the proper action", async () => {
      const store = mockStore(initialState);

      await store.dispatch(loadPipesData(dataSourceUrl));
      const actions = store.getActions();

      expect(actions.map(R.prop("type"))).toEqual(
        expect.arrayContaining([
          ZAPP_PIPES_REQUEST_START,
          ZAPP_PIPES_REQUEST_COMPLETE,
        ])
      );

      expect(
        R.find(R.propEq("type", ZAPP_PIPES_REQUEST_START), actions)
      ).toHaveProperty("payload", { dataSourceUrl });

      expect(
        R.find(R.propEq("type", ZAPP_PIPES_REQUEST_COMPLETE), actions)
      ).toHaveProperty("payload", { dataSourceUrl, data });
    });

    it("dispatches the fail action when the request returns a non 200 code", async () => {
      jest
        .spyOn(zappPipesModule, "bootstrapZappPipes")
        .mockImplementation(() => ({
          get: jest.fn((url, cb) =>
            cb({
              code: 400,
              url,
              response: error,
            })
          ),
        }));

      const store = mockStore(initialState);

      const consoleSpy = jest
        .spyOn(console, "warn")
        .mockImplementation(() => ({}));

      await store.dispatch(loadPipesData(dataSourceUrl));
      const actions = store.getActions();
      expect(consoleSpy).toHaveBeenCalled();
      consoleSpy.mockReset();

      expect(actions.map(R.prop("type"))).toEqual([
        ZAPP_PIPES_REQUEST_START,
        ZAPP_PIPES_REQUEST_FAIL,
      ]);

      const failAction = actions.find(
        R.propEq("type", ZAPP_PIPES_REQUEST_FAIL)
      );
      expect(failAction).toHaveProperty("payload", { dataSourceUrl, error });
    });

    it("skips loading if dataSourceUrl is not defined", () => {
      expect(loadPipesData()).toBeUndefined();
    });

    it("skips loading if dataSource is already cached", async () => {
      const store = mockStore(initialLoadedState);
      await store.dispatch(loadPipesData(dataSourceUrl));
      const actions = store.getActions();
      expect(actions).toEqual([]);
    });

    it("does the request again if the `clearCache` option is set to true", async () => {
      const store = mockStore(initialLoadedState);
      await store.dispatch(loadPipesData(dataSourceUrl, { clearCache: true }));
      const actions = store.getActions();
      expect(actions).not.toEqual([]);
      expect(actions).toMatchSnapshot();
    });

    it("forwards the meta property if it is defined", async () => {
      const store = mockStore(initialState);
      await store.dispatch(loadPipesData(dataSourceUrl, { meta }));
      const actions = store.getActions();
      expect(actions.map(R.prop("meta"))).not.toEqual([]);
      expect(actions).toMatchSnapshot();
    });
  });
});

describe("reducer", () => {
  const initialState = {};

  it("adds the loading data flag", () => {
    const nextState = reducer(
      initialState,
      zappPipesRequestStart(dataSourceUrl)
    );

    expect(nextState).toHaveProperty(
      dataSourceUrl,
      expect.objectContaining({
        url: dataSourceUrl,
        loading: true,
      })
    );
  });

  it("adds the data", () => {
    const nextState = reducer(
      initialState,
      zappPipesRequestComplete(dataSourceUrl, data)
    );

    expect(nextState).toHaveProperty(
      dataSourceUrl,
      expect.objectContaining({
        url: dataSourceUrl,
        loading: false,
        data,
      })
    );
  });

  it("adds the error property", () => {
    const nextState = reducer(
      initialState,
      zappPipesRequestFail(dataSourceUrl, error)
    );

    expect(nextState).toHaveProperty(
      dataSourceUrl,
      expect.objectContaining({
        url: dataSourceUrl,
        loading: false,
        error,
      })
    );
  });

  it("does nothing if an unknown action is invoked", () => {
    const nextState = reducer(initialState, { type: "NOOP" });
    expect(nextState).toEqual(initialState);
  });
});

describe("selectors", () => {
  const store = mockStore(initialLoadedState);

  it("retrieves the zappPipes state", () => {
    expect(zappPipesSelector(store.getState())).toEqual(
      initialLoadedState.zappPipes
    );
  });

  it("retrieves a specific data source url", () => {
    expect(getZappPipesData(dataSourceUrl)(store.getState())).toEqual(
      initialLoadedState.zappPipes[dataSourceUrl]
    );
  });
});
