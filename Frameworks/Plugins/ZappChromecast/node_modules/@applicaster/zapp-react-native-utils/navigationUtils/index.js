// @flow
import * as R from "ramda";
import { itemIsOfType, SCREEN_TYPES, getIdResolver } from "./itemTypes";

export type Navigation = {
  category: string,
  navigation_type: string,
  [string]: any,
};

type PluginModule = any;
type Plugin = {
  module: PluginModule,
  type: string,
  name: string,
};
type PluginsMap = { [string]: Plugin };

type PathAttribute = {
  screenType: string,
  screenId: string,
};

/**
 * returns the type of navigation based on a navigation category
 * @param {String} category to look for. can be either "nav_bar" or "menu"
 * @param {Array} navigations array to look for the type
 * @returns {String} navigation type for the selected category
 */
export function getNavigationType(
  category: "nav_bar" | "menu",
  navigations: [Navigation]
): string {
  return R.compose(
    R.unless(R.isNil, R.prop("navigation_type")),
    R.defaultTo(undefined),
    R.find(R.propEq("category", category))
  )(navigations);
}

/**
 * returns the navigation plugin for the given category, and the provided plugins
 * Will return the navigation plugin flagged as default
 * @param {Object} options
 * @param {String} options.category to look for. can be either "nav_bar" or menu
 * @param {Array<Object>} navigations array to look for the type
 * @param {Array<Object>} plugins list to search for the plugin to return
 * @returns {Object} plugin to use
 */
export function resolveNavigationPlugin({
  category,
  navigations,
  plugins,
}: {
  category: "nav_bar" | "menu",
  navigations: [Navigation],
  plugins: PluginsMap,
}): Plugin {
  const navigationType = getNavigationType(category, navigations);
  if (!navigationType) {
    return null;
  }

  const elligiblePlugins = R.filter(
    R.propEq("identifier", navigationType),
    plugins
  );

  if (R.length(elligiblePlugins) === 0) {
    return R.find(R.propEq("type", category), plugins);
  }

  if (R.length(elligiblePlugins) > 1) {
    return R.find(R.compose(R.not, R.prop("default")), elligiblePlugins);
  }

  return R.head(elligiblePlugins);
}

/**
 * returns the navigation props for the provided category, for the given screen
 * @param {Object} navigator to look for navigation props
 * @param {String} category to look for in screen navigations
 * @returns {Object} props
 */
export function getNavigationProps({
  navigator: { activeRiver, screenTitle: title },
  category,
}: {
  navigator: {
    screenTitle: ?string,
    isNavBarVisible: boolean,
    activeRiver: { navigations: [{}], id: string, name: string, home: boolean },
  },
  category: string,
}): ?{} {
  const { navigations, id: selected, home } = activeRiver;
  const navigation = R.find(R.propEq("category", category), navigations);

  if (!navigation) {
    return null;
  }

  const { styles, assets, nav_items, rules } = navigation;
  const result = {
    selected,
    title,
    home,
    styles,
    assets,
    nav_items,
    rules,
  };
  return result;
}

/**
 * Returns the path attributes for a provided location
 * will transform /screenType1/screenId/foo/bar
 * into
    [
      { screenType: "screenType1", screenId: "screenId"},
      { screenType: "foo", screenId: "bar"}
    ]
 * @param {Object} location object
 * @param {String} location.pathname path to get attributes from
 * @returns {Array} PathAttributes array, of the form [{ screenType: String, screenId: String }]
 */
export function getPathAttributes({
  pathname,
}: {
  pathname: string,
}): [PathAttribute] {
  if (pathname === "/" || pathname === "") {
    return [];
  }

  return R.compose(
    // mapping(["foo", "bar"] => { screenType: "foo", screenId: "bar" })
    R.map(R.zipObj(["screenType", "screenId"])),
    // ["foo", "bar", "baz", "qux"] => [["foo", "bar"], ["baz", "qux"]]
    R.splitEvery(2),
    // omitting the first empty element in the array since pathname starts with /
    R.tail,
    // spliting pathname string into array
    R.split("/")
  )(pathname);
}

/**
 * retrieves the type of an item
 * @param {object} item
 * @return {String} type of the item
 */
export function getItemType(item) {
  return R.compose(R.find(itemIsOfType(item)), R.values)(SCREEN_TYPES);
}

/**
 * retrieves a the Id of the item target based on an item and a type
 * @param {object} item
 * @param {string} itemType type of the item
 * @return {string} id of the item target
 */
export function getItemTargetId(item, itemType) {
  return getIdResolver(itemType)(item);
}

/**
 * returns the target route given the provided payload and pathname
 * @param {object} payload data of the item which triggered the navigation
 * @param {string} pathname current location if it exist
 * @returns {string} targetRoute to navigate to
 */
export function getTargetRoute(payload, pathname = "") {
  const screenType = getItemType(payload);
  const screenId = getItemTargetId(payload, screenType);

  const routeForScreenType = screenType === "menu_item" ? "river" : screenType;

  return R.replace("//", "/", `${pathname}/${routeForScreenType}/${screenId}`);
}

/**
 * retrieves the river from the given route, or null if route is not a river route
 * @param {string} route
 * @param {object} rivers
 * @returns {object}
 */
export function getRiverFromRoute({ route, rivers }) {
  const { screenType, screenId } =
    R.compose(
      R.last,
      getPathAttributes,
      R.assoc("pathname", R.__, {})
    )(route) || {};

  if (screenType === "river") {
    return rivers[screenId];
  }

  const pluginScreen = R.compose(
    R.find(R.propEq("type", screenType)),
    R.values
  )(rivers);

  if (pluginScreen) {
    return pluginScreen;
  }

  return screenType && screenId ? { screenType, screenId } : null;
}

/**
 * Function returns true if the previous route (in the react-router history) is a hook plugin
 * @param {*} history - React-Router History Object
 * @return boolean
 */
export function isPreviousRouteHook(entries: [{ pathname: string }]): boolean {
  const previousRoute = entries[entries.length - 2];
  if (!previousRoute) return false;
  return R.test(/\/hooks\/.*/g, previousRoute.pathname);
}

/**
 * Function returns number of consecutive hooks that are behind the current route
 * @param {*} history - React-Router History Object
 * @return true
 */
export function getPreviousHooksCount(history: {
  entries: [{ pathname: string }],
}): number {
  let hooksCount = 0;
  let entries = R.clone(history.entries);

  while (isPreviousRouteHook(entries)) {
    hooksCount++;
    entries = R.init(entries);
  }

  return hooksCount;
}
