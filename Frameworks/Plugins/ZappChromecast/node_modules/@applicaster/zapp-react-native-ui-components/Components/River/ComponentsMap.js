// @flow
import * as React from "react";
import * as R from "ramda";
import { ScrollView, Animated } from "react-native";

import { connectToStore } from "@applicaster/zapp-react-native-redux";
import { objFromListWith } from "@applicaster/zapp-react-native-utils/objectUtils";

import { ComponentResolver } from "../ComponentResolver";
import { applyDecorators } from "../../Decorators";
import { useTheme } from "@applicaster/zapp-react-native-utils/theme";

type Props = {
  feed: ?string,
  groupId: string,
  isScreenWrappedInContainer: boolean,
  riverComponents: [any],
  scrollViewExtraProps: {},
};

function styles(animatedValue) {
  return {
    flex: 1,
    opacity: animatedValue,
  };
}

export function ComponentsMapComponent(props: Props) {
  const theme = useTheme();
  const [animatedValue] = React.useState(new Animated.Value(0));
  const [animated, setAnimated] = React.useState(false);

  const riverComponents = R.compose(
    objFromListWith(R.prop("id")),
    R.map(R.pick(["id", "position"]))
  )(props.riverComponents);

  function riversAreLoaded() {
    const riverComponentIds = R.compose(
      R.map(R.prop("id")),
      R.prop("riverComponents")
    )(props);

    return R.compose(
      R.all(R.prop("loaded")),
      R.filter(riverComponent => riverComponentIds.includes(riverComponent.id))
    )(riverComponents);
  }

  function getFeedUrl(feed, index) {
    try {
      const feedUrl = R.path(["entry", index, "content", "src"], feed);
      return (R.contains || R.includes)("fetchData?", feedUrl) ? feedUrl : null;
    } catch (error) {
      return null;
    }
  }

  // Mark each component in the local riversComponents map as "loaded".
  // When all components are marked as such, apply fade-in opacity animation.
  const componentIsLoaded = id => {
    if (riverComponents[id]) {
      riverComponents[id].loaded = true;
    }

    if (riversAreLoaded() && !animated) {
      setAnimated(true);
      animate();
    }
  };

  const renderRiverComponent = (component, index) => {
    const { id } = component;

    if (!riverComponents[component.id]) {
      riverComponents[component.id] = R.pick(["id", "position"], component);
    }

    const { feed, isScreenWrappedInContainer, groupId } = props;
    const feedUrl = getFeedUrl(feed, index);

    return (
      <ComponentResolver
        key={index}
        component={component}
        decorators={applyDecorators}
      >
        {(Component, CellRenderer) => {
          return (
            <Component
              key={id}
              isScreenWrappedInContainer={isScreenWrappedInContainer}
              component={component}
              componentIndex={index}
              CellRenderer={CellRenderer}
              onLoadFinished={() => componentIsLoaded(component.id)}
              groupId={groupId}
              feedUrl={feedUrl}
            />
          );
        }}
      </ComponentResolver>
    );
  };

  function animate() {
    Animated.timing(animatedValue, {
      toValue: 1,
      duration: 600,
    }).start();
  }
  const { riverComponents: components, scrollViewExtraProps } = props;

  const screenStyle = {
    paddingTop: R.prop("screen_padding_top")(theme),
    paddingBottom: R.prop("screen_padding_bottom")(theme),
    paddingLeft: R.prop("screen_padding_left")(theme),
    paddingRight: R.prop("screen_padding_right")(theme),
  };

  // TODO: support both "isScreenWrappedInContainer" and hasScreenPicker().
  // The Screen Picker in Mobile is completly different than the TV
  // so the various offsets / margins in TV do not apply here.
  return (
    <Animated.View style={styles(animatedValue)}>
      <ScrollView {...scrollViewExtraProps} contentContainerStyle={screenStyle}>
        {components.map(renderRiverComponent)}
      </ScrollView>
    </Animated.View>
  );
}

export const ComponentsMap = connectToStore(R.pick(["cellStyles"]))(
  ComponentsMapComponent
);
