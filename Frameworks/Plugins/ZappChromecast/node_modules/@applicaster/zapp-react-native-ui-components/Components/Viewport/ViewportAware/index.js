// @flow
import * as React from "react";
import * as R from "ramda";
import { UIManager, findNodeHandle } from "react-native";

import { useViewportEventsContext } from "../ViewportEvents";
import * as Utils from "../utils";

type Props = {
  innerRef: (React.Ref<any>) => void,
  preTriggerRatio: Number,
  onViewportEnter: () => void,
  onViewportLeave: () => void,
  children: React.Node,
  name: string,
  testDimensions: {
    componentOffsetX: number,
    componentOffsetY: number,
    componentWidth: number,
    componentHeight: number,
    inViewport: boolean,
  },
};

const initialDimensions = {
  componentOffsetX: null,
  componentOffsetY: null,
  componentWidth: null,
  componentHeight: null,
  inViewport: false,
};

function getTestDimensions(testDimensions) {
  return (process.env.NODE_ENV === "test" && testDimensions) || null;
}

function ViewportAwareComponent(props: Props, ref: React.Ref<any>) {
  const viewportEvents = useViewportEventsContext();

  const {
    preTriggerRatio,
    onViewportEnter,
    onViewportLeave,
    children,
    testDimensions,
  } = props;

  const [state, setState] = React.useReducer(R.merge, initialDimensions);
  const [viewportChangeEvent, setViewportChangeEvent] = React.useState(null);

  const {
    componentOffsetX,
    componentOffsetY,
    componentWidth,
    componentHeight,
    inViewport,
  } = getTestDimensions(testDimensions) || state;

  function assignRef(_ref) {
    if (_ref && !ref) {
      ref = _ref;
    }
  }

  React.useEffect(() => {
    viewportEvents.addListener(onViewportChange);

    viewportChangeEvent &&
      setTimeout(() => onViewportChange(viewportChangeEvent), 50);

    return () => {
      viewportEvents.removeListener(onViewportChange);
    };
  }, []);

  function checkViewportEnterOrLeave(newInViewportState) {
    if (!inViewport && newInViewportState) {
      onViewportEnter && onViewportEnter();
      return true;
    } else if (inViewport && !newInViewportState) {
      onViewportLeave && onViewportLeave();
      return true;
    }
    return false;
  }

  function onViewportChange(viewportChangeEvent) {
    setViewportChangeEvent(viewportChangeEvent);

    const nodeHandle = findNodeHandle(ref);

    if (!nodeHandle) {
      return;
    }

    if (
      viewportChangeEvent.shouldMeasureLayout ||
      componentOffsetX == null ||
      componentOffsetY == null ||
      componentWidth == null ||
      componentHeight == null
    ) {
      UIManager.measureLayout(
        nodeHandle,
        viewportChangeEvent.parentHandle,
        () => {},
        (offsetX, offsetY, width, height) => {
          const inVerticalViewport = Utils.isInViewport(
            viewportChangeEvent.offsetY,
            viewportChangeEvent.height,
            offsetY,
            height,
            preTriggerRatio
          );

          const inHorizontalViewport = Utils.isInViewport(
            viewportChangeEvent.offsetX,
            viewportChangeEvent.width,
            offsetX,
            width,
            preTriggerRatio
          );

          const newInViewportState = inVerticalViewport && inHorizontalViewport;

          checkViewportEnterOrLeave(newInViewportState);

          setState({
            componentOffsetX: offsetX,
            componentOffsetY: offsetY,
            componentWidth: width,
            componentHeight: height,
            inViewport: newInViewportState,
          });
        }
      );
    } else {
      const inVerticalViewport = Utils.isInViewport(
        viewportChangeEvent.viewportOffsetY,
        viewportChangeEvent.viewportHeight,
        componentOffsetY,
        componentHeight,
        preTriggerRatio
      );

      const inHorizontalViewport = Utils.isInViewport(
        viewportChangeEvent.offsetY,
        viewportChangeEvent.viewportWidth,
        componentOffsetX,
        componentWidth,
        preTriggerRatio
      );

      const newInViewportState = inVerticalViewport && inHorizontalViewport;

      if (checkViewportEnterOrLeave(newInViewportState)) {
        setState({ inViewport: newInViewportState });
      }
    }
  }

  return React.cloneElement(React.Children.only(children), {
    ref: assignRef,
  });
}

export const ViewportAware = React.forwardRef(ViewportAwareComponent);
