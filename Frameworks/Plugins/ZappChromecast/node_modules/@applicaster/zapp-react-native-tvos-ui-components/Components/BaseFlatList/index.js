// @flow
import * as React from "react";
import * as R from "ramda";
import { onCellPress } from "@applicaster/zapp-react-native-ui-components/Helpers/ComponentCellSelectionHelper/";
import { focusableItemId } from "@applicaster/zapp-react-native-ui-components/Helpers/ComponentsHelper";

type Props = {
  onLoadFinished: () => void,
  zappPipesData: any,
  cellStyle: ?Array<any>,
  component: {
    id: string,
    styles: {
      header: {
        visible: boolean,
      },
    },
  },
  navigator: {},
  mainOffsetUpdater: any => void,
  componentPositionIndex: number,
  focusableRiverData: {
    groupId: string,
    itemId: string,
    contentOffsetY: number,
    screenFocusableGroupId: string,
    componentId: string,
    itemIndex: number,
  },
};

export class BaseFlatList extends React.Component<Props> {
  constructor(props) {
    super(props);

    this.viewFrame = { x: 0, y: 0, width: 0, height: 0 };
    this.contentWidth = 0;
    // Temp solution until Simon will add support header size in CellBuilder
    // or move it to some default + optional style key
    const headerHeight = 60;
    const headerMarginBottom = 10;
    this.headerHeight = props.component.styles.header.visible
      ? headerHeight + headerMarginBottom
      : 0;

    this.onPress = this.onPress.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onContentSizeChange = this.onContentSizeChange.bind(this);
    this.customOffsetForIndex = this.customOffsetForIndex.bind(this);
  }

  onPress(e, index) {
    const { zappPipesData, navigator, component } = this.props;

    const entry = R.path(["data", "entry", index], zappPipesData) || {};
    const headerTitle = R.path(["data", "title"], zappPipesData) || "";
    entry && onCellPress(entry, navigator, component, headerTitle, index);
  }

  onFocus(event, index, groupId, itemId) {
    const {
      component: { id: componentId },
    } = this.props;
    this.props.mainOffsetUpdater(
      event,
      this.customOffsetForIndex(index),
      this.viewFrame,
      groupId,
      itemId,
      componentId,
      index
    );
  }

  customOffsetForIndex(index) {
    return this.headerHeight;
  }

  onContentSizeChange(contentWidth, contentHeight) {
    this.contentWidth = contentWidth;
  }

  headerStyles() {
    const { component } = this.props;
    return component && R.path(["styles", "header"], component);
  }

  savedDataForComponent() {
    const {
      component: { id: componentId },
      focusableRiverData,
    } = this.props;
    if (focusableRiverData && focusableRiverData.componentId === componentId) {
      const {
        groupId,
        itemId,
        contentOffsetY,
        screenFocusableGroupId,
        componentId,
        itemIndex,
      } = focusableRiverData;
      return {
        groupId,
        itemId,
        contentOffsetY,
        screenFocusableGroupId,
        componentId,
        itemIndex,
      };
    }
    return null;
  }

  getSavedInitialFocusedItemIndex(dataSourceArray) {
    const focusableRiverData = this.savedDataForComponent();

    let savedInitialFocusedItemIndex = null;

    if (dataSourceArray && focusableRiverData) {
      const mappedIndexFunc = R.addIndex(R.findIndex);
      savedInitialFocusedItemIndex = mappedIndexFunc((model, index) => {
        const currenItemId = focusableItemId(model, index);
        return currenItemId === focusableRiverData.itemId;
      })(dataSourceArray);
    }
    return savedInitialFocusedItemIndex;
  }
}
