import * as R from "ramda";
import { Tree } from "./treeDataStructure/Tree";
import { findPriorityItem, findFocusableNode } from "./treeDataStructure/Utils";
import { subscriber } from "../../functionUtils";

/**
 * The focusManager is meant to keep references of focusables elements in the UI, and provide
 * ways to assign the focus to one of the focusables.
 * Focusables belong in groups (possibly nested), to allow for logical navigation between
 * the Focusables.
 *
 * Focusables and FocusableGroups are created in the UI by using
 * @applicaster/zapp-react-native-ui-components/Components/Focusable and
 * @applicaster/zapp-react-native-ui-components/Components/FocusableGroup
 * See the components documentation for more information regarding available features.
 *
 * when these components are mounted, they automatically register to the focus manager,
 * which is then responsible for providing a deterministic and reliable way to move the
 * focus around, and activate the underlying feature.
 *
 * @returns {Object} focusManager
 * @returns {Function} `focusManager.register` registers a Focusable (item or group)
 * @returns {Function} `focusManager.unregister` unregisters a Focusable (item or group)
 * @returns {Function} `focusManager.moveFocus` moves the focus in a given direction
 * @returns {Function} `focusManager.getCurrentFocus` returns the current focus
 * @returns {Function} `focusManager.setFocus` sets the focus to a specific Focusable item
 * @returns {Function} `focusManager.press` calls the `press` method on the current focus
 */
export const focusManager = (function() {
  // focusable node which currently holds the focus
  let currentFocusNode = null;
  let lastFocusedId = null;
  const eventHandler = subscriber();
  const focusableTree = new Tree(treeLoaded);

  function treeLoaded(val, node) {
    if (val && !currentFocusNode) {
      setInitialFocus();
    }
  }

  /**
   * sets the initial focus when the screen loads, or when focus is lost
   */
  function setInitialFocus() {
    const preferredFocus = findPriorityItem(focusableTree.root.children);

    if (preferredFocus && preferredFocus.length > 0) {
      const focusCandidate = preferredFocus[0];
      const focusableItem = focusCandidate.component;

      if (focusableItem) {
        currentFocusNode = preferredFocus[0];
        focusableItem.willReceiveFocus(focusableItem, null);
        focusableItem && setFocus(preferredFocus[0].id, null);
      }
    }
  }

  /**
   * registers a group in the focus manager. This method is called automatically
   * when a FocusableGroup mounts.
   * If there is no current focus
   * we will try to assign one, taking into consideration wether the group
   * has a preferred focus. If not, it will pick the first focusable which is in the group
   * NB: focusable Items are registered to the focus manager before the groups
   * @private
   * @param {string} id of the focusable group
   * @param {React.Component} component the actual FocusableGroup
   * @returns {React.Component} the registered component
   */
  function registerGroup(id, component) {
    focusableTree.addNode({ id, component });
    return component;
  }

  /**
   * registers a Focusable in the focus manager. This happens before
   * groups are registered, and is called automatically when the
   * Focusable component mounts
   * @private
   * @param {String} id of the Focusable
   * @param {React.Component} component the actual Focusable component
   * @returns {React.Component} the registered component
   */
  function registerItem(id, component) {
    focusableTree.addNode({ id, component });

    if (!currentFocusNode && id === lastFocusedId && !id.includes("menu")) {
      currentFocusNode = focusableTree.findInTree(id);
      component.setFocus(null);
    }
    return component;
  }

  /**
   * unregisters a group. This is called automatically when the underlying component
   * unmounts
   * @private
   * @param {String} id of the group to unregister
   */
  function unregisterGroup(id) {
    focusableTree.findAndRemoveNode(id);
  }

  /**
   * unregisters an item. This is called automatically when the underlying component
   * unmounts.
   * If the component is the current focus, it will set the current focus to null
   * @private
   * @param {String} id of the Focusable to unregister
   */
  function unregisterItem(id) {
    focusableTree.findAndRemoveNode(id);

    if (currentFocusNode && currentFocusNode.id === id) {
      currentFocusNode = null;
      lastFocusedId = id;
    }
  }

  /**
   * Registers a Focusable or a FocusableGroup. This is the function actually called
   * when a Focusable or FocusableGroup is being mounted, and figures out if it needs
   * to register a group or a focusable
   * @public
   * @param {Object} options
   * @param {String} options.id id of the Focusable to register
   * @param {React.Component} options.component underlying React Component
   * @returns {React.Component} the registered component
   */
  function register({ id, component }) {
    const { isGroup = false } = component;
    return isGroup ? registerGroup(id, component) : registerItem(id, component);
  }

  /**
   * Unregisters a Focusable or a Focusable group. This is the function actually called when a
   * Focusable of FocusableGroup is unmounting.
   * @public
   * @param {String} id if the Focusable to unregister
   * @param {Object} options
   * @param {Boolean} options.group tells wether or not the focusable to
   * unregister is a group. defaults to false.
   */
  function unregister(id, { group = false } = {}) {
    group ? unregisterGroup(id) : unregisterItem(id);
  }

  /**
   * Sets the current focus to the provided id. If there is an existing focus, it will
   * blur it first, so all handlers are called properly
   * @private
   * @param {String} id of the focusable to set as currentFocus
   * @param {Object} direction of the navigation, which led to this focus change
   * @param {Object} options
   * @param {Boolean} options.groupFocusedChanged tells wether the focus has moved
   * to another group or not. defaults to false
   */
  function setFocus(id, direction, { groupFocusedChanged = false } = {}) {
    // due to optimisiation it's recommanded to set currentFocusNode before setFocus
    // is called, so there will be no delays on tree search.
    if (currentFocusNode.id !== id) {
      currentFocusNode = focusableTree.findInTree(id);
    }
    if (currentFocusNode && currentFocusNode.parent) {
      currentFocusNode.parent.lastFocusedItem = currentFocusNode.id;
    }
    const currentGroup = getCurrentGroup();
    if (groupFocusedChanged && currentGroup) {
      currentGroup.hasLostFocus(currentGroup, direction);
    }

    focus(direction);
  }

  /**
   * returns the current focusable component
   * @private
   * @returns {React.Component} the current focus
   */
  function getCurrentFocus() {
    return currentFocusNode && currentFocusNode.component
      ? currentFocusNode.component
      : null;
  }

  /**
   * returns the current focusable's group
   * @private
   * @returns {React.Component} the current focus
   */
  function getCurrentGroup() {
    return getGroupById(R.path(["props", "groupId"], getCurrentFocus()));
  }

  /**
   * returns a group from a group Id.
   * @private
   * @param {String} groupId id of the group
   * @returns {React.Component} matching group
   */
  function getGroupById(groupId) {
    const group = focusableTree.findInTree(groupId);
    return group ? group.component : null;
  }

  /**
   * calls the `blur` method on the current focus component
   * @private
   * @param {Object} direction of the navigation which led to this action
   */
  function blur(direction) {
    const currentFocusable = getCurrentFocus();
    if (
      currentFocusable &&
      !currentFocusable.isGroup &&
      currentFocusable.isMounted()
    ) {
      currentFocusable.blur(direction);
      currentFocusable.hasLostFocus(getCurrentFocus(), direction);
    }
  }

  /**
   * calls the `focus` method on the current focus component
   * @private
   * @param {Object} direction of the navigation which led to this action
   */
  function focus(direction) {
    const currentFocusable = getCurrentFocus();
    if (
      currentFocusable &&
      !currentFocusable.isGroup &&
      currentFocusable.isMounted()
    ) {
      currentFocusable.setFocus(direction);
    }
  }

  /**
   * calls the `press` method on the current focus component
   * @public
   */
  function press() {
    const currentFocusable = getCurrentFocus();
    if (currentFocusable) {
      currentFocusable.press(null);
    }
  }

  /**
   * moves the focus in a provided direction
   * @public
   * @param {Object} direction of the scroll
   */
  function moveFocus(direction) {
    if (currentFocusNode) {
      currentFocusNode.component.willLoseFocus(currentFocusNode, direction);
      const nextFocusable = findFocusableNode(direction, currentFocusNode);
      if (
        nextFocusable &&
        nextFocusable.component &&
        nextFocusable.component.isMounted()
      ) {
        const nextRrect = nextFocusable.component.getRect();
        if (nextRrect && nextRrect.width > 0) {
          nextFocusable.component.willReceiveFocus(
            nextFocusable.component,
            direction
          );
          blur(direction);
          const groupChanged =
            nextFocusable.component.props.groupId !==
            currentFocusNode.component.props.groupId;
          currentFocusNode = nextFocusable;
          setFocus(nextFocusable.id, direction, groupChanged);
        }
      } else {
        currentFocusNode.component.failedLostFocus(currentFocusNode, direction);
      }
    } else {
      setInitialFocus();
    }
  }

  const { on, invokeHandler, removeHandler } = eventHandler;

  /**
   * this is the list of the functions available externally
   * when importing the focus manager
   */
  return {
    register,
    unregister,
    moveFocus,
    getCurrentFocus,
    getGroupById,
    setFocus,
    press,
    on,
    invokeHandler,
    removeHandler,
  };
})();
