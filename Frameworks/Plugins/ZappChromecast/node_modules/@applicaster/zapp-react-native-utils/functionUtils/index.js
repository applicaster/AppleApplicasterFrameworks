import * as R from "ramda";

/**
 * standard debounce function.
 * @param {Object} options
 * @param {Function} options.fn function to debounce
 * @param {Number} options.wait debounce duration in ms. defaults to 200
 * @param {Boolean} options.immediate will trigger immediately instead of after wait
 * @param {Object} options.context context to apply the functions on
 * @param {Function} debounced function
 */
export function debounce({ fn, wait = 200, immediate = true, context }) {
  let timeout;

  return function debounced(...args) {
    const that = context || this;

    function callLater() {
      timeout = null;
      if (!immediate) {
        fn.apply(that, args);
      }
    }

    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(callLater, wait);

    if (callNow) {
      fn.apply(that, args);
    }
  };
}

/**
 * a function that does nothing
 */
export function noop() {}

/**
 * returns if passed value is a function
 * @param {*} functionToCheck to add the subscription feature on
 * @returns {Bool} subscriber object
 */
export function isFunction(functionToCheck) {
  return functionToCheck ? typeof functionToCheck === "function" : false;
}

/**
 * returns a subscribe object to which handlers can be attached
 * @param {Object} obj to add the subscription feature on
 * @returns {Object} subscriber object
 */
export function subscriber(obj = {}) {
  let handlers = {};

  /**
   * creates a dispose function to remove handlers on a given event
   * @param {string} event to dispose handlers for
   * @param {function} handler to remove
   * @returns {function} to dispose handlers
   */
  function dispose(event, handler) {
    /**
     * function to invoke to remove a handler on an event.
     * handlers are invoked with this function as last argument
     * @param {object} options
     * @param {boolean} options.disposeAll if set to true, will
     * remove all handlers on the object
     */
    return function({ disposeAll = false } = {}) {
      if (disposeAll) {
        handlers = {};
        return;
      }
      handlers[event] = R.reject(R.equals(handler), handlers[event] || []);
    };
  }

  /**
   * adds a handler for a specific event
   * @param {string} event to trigger the handler
   * @param {function} handler to invoke
   * @returns {object} returns `this` so that handlers declaration
   * can be chained
   */
  obj.on = function(event, handler) {
    handlers[event] = R.append(handler, handlers[event] || []);

    return obj;
  };

  /**
   * invokes handlers for a specific event with the provided args
   * will append the dispose function as last argument to the handler
   * @param {string} event for which handlers should be invoked
   * @param {Array<Any>} args variadic list args of args to invoke the handlers with
   * @returns {object} returns `this` so handlers invocation can be chained
   */
  obj.invokeHandler = function(event, ...args) {
    R.compose(
      R.forEach(handler => handler(...args, dispose(event, handler))),
      R.defaultTo([]),
      R.prop(event)
    )(handlers);

    return obj;
  };

  obj.removeHandler = function(event, handler) {
    handlers[event] = R.reject(R.equals(handler), handlers[event]);

    return obj;
  };

  return obj;
}

/**
 * tries to parse a json. if it fails returns the initial value
 * @param {Any} data
 * @returns {any}
 */
export const parseJsonIfNeeded = R.tryCatch(JSON.parse, R.flip(R.identity));

/**
 * map function which works with async functions. Has the same signature as Ramda's map
 * function, but allows async functions, and will return a promise
 * @param {Function} fn function to run
 * @param {[Any]} arr to run the async function unto
 * @returns {Promise<[Any]>} a promise which resolves to an array
 */
export const mapAsync = R.curry(async (fn, arr) => {
  return await R.compose(promises => Promise.all(promises), R.map(fn))(arr);
});
