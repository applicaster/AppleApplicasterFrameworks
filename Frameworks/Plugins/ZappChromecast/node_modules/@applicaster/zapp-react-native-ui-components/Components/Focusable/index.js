// @flow
import * as React from "react";
import * as R from "ramda";

import { BaseFocusable } from "../BaseFocusable";

type Props = {
  initialFocus: ?boolean,
  id: string,
  groupId: string,
  node: {},
  preferredFocus: ?boolean,
  onFocus: ({}) => void,
  onBlur: ?({}) => void,
  onPress: ({}) => void,
  children: (boolean, string) => React.ComponentType<any>,
  selected: ?boolean,
};

export class Focusable extends BaseFocusable<Props> {
  constructor(props) {
    super(props);

    this.isGroup = false;
    this.preferredFocus = this.preferredFocus.bind(this);
  }

  /**
   * indicates whether the underlying component should claim preferred focus
   * when navigating into the group of this item
   * @returns {boolean}
   */
  isPreferredFocus() {
    return this.preferredFocus();
  }
  /**
   * Sets the focus on this item. Will trigger sequentially a sequence of
   * functions (willReceiveFocus, focus, hasReceivedFocus). If these functions (defined in the Focusable
   * Item underlying component) return promises, execution will wait before it proceeds to the next. This
   * is useful for trigerring sequential operations that specifically require to fully run before or after
   * focus is actually set on that item.
   * @param {string} scrollDirection string representation of the direction of the navigation which landed
   * to this item being focused
   */
  setFocus(scrollDirection) {
    const focusMethods = [
      this.willReceiveFocus,
      this.focus,
      this.hasReceivedFocus,
    ];

    const self = this;

    return R.reduce(
      (sequence, method) => {
        return sequence
          .then(() => method.apply(self, [scrollDirection]))
          .catch((e) => {
            throw e;
          });
      },
      Promise.resolve(),
      focusMethods
    );
  }

  /**
   * will invoke the underlying component's focus method
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  focus(scrollDirection) {
    return this.onFocus(this, scrollDirection); // invokeComponentMethod(this, "onFocus", scrollDirection);
  }
  /**
   * will invoke the underlying component's blur method
   * @param {Object} scrollDirection
   * @returns {Promise}
   */
  blur(scrollDirection) {
    return this.onBlur(this, scrollDirection);
  }

  /**
   * will invoke the underlying component's press method
   * @param {Object} keyEvent
   * @returns {Promise}
   */
  press(keyEvent) {
    return this.onPress(keyEvent);
  }

  preferredFocus() {
    return this.props.preferredFocus || false;
  }

  render() {
    const { children, groupId, id, style } = this.props;
    const { focused } = this.state;

    const focusableId = `focusable-${groupId}-${id}`;

    return (
      <div
        id={focusableId}
        ref={this.ref}
        data-testid={focusableId}
        focused-teststate={focused ? "focused" : "default"}
        style={style}
      >
        {children(focused, id)}
      </div>
    );
  }
}
