// @flow
import * as R from "ramda";
import { toPascalCase, toCamelCase } from "../stringUtils";

import { getNavigationType } from "../navigationUtils";
import { deprecationMessage } from "../appUtils";

import type { Navigation } from "../navigationUtils";

type PluginModule = any;
type Plugin = {
  module: PluginModule,
  type: string,
  name: string,
  identifier: string,
};
type PluginsMap = { [string]: Plugin };

/**
 * returns the component if it exists, returns undefined otherwise. also decorates
 * the component with the decorators if provided.
 */
export function findComponentByType({
  componentType,
  components,
  decorators = R.identity,
  plugins = [],
}) {
  const applyDecorators = Array.isArray(decorators)
    ? R.compose(...R.reverse(decorators))
    : decorators;

  const component = getComponentModule({ componentType, components, plugins });

  return R.unless(R.isNil, applyDecorators)(component);
}

/**
 * returns the component module for a specific type
 * Will look in components first, then in plugins
 * @param {*} param0
 */
function getComponentModule({
  componentType,
  components,
  plugins,
}: {
  componentType: string,
  components: ComponentsMap,
  plugins: [Plugin],
}) {
  const component = R.compose(
    R.prop(R.__, components),
    toPascalCase
  )(componentType);

  if (component) {
    return component;
  }

  return R.compose(
    R.prop("module"),
    R.defaultTo({}),
    R.find(R.propEq("identifier", componentType))
  )(plugins);
}

/**
 * Returns the plugin for a given identifier, if found
 * @param {String} identifier of the plugin to look for
 * @param {Object} plugins map of the available plugins
 * @return {Plugin?} whole plugin if found, undefined otherwise
 */
export function findPluginByIdentifier(
  identifier: string,
  plugins: PluginsMap
): ?Plugin {
  if (!identifier) {
    return undefined;
  }

  return R.compose(
    R.find(R.propEq("identifier", identifier)),
    R.values
  )(plugins);
}

/**
 * returns the plugin module for a given type, if found
 * @param {String} type of the plugin to look for
 * @param {Object} plugins map of the available plugins
 * @return {Function?} plugin module found, if any, undefined otherwise
 */
export function findPluginByType(
  type: string,
  plugins: PluginsMap
): ?PluginModule {
  const { module: pluginModule, configuration } =
    R.compose(
      R.find(R.propEq("type", pluginTypeForItemTypeMapper(type))),
      R.values
    )(plugins) || {};

  if (!pluginModule) {
    return undefined; // eslint-disable-line no-undefined
  }

  pluginModule.__plugin_configuration = configuration;

  return pluginModule;
}

const pluginTypeForItemTypeMap = {
  playable: "player",
};

/**
 * return the type of plugin required for a type of item
 * when names don't match (see map above)
 * @param {String} itemType requested
 * @returns {String} matching result in the map above. returns the input otherwise
 */
function pluginTypeForItemTypeMapper(itemType) {
  return R.when(
    R.has(R.__, pluginTypeForItemTypeMap),
    R.prop(R.__, pluginTypeForItemTypeMap)
  )(itemType);
}

type Component = any;
type ComponentsMap = { [string]: Component };

/**
 * returns a navigation plugin based on its type. if not found, returns undefined
 * @deprecated will be removed in next major version. Use NavigationUtils.resolveNavigationPlugin instead
 * @param {Object} options to provide to the function
 * @param {String} options.category of navigation plugin to look for - can be either nav_bar or menu
 * @param {[Object]} options.navigations navigations data to look for plugin type
 * @param {Object} options.plugins map of available plugins
 * @param {Object} options.defaultNavigationComponents map of default components to use (optional)
 * @return {Function?} plugin module found, if any
 */
export function getNavigationPlugin({
  category,
  navigations,
  plugins,
  defaultNavigationComponents = {},
}: {
  category: "nav_bar" | "menu",
  navigations: [Navigation],
  plugins: PluginsMap,
  defaultNavigationComponents: ComponentsMap,
}): any {
  deprecationMessage(
    "@applicaster/zapp-react-native-utils/PluginUtils.getNavigationPlugin",
    "@applicaster/zapp-react-native-utils/NavigationUtils.resolveNavigationPlugin"
  );

  return (
    findPluginByType(getNavigationType(category, navigations), plugins) ||
    defaultNavigationComponents[toPascalCase(category)]
  );
}

/**
 * retrieves a Screen Plugin from the plugins array
 * curried function `findScreenPlugin(type)(plugins)`
 * @param {string} type type of the plugin to look for.
 * will be camelCased, and matched to the name property in the plugins
 * @param {[Object]} plugins array of plugins to look into.
 * @param {Function} plugins[].module React component for the plugin
 * @param {string} plugins[].name name of the plugin
 * @param {string} plugins[].type type of the plugin
 * @return {Function} the plugin's module property (React component)
 */
export function findScreenPlugin(type) {
  return function(plugins) {
    return R.compose(
      R.prop("module"),
      R.find(R.propEq("name", toCamelCase(type)))
    )(plugins);
  };
}
