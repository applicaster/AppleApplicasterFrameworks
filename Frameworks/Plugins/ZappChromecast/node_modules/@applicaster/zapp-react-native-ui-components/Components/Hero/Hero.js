// @flow
import * as React from "react";
import { View, TouchableOpacity, ScrollView, Dimensions } from "react-native";
import * as R from "ramda";

import { Header } from "../Header";

type Props = {
  CellRenderer: React.ComponentType<{ item: Object, state: string }>,
  component: any,
  navigator: {
    push: () => void,
  },
  onLoadFinished: any,
  styles: any,
  zappPipesData: {
    data: {
      entry: [{}],
    },
    loading: Boolean,
  },
};

const heroStyles = {
  container: {
    flex: 1,
  },
  indicatorContainer: {
    marginTop: -42,
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
  },
  bullet: {
    borderWidth: 1,
    backgroundColor: "#666",
    borderColor: "#666",
    height: 12,
    width: 12,
    borderRadius: 17,
    margin: 6,
  },
  currentBullet: {
    backgroundColor: "#eee",
    borderColor: "#eee",
  },
};

export class HeroComponent extends React.PureComponent<Props> {
  constructor(props) {
    super(props);

    this.onScroll = this.onScroll.bind(this);
    this.navigateTo = this.navigateTo.bind(this);
    this.renderHeader = this.renderHeader.bind(this);
    this.renderItem = this.renderItem.bind(this);

    this.width = Dimensions.get("window").width;
    this.state = { itemIndex: 0, selected: undefined };
  }

  renderPlaceholder() {
    return null;
  }

  renderHeader() {
    const {
      styles: { header },
    } = this.props.component;

    if (header.visible) {
      const title = R.path(["zappPipesData", "data", "title"], this.props);
      return <Header title={title || ""} />;
    }

    return null;
  }

  onScroll({ nativeEvent: { contentOffset, layoutMeasurement } }) {
    const scrollIndex = Math.round(contentOffset.x / layoutMeasurement.width);
    if (this.state.itemIndex !== scrollIndex) {
      this.setState({ itemIndex: scrollIndex });
    }
  }

  navigateTo(item) {
    this.props.navigator.push(item);
  }

  /**
   * Draws a page/carousel indicator over the hero
   * if there is more than one item
   * @param {object} data items to show
   */
  renderPageIndicator(data) {
    if (data.length < 2) {
      return null;
    }

    return (
      <View style={heroStyles.indicatorContainer}>
        {data.map((_item, index) => {
          return (
            <View
              key={index}
              style={[
                heroStyles.bullet,
                index === this.state.itemIndex ? heroStyles.currentBullet : {},
              ]}
            />
          );
        })}
      </View>
    );
  }

  renderItem = (item, index) => {
    const { CellRenderer } = this.props;
    const cellState = item.id === this.state.selected ? "focused" : "default";
    const id = R.has("id", item) ? item.id : "";
    return (
      <TouchableOpacity
        key={index}
        activeOpacity={1.0}
        onPress={() => this.navigateTo(item)}
        onPressIn={() => this.setState({ selected: item.id })}
        onPressOut={() => this.setState({ selected: undefined })}
        testID={`${index}${id}`}
      >
        <CellRenderer item={item} state={cellState} />
      </TouchableOpacity>
    );
  };

  renderComponent(zappPipesData: any) {
    this.props.onLoadFinished();

    const itemLimit = Math.min(
      R.path(["rules", "item_limit"], this.props) || 20,
      20
    );

    const data =
      zappPipesData.data && zappPipesData.data.entry
        ? zappPipesData.data.entry.slice(0, itemLimit)
        : [];

    return (
      <View style={heroStyles.container}>
        {this.renderHeader()}

        <ScrollView
          centerContent
          horizontal
          onScroll={this.onScroll}
          pagingEnabled
          showsHorizontalScrollIndicator={false}
        >
          {data.map((item, index) => this.renderItem(item, index))}
        </ScrollView>
        {this.renderPageIndicator(data)}
      </View>
    );
  }

  render() {
    const { zappPipesData } = this.props;

    return zappPipesData && !zappPipesData.loading
      ? this.renderComponent(zappPipesData)
      : this.renderPlaceholder();
  }
}
