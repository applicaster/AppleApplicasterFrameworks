// @flow
import * as React from "react";
import * as R from "ramda";

import { useActions } from "@applicaster/zapp-react-native-utils/reactHooks/actions";
import { sessionStorage } from "@applicaster/zapp-react-native-bridge/ZappStorage/SessionStorage";
import { getAppData } from "@applicaster/zapp-react-native-bridge/QuickBrick";
import { setAppReady } from "@applicaster/zapp-react-native-redux/appState";

import { getRemoteContextData } from "../remoteContextReloader/getRemoteContextData";

function setAppDataInStorage(appData) {
  return async function (key) {
    try {
      return await sessionStorage.setItem(key, appData[key]);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.warn(
        "skipping initial app data loading in session storage - bridge doesn't exist",
        e
      );

      return Promise.resolve();
    }
  };
}

async function loadAppDataInSessionStorage() {
  const appData = getAppData();
  try {
    return await Promise.all(
      R.compose(R.map(setAppDataInStorage(appData)), R.keys)(appData)
    );
  } catch (e) {
    return Promise.resolve();
  }
}

/**
 * adds a call to the QuikBrickManager to tell the app is ready, reloads remote
 * configuration when not in dev mode, and loads basic app data in the session storage
 * @param {Object} QuickBrickManager
 * @returns {Function}
 */

const useSubscribeToActionProviders = () => {
  const { actions } = useActions() || {};

  const contexts = R.compose(
    R.map(R.path(["module", "context"])),
    R.values
  )(actions);

  let subscriptions = [];
  R.forEach((context) => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const subscription = React.useContext(context);

    if (subscription) {
      subscriptions.push(subscription);
    } else {
      // eslint-disable-next-line no-console
      console.warn("One of your action plugins has an undefined context value");
    }
  })(contexts);

  return subscriptions;
};

const useActionSetters = () => {
  const actionProvidersSubscriptions = useSubscribeToActionProviders();
  if (!actionProvidersSubscriptions.length) return undefined;

  const actionsInitialStateSetters = R.map(R.prop("getInitialState"))(
    actionProvidersSubscriptions
  );
  return actionsInitialStateSetters;
};

async function resolvePromises(loaders, done) {
  try {
    await Promise.all(loaders);
  } catch (error) {
    // eslint-disable-next-line no-console
    console.warn("A loading operation failed: ", error);
  } finally {
    done();
  }
}

type Props = {
  dispatch: () => void,
  testCallback: () => void,
  plugins: [{}],
  appSettings: { runtimeConfigurationUrls: { [string]: string } },
};

export function appLifeCycleManager(appLoader, QuickBrickManager) {
  return function appLifeCycleManagerComponent(Component) {
    return function AppLifeCycleManagerRenderer(props: Props) {
      const actionsInitialStateSetters = useActionSetters();
      // using useLayoutEffect to call the loader just after the DOM render to mimic componentDidMount timing
      React.useLayoutEffect(() => {
        const { dispatch, testCallback, ...state } = props;

        const getState = () => state;

        const loaders = [
          loadAppDataInSessionStorage(),
          appLoader(dispatch, getState),
        ];

        if (!__DEV__) {
          const {
            appSettings: { runtimeConfigurationUrls },
            plugins,
          } = state;

          loaders.push(
            getRemoteContextData(dispatch, runtimeConfigurationUrls, plugins)
          );
        }
        // Adding actions initial setters
        if (actionsInitialStateSetters) {
          R.forEach((setter) => {
            loaders.push(setter());
          })(actionsInitialStateSetters);
        }

        resolvePromises(loaders, () => {
          dispatch(setAppReady());
          QuickBrickManager.sendQuickBrickEvent("quickBrickReady");

          if (process.env.NODE_ENV === "test") {
            testCallback();
          }
        });
      }, []);

      return <Component {...props} />;
    };
  };
}
