// @flow
import * as React from "react";
import { View } from "react-native";
import * as R from "ramda";
import { FocusableGroup } from "@applicaster/zapp-react-native-ui-components/Components/FocusableGroup";
import { BaseFlatList } from "../BaseFlatList";
import { Header } from "../Header";
import { wrapperViewContainer, containerStyle } from "./styles";

import { BaseCell } from "../BaseCell";
import { FixedFocusScrollableList } from "../FixedFocusScrollableList";
import { itemLimitForData } from "@applicaster/zapp-react-native-ui-components/Helpers/DataSourceHelper";
import { focusableItemId } from "@applicaster/zapp-react-native-ui-components/Helpers/ComponentsHelper";
import { ContainerWrapperView } from "../ContainerWrapperView";
import { onCellPress } from "@applicaster/zapp-react-native-ui-components/Helpers/ComponentCellSelectionHelper/";

type State = {
  focusedItem: number,
  prevFocusedItem: number,
  isFocusDisabled: boolean,
  jump: boolean,
};

type Props = {
  CellRenderer: React.componentType<{ item: Object, state: string }>,
  isScreenWrappedInContainer: boolean,
  remoteConfigurations: { styles: {} },
};

const itemsPerPage = 1;
const buffer = itemsPerPage * 2;
const minimumLineSpacing = 0;

export class HeroComponent extends BaseFlatList<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      focusedItem: null,
      prevFocusedItem: null,
      isFocusDisabled: false,
      jump: false,
    };
    this.customOffsetForIndex = this.customOffsetForIndex.bind(this);
    this.onMomentumScrollEnd = this.onMomentumScrollEnd.bind(this);
    this.renderCell = this.renderCell.bind(this);
    this.focusRef = this.focusRef.bind(this);
    this.onLayout = this.onLayout.bind(this);
    this.onCellLayout = this.onCellLayout.bind(this);
    this.dataSourceCount = 0;
    this.dataSource = null;
    this.currentFocusedItem = null;
    this.flatListRef = null;
    this.focusGroupRef = null;
    this.cellWidth = 0;
  }

  onContentSizeChange(contentWidth: number, contentHeight: number) {
    super.onContentSizeChange(contentWidth, contentHeight);
    this.initialScroll();
  }

  onLayout(layoutFrame: Object) {
    const { x, y, width, height } = layoutFrame;
    this.viewFrame = { x, y, width, height };
    this.initialScroll();
  }

  initialScroll() {
    if (
      this.viewFrame.width > 0 &&
      this.contentWidth > 0 &&
      this.dataSourceCount > 1
    ) {
      this.scrollToIndex(this.initialFocusedItem());
    }
  }

  onMomentumScrollEnd(event) {
    const indexToJump = this.calculateNewFocusedIndex(this.currentFocusedItem);
    const mustJump = indexToJump !== this.currentFocusedItem;
    const newFocusIndex = mustJump ? indexToJump : this.currentFocusedItem;
    const oldFocusIndex = mustJump
      ? this.currentFocusedItem
      : this.state.focusedItem;

    const isFocusDisabled = false;
    this.currentFocusedItem = newFocusIndex;

    this.setFocusableGroupFocusDisabled(isFocusDisabled);

    this.setState({
      focusedItem: newFocusIndex,
      prevFocusedItem: oldFocusIndex,
      jump: mustJump,
      isFocusDisabled,
    });
  }

  initialFocusedItem() {
    const dataSourceCountMoreThanOne = this.dataSourceCount > 1;

    let savedInitialFocusedItemIndex = this.getSavedInitialFocusedItemIndex(
      this.dataSource
    );
    if (this.props.isScreenWrappedInContainer) {
      return savedInitialFocusedItemIndex || 0;
    } else {
      return dataSourceCountMoreThanOne
        ? savedInitialFocusedItemIndex || buffer
        : 1;
    }
  }

  onCellLayout({ nativeEvent }) {
    const {
      layout: { width = 0 },
    } = nativeEvent;
    this.cellWidth = width;
  }

  onFocus(event, index, groupId, itemId) {
    super.onFocus(event, index, groupId, itemId);

    const dataSourceCountMoreThanOne = this.dataSourceCount > 1;
    const isFocusDisabled = this.state.isFocusDisabled === false;
    // Safe check to block animation if user scroll fast than RN send events to native to block focus
    if (isFocusDisabled && dataSourceCountMoreThanOne) {
      // Initial focus state, in case tvOS decide to select this component first but default.
      if (
        this.state.focusedItem === null &&
        this.state.prevFocusedItem === null
      ) {
        const focusedItem = this.initialFocusedItem();

        this.setState({ focusedItem });
        this.currentFocusedItem = focusedItem;

        // We are going inside only in case itemes are differ or component must jump
      } else if (this.currentFocusedItem !== index || this.state.jump) {
        this.currentFocusedItem = index;
        // If Must just, scrolling to offset without animation
        if (this.state.jump) {
          this.scrollToIndex(index, false);
          this.setState({
            jump: false,
          });
        } else {
          // Regular scroll with animation and blocking focus until scroll will finish
          const isFocusDisabled = true;
          this.setState({ isFocusDisabled });
          this.setFocusableGroupFocusDisabled(isFocusDisabled);
          this.scrollToIndex(index, true);
        }
      }
    }
  }

  calculatedRealIndex(index) {
    if (this.props.isScreenWrappedInContainer) {
      return index;
    }
    return index - buffer >= 0 ? index - buffer : index;
  }

  onPress(e, index) {
    const calculatedRealIndex = this.calculatedRealIndex(index);
    const { zappPipesData, navigator, component } = this.props;

    const entry =
      R.path(["data", "entry", calculatedRealIndex], zappPipesData) || {};
    const headerTitle = R.path(["data", "title"], zappPipesData) || "";

    entry &&
      calculatedRealIndex != null &&
      onCellPress(
        entry,
        navigator,
        component,
        headerTitle,
        calculatedRealIndex
      );
  }

  calculateNewFocusedIndex(currentIndex) {
    if (!this.props.isScreenWrappedInContainer) {
      if (
        (currentIndex < this.state.prevFocusedItem ||
          !this.state.prevFocusedItem) &&
        currentIndex < buffer
      ) {
        return currentIndex + this.dataSourceCount;
      }

      if (
        (currentIndex > this.state.prevFocusedItem ||
          !this.state.prevFocusedItem) &&
        currentIndex >= buffer + this.dataSourceCount
      ) {
        return currentIndex - this.dataSourceCount;
      }
    }

    return currentIndex;
  }

  customOffsetForIndex(_index) {
    const { paddingVertical = 0, marginTop = 0 } = containerStyle;
    return paddingVertical + marginTop + this.headerHeight;
  }

  scrollToIndex(index, animated = false) {
    const offset = this.offsetForItemAtIndex(index);
    this.flatListRef &&
      this.flatListRef.scrollToOffset({ offset: offset, animated });
  }

  getItemLayout = (data, index) => {
    return {
      length: this.cellWidth,
      offset: this.cellWidth * index,
      index,
    };
  };

  focusRef(component) {
    this.focusGroupRef = component;
  }

  render() {
    const entries = this.prepareDataSource();
    if (!entries || entries.length === 0) {
      return null;
    }

    const {
      zappPipesData: { data },
      component,
      isScreenWrappedInContainer,
    } = this.props;

    const {
      id,
      styles: { header },
    } = component;

    const nextInitialFocusedIndex = this.state.focusedItem;

    this.props.onLoadFinished();
    const initialItemIndex =
      nextInitialFocusedIndex ||
      (isScreenWrappedInContainer || entries.length <= 1 ? 0 : buffer);
    const item =
      entries.length > initialItemIndex ? entries[initialItemIndex] : null;
    return (
      <FocusableGroup
        focusGroupRef={this.focusRef}
        style={containerStyle}
        id={id}
        initialItemId={focusableItemId(item, initialItemIndex)}
        resetFocusToInitialValue={true}
        isManuallyBlockingFocusValue={0.25}
      >
        {header.visible && (
          <Header
            configuration={component.styles}
            {...header}
            item={data}
            isScreenWrappedInContainer={isScreenWrappedInContainer}
          />
        )}
        {entries.length > 1 ? (
          <ContainerWrapperView style={wrapperViewContainer}>
            {() => (
              <FixedFocusScrollableList
                setFlatListRef={flatListRef => (this.flatListRef = flatListRef)}
                extraData={this.state.focusedItem}
                getItemLayout={this.getItemLayout}
                onMomentumScrollEnd={this.onMomentumScrollEnd}
                data={entries}
                renderCell={this.renderCell}
                horizontal={true}
                onContentSizeChange={this.onContentSizeChange}
                onLayout={this.onLayout}
              />
            )}
          </ContainerWrapperView>
        ) : (
          <View style={wrapperViewContainer}>
            {this.renderCell({ item: entries[0], index: 0 })}
          </View>
        )}
      </FocusableGroup>
    );
  }

  renderCell({ item, index }) {
    const entries = this.prepareDataSource();
    const nextInitialFocusedIndex = this.state.focusedItem;

    const { onFocus, onPress } = this;
    const {
      CellRenderer,
      component: { id },
      componentPositionIndex,
    } = this.props;
    const focusIndex = this.state && this.state.focusedItem;
    const forceFocus = (focusIndex && focusIndex === index) || false;

    const initialItemIndex =
      nextInitialFocusedIndex ||
      (this.props.isScreenWrappedInContainer || entries.length <= 1
        ? 0
        : buffer);

    return (
      <BaseCell
        index={index}
        key={index}
        item={item}
        onPress={onPress}
        onFocus={onFocus}
        onLayout={this.onCellLayout}
        groupId={id}
        CellRenderer={CellRenderer}
        forceFocus={forceFocus}
        componentPositionIndex={componentPositionIndex}
        initialItemId={focusableItemId(item, initialItemIndex)}
      />
    );
  }

  prepareDataSource() {
    const { component, isScreenWrappedInContainer } = this.props;
    const entries = R.path(["zappPipesData", "data", "entry"], this.props);

    if (this.dataSource === null && entries && entries.length > 0) {
      const entriesAfterLimit = itemLimitForData(entries, component);
      this.dataSourceCount = entriesAfterLimit && entriesAfterLimit.length;
      this.dataSource = [];
      if (this.dataSourceCount > 1 && !isScreenWrappedInContainer) {
        const customDataSourceCount = this.dataSourceCount + 2 * buffer;
        var i;
        for (i = 0; i < customDataSourceCount; i++) {
          const index = this.indexFromDataSource(i);
          if (entries.length > index) {
            let entry = entries[index];
            this.dataSource.push(entry);
          }
        }
      } else {
        this.dataSource = entriesAfterLimit;
      }
    }
    return this.dataSource;
  }

  offsetForItemAtIndex(index) {
    const { isScreenWrappedInContainer } = this.props;
    if (this.dataSourceCount === 1) {
      return this.dataSourceCount;
    }
    const pageSize = itemsPerPage;
    const pageIndex = index / pageSize;
    const firstItemOnPageIndex = pageIndex * pageSize;
    const offset = isScreenWrappedInContainer
      ? 0
      : (this.viewFrame.width -
          pageSize * this.cellWidth -
          minimumLineSpacing) /
          2.0 +
        minimumLineSpacing;

    return firstItemOnPageIndex * this.cellWidth - offset;
  }

  indexFromDataSource(index) {
    const { dataSourceCount } = this;
    let wrapped =
      index - buffer < 0 ? dataSourceCount + (index - buffer) : index - buffer;
    return wrapped % dataSourceCount;
  }

  setFocusableGroupFocusDisabled(isFocusDisabled) {
    const isFunctionExists = R.compose(
      R.is(Function),
      R.prop("setNativeProps")
    )(this.focusGroupRef);
    if (isFunctionExists) {
      this.focusGroupRef.setFocusDisabled(isFocusDisabled);
    }
  }
}
