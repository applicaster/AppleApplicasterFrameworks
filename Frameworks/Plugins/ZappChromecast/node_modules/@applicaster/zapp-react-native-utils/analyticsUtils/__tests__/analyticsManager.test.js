const mock_postEvent = jest.fn();
const mock_setPlugins = jest.fn();
const mock_postTimedEvent = jest.fn();
const mock_endTimedEvent = jest.fn();

jest.mock("react-native", () => ({
  NativeModules: {
    AnalyticsBridge: {
      postEvent: mock_postEvent,
      setPlugins: mock_setPlugins,
      postTimedEvent: mock_postTimedEvent,
      endTimedEvent: mock_endTimedEvent,
    },
  },
}));

const eventName = "event";
const payload = {};

const analyticsManager = require("../manager");

function clearAllMocks() {
  mock_postEvent.mockClear();
  mock_setPlugins.mockClear();
  mock_postTimedEvent.mockClear();
  mock_endTimedEvent.mockClear();
}

describe("isValidAnalyticsData", () => {
  beforeEach(clearAllMocks);

  it("returns false if eventName is not a string", () => {
    expect(analyticsManager.isValidAnalyticsData(42)).toBe(false);
    expect(analyticsManager.isValidAnalyticsData({})).toBe(false);
    expect(analyticsManager.isValidAnalyticsData([])).toBe(false);
    expect(analyticsManager.isValidAnalyticsData(() => ({}))).toBe(false);
  });

  it("returns false if payload is not an object", () => {
    expect(analyticsManager.isValidAnalyticsData(eventName, "string")).toBe(
      false
    );

    expect(analyticsManager.isValidAnalyticsData(eventName, 42)).toBe(false);

    expect(analyticsManager.isValidAnalyticsData(eventName, () => ({}))).toBe(
      false
    );
  });

  it("returns true if eventName is a string and payload is null or an object", () => {
    expect(analyticsManager.isValidAnalyticsData(eventName)).toBe(true);
    expect(analyticsManager.isValidAnalyticsData(eventName, payload)).toBe(
      true
    );
  });
});

describe("postAnalyticEvent", () => {
  beforeEach(clearAllMocks);

  it("calls the postEvent method of the analytic bridge", () => {
    analyticsManager.postAnalyticEvent(eventName, payload);
    expect(mock_postEvent).toHaveBeenCalledWith(eventName, payload);
  });

  it("skips the event if it is not valid", () => {
    analyticsManager.postAnalyticEvent(42);
    expect(mock_postTimedEvent).not.toHaveBeenCalled();
  });
});

describe("providePlugins", () => {
  beforeEach(clearAllMocks);

  it("calls the setPlugins method of the analytic bridge", () => {
    const plugins = [];
    const plugin_configurations = {};
    const callback = jest.fn();

    analyticsManager.providePlugins(plugins, plugin_configurations, callback);

    expect(mock_setPlugins).toHaveBeenCalledWith(
      plugins,
      plugin_configurations,
      callback
    );
  });
});

describe("startAnalyticsTimedEvent", () => {
  beforeEach(clearAllMocks);

  it("calls the postTimedEvent of the analytic bridge", () => {
    analyticsManager.startAnalyticsTimedEvent(eventName, payload);
    expect(mock_postTimedEvent).toHaveBeenCalledWith(eventName, payload);
  });

  it("skips the event if it is not valid", () => {
    analyticsManager.startAnalyticsTimedEvent(42);
    expect(mock_postTimedEvent).not.toHaveBeenCalled();
  });
});

describe("endAnalyticsTimedEvent", () => {
  beforeEach(clearAllMocks);

  it("calls the endTimedEvent of the analytic bridge", () => {
    analyticsManager.endAnalyticsTimedEvent(eventName, payload);
    expect(mock_endTimedEvent).toHaveBeenCalledWith(eventName, payload);
  });

  it("skips the event if it is not valid", () => {
    analyticsManager.endAnalyticsTimedEvent(42);
    expect(mock_postTimedEvent).not.toHaveBeenCalled();
  });
});
